module separate-compilation

imports cleardep/cleardep
imports cleardep/fileutils
imports separate-compilation/utils
imports separate-compilation/process-deps
imports separate-compilation/separate-compilation-options

signature
	constructors
		IncludeAST: Term * String -> Include

strategies

    /*strc-front-end =
        log-timed(
          strc-get-infile
  		;strc-pack-stratego-trm
  		; tfc1(|"Stratego-Sugar-Cong", "pack")
    		; strc-output-ast
        	; frontend
        | "Front-end succeeded"
        , 1
        )*/
	  
    strc-front-end1(back-end) =
	{| CompilingModules, ImportMap :
      log-timed(
        strc-get-infile ;
	    separate-compilation-front-end(back-end|<get-config <+ !"" > "-p",<get-config;string-ensure-trailing-slash <+ !"./"> "-o")
      | "Front-end succeeded", 1) |}
	
  	strc-front-end2 = 
      //  strc-get-infile
      //  ; strc-pack-stratego-trm
  		tfc1(|"Stratego-Sugar-Cong", "pack")
        ; strc-output-ast
  	  	; frontend



	separate-compilation-front-end(back-end|working-package,working-output)=
		 // create-compilation-units(|working-package, working-output)
		  where(fileName := <\FILE(s) -> s\>)
		  
	// Make a relative file of the given with respect to the include path, then read or create the compilation unit for this file
		; !AbsolutePath(fileName)
		; path-relativize (|
			<pack-include-path;fetch-elem(\IncludeDir(d) -> AbsolutePath(d)\)> )
		; if complete-rebuild 
			then create-compilation-unit(|<id>)
			else read-or-create-compilation-unit(|<id>)
		  end
	// Create the build schedule for the compilation unit and flatten it
		; ![<id>]
		; createBuildSchedule(|<get-schedule-mode>)
		; flattenBuildSchedule
		; log(|Info(), ["Calculated build schedule ", <id>])
	// Compile according to the build schedule, outer map maps over the build tasks in the build schedule
		; map(	not(needsTaskToBeBuild) <+ (task-get-units
				; log(|Info(), ["Compile Build Task " , <id>])
	// Compile each compilation unit in the task
				; map(	 
						compile(back-end|working-package,working-output)
					))
	// Calculate the transitive interface hashes for all files and then register them as module dependency 
				; map (calculate-transitive-interface-hash)
				; where( map ({unit: 
					  id => unit
					; get-all-module-dependencies ;debug
					; map(update-module-dependency-interface(|unit))
					}))
	// Finally write all units
				; map (write-compilation-unit)
				
		)
		

	
	compile (back-end|working-package,working-output)=
	  if !AbsolutePath(working-output);not(path-is-directory)
	    then log(|Error(), ["Given path is not a directory or does not end with a slash: ", working-output]); fail
	  end
	; id => read-unit
	; get-stratego-source-file
	; path-get-full-path
	; !FILE(<id>)
	; where(fileName := <\FILE(s) -> s\>)
	; if !read-unit; is-persisted; is-consistent-shallow; is-consistent-to-interfaces
		then 
			  log(|Info(),["Check to compile, is consistent to interfaces, do not compile ", fileName])
			; !read-unit => work-unit
		else
			  \ FILE(s) -> (IncludePathName(s),<pack-include-path>)\
			; pack-process-options
			; where(incl := <get-config <+ ![]> "-I")
			; where(libs := <get-config <+ ![]> "-la")
			; log(|Info(), ["Parse file:         ", <id>])
			; (separate-compilation-parse-file <+ log(|Error(), ["File not found: ", <id>])) => parseResult
			; where(moduleName:=<\(_,Module(name,_))->name\><id>)
			; log(|Info(), ["Check to compile, need to compile ", moduleName])
			; log(|Info(), ["Compile to package: ", working-package])
			; log(|Info(), ["Place files in:     ", working-output])
			; rules(CompilingModules: moduleName -> 1)
			; create-compilation-unit-for-module(|moduleName) => work-unit
			; where (!work-unit; get-module-dependencies; debug)
			; save-and-set-options(
				  where(<debug> "Rewrite")
				  ; !parseResult
				  ; (separate-compilation-rewrite-imports(back-end|moduleName, work-unit, working-package,working-output)) => (ast, newLibs)
				  ; where(<set-config>("-I", <conc;make-set> (<map(Third;Snd;!IncludeDir(<id>))> newLibs, incl)))
				  ; where(<set-config>("-la", <conc;make-set> (libs, <map(Fst)> newLibs)))
				  ; log(|Notice(), ["Import transformation for ", moduleName])
				  ; log(|Notice(), ["Use import dirs: " , <get-config> "-I"])
				  ; log(|Notice(), ["Use libraries:   " , <get-config> "-la"])
				  ; !IncludeAST(ast,fileName)
				  ; pack-stratego(|<pack-include-path>) => (files, spec)
				  ; !spec
				  ; log(|Notice(), ["Calling Frontend for ", moduleName])
				  ; strc-front-end2
				  ; log(|Notice(), ["Calling Backend for ", moduleName])
				  ; back-end(|work-unit)
			  | working-package,working-output,fileName,moduleName)
			; !work-unit
			; where (!work-unit; get-module-dependencies; debug)
			; rules(CompilingModules-: moduleName)
			; log(|Info(), ["Compilation of ", moduleName, " completed."])

			; where(<set-config> ("-la", libs); <set-config> ("-I", incl))
	  end

	string-char-replace(|c1, c2) = explode-string; map((?c1;!c2)<+id); implode-string
	
	
	to-library-name = separate-compilation-modify-filename(if or(?"char",?"term") then !["_", <id>];concat-strings end ; jify)
	to-java-compilation-folder:   modulename -> <to-library-name;jify> modulename
	to-java-compilation-filename: modulename -> <to-library-name;path-get-filename;jify> modulename
	to-java-compilation-rel-file: modulename -> <concat-strings> [<to-java-compilation-folder> modulename ,"/",<to-java-compilation-filename> modulename]
	to-java-compilation-abs-path (| working-output):modulename -> <concat-strings> [working-output, <to-java-compilation-folder> modulename, "/"]
	to-java-compilation-abs-file (| working-output) =
		  id => modulename 
		; to-java-compilation-filename
		; string-path-append(|<to-java-compilation-abs-path(|working-output)> modulename)

	save-and-set-options(s|working-package,working-output,filename, modulename) = 
		where(input := <get-config> "-i"; output := <get-config> "-o"; package := <get-config> "-p"; islib := <get-config<+!0> "--library"; baseout := <get-config> "baseout");
		where(	<set-config> ("-i",filename));
		where(	<set-config> ("-p", <concat-strings>[working-package, ".", <to-library-name;jify;string-char-replace(|'/','.');string-char-replace(|'-','_')> modulename]));
		where(	<set-config>("-o", <to-java-compilation-abs-path(|working-output); (mkdirs <+ err(|"Creating dir failed"))> modulename));
		where(	<set-config> ("baseout" ,<to-java-compilation-abs-file(|working-output)> modulename));
		where(  <set-config> ("--library" ,""));
		s;
		where(<set-config> ("-i", input); <set-config> ("-o", output); <set-config> ("-p", package); <(?0;!"--library";rm-config)<+id> islib; <set-config> ("baseout", baseout))
	 
	mkdirs = 
	file-exists <+ mkdir <+ where(explode-string;reverse;drop(|1);drop-until(?'/');drop(|1);reverse;implode-string;mkdirs);mkdir
	
	create-compilation-unit-for-module(|module-name) = 
		  create-compilation-unit(|<separate-compilation-get-relative-file;where(path-exists)> module-name)
	
	read-compilation-unit-for-module(|module-name) = 
		  read-compilation-unit(|<separate-compilation-get-relative-file;where(path-exists)> module-name)
	
	separate-compilation-rewrite-imports(back-end|module-name, module-unit, working-package,working-output) =
		?(fileName, <id>);
		let
			to-library-import = ?Import(<id>);to-library-name;\name -> [name,"/",<path-get-filename> name]\;concat-strings;!Import(<id>)
			
			import-to-flag = \Import(name) -> 
				(<concat-strings>[working-package, ".", <to-java-compilation-folder;string-char-replace(|'/','.')> name],
				 <concat-strings> [working-output, <to-library-name> name], 
				 (name,Import(<to-java-compilation-rel-file> name)),
				 <separate-compilation-get-file> name )\
			
		
					
			maybe-compile(|imported-module-name) = 
			{| import-unit:
				 (read-compilation-unit-for-module(|imported-module-name)
				 	<+ (where(<debug> "Create");create-compilation-unit-for-module(|imported-module-name);debug)) // => import-unit
						;debug
				; if equal(| module-unit)
					then	  log(|Info(), ["Module imports itself ", module-name])
					else
						  add-module-dependency(|module-unit)
						; if depends-on-transitivly-on-other(|module-unit, <id>)
							then
							  log(|Info(),[module-unit , " depends transitivly, do not follow import ", imported-module-name])
							; if depends-on-transitivly-noncircularly(|module-unit)
								then log(|Info(), ["Imports depends on module ", imported-module-name , " - ", module-name])
								else log(|Info(), ["Module depends on import ", module-name, " - " , imported-module-name])
							  end
							else
							  if !imported-module-name; CompilingModules
								then log(|Info(), ["Module ", imported-module-name, " is already in work, do not follow import"])
								else  //add-module-dependency(|module-unit);
									  log(|Info(),["From ", module-name ," follow import ", imported-module-name]);debug
									; compile(back-end|working-package,working-output)
							  end
					end
				end
			|}
	
		in
		fold-on-imports(
			import-is-file,
			where(maybe-compile(|<\Import(name) -> name\> <id>));to-library-import, 
			import-to-flag) end
		   
	separate-compilation-get-file : name->
		FILE(<pack-include-path;fetch-elem(\IncludeDir(dir) -><concat-strings; file-exists> [dir,"/", name, ".str"]\)>)
	separate-compilation-get-relative-file : name->
		<pack-include-path;fetch-elem(
			\IncludeDir(dir) -> 
				<where(<concat-strings; file-exists> [dir,"/", name, ".str"])>
					 RelativePath(AbsolutePath(dir), <concat-strings> [name, ".str"])\)>
			
	separate-compilation-modify-filename(s) =
		let
			split-string = reverse;split-at(?'/');tmap(reverse;implode-string)
			in explode-string;fetch(?'/') < split-string;?(name, path);![path, "/", <s> name];concat-strings+ s end
	
	separate-compilation-replace-file = 
		let
			cut-until-slash = explode-string;reverse;drop-until(?'/');reverse;implode-string
			in \(filePath, newName) -> <conc-strings> (<cut-until-slash> filePath, newName)\ end
			

		    pack-include-from-dir-exists(|mod) :
		      IncludeDir(dir) ->  <concat-strings; file-exists> [dir,"/", mod, ".str"]
			  
			  pack-include-from-xtc-exists(|mod) :
			    IncludeXTC() -> <conc-strings; xtc-find-loc> (mod, ".str")

separate-compilation-check-file =
   ?(IncludeFromPath(<id>), includes)
  ; if has-extension(|"str") then
      remove-extension
    end
  ;  ?mod
  ;  <fetch-elem(
         pack-include-from-dir-exists(|mod)
         <+ pack-include-from-xtc-exists(|mod)
       )
     > includes /// separate-compilation-parse-file
	 
	 
  separate-compilation-check-file = 
     let pack-qualify-pathname =
             where(explode-string => cs)
           ; if <pack-is-qualified> cs then
               id
             else
               <implode-string> ['.', '/' | cs]
             end
 
          pack-is-qualified =
            ?['/' | _] + ?['.' | _ ] + ?['\' | _] + [is-alpha, ':', '\' | id]

      in ?(IncludePathName(<pack-qualify-pathname>), _)
       ; if file-exists then
            pack-include-pathname
            ; (id,report-ambs)
              // (id, xtc-transform(!"report-ambs")) // EV
            ; pack-fc(|"Stratego-Sugar-Cong")
          else
		  fail
          end
     end
	
    separate-compilation-parse-file =
       ?(IncludeFromPath(<id>), includes)
      ; if has-extension(|"str") then
          remove-extension
        end
      ;  ?mod
      ;  <fetch-elem(
             pack-include-from-dir(|mod)
             <+ pack-include-from-xtc(|mod)
           )
         > includes
      ; (id, report-ambs)
      ; pack-fc(|"Stratego-Sugar-Cong")
	  
	  separate-compilation-parse-file = 
      let pack-qualify-pathname =
              where(explode-string => cs)
            ; if <pack-is-qualified> cs then
                id
              else
                <implode-string> ['.', '/' | cs]
              end
  
           pack-is-qualified =
             ?['/' | _] + ?['.' | _ ] + ?['\' | _] + [is-alpha, ':', '\' | id]

       in ?(IncludePathName(<pack-qualify-pathname>), _)
        ; if file-exists then
            pack-include-pathname
            ; (id,report-ambs)
              // (id, xtc-transform(!"report-ambs")) // EV
            ; pack-fc(|"Stratego-Sugar-Cong")
          else
		  fail
          end
      end