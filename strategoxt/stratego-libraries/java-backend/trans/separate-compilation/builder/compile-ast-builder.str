module separate-compilation/builder/compile-ast-builder

imports libstrategolib
imports libstrc

imports cleardep/fileutils
imports pluto/builder
imports pluto/build-cycle-at-once-builderfactory

imports separate-compilation/builder/deps-path
imports separate-compilation/rewrite-imports
imports separate-compilation/std-lib-utils
imports separate-compilation/separate-compilation-options
imports separate-compilation/compiler-config
imports separate-compilation/utils
imports separate-compilation/booleans
imports separate-compilation/create-signature
imports separate-compilation

imports strj

signature
	constructors
		
		CompileASTInput: ModuleName * AST * Path * JavaPackage * OutputFolder * MainModule * PackIncludePath -> CompileASTInput
		CompileASTOutput: RTreeFile -> CompileASTOutput
		
		
strategies
		
	compile-asts(input-for-module) = let
	// Accessor strategies such that the input can be extended with other values without need to change all pattern matches
		get-module-name = {name: \ CompileASTInput(name, _, _, _, _, _, _) -> name\}
		get-ast = {ast: \ CompileASTInput(_, ast, _, _, _, _, _) -> ast\} 
		get-path = {path: \ CompileASTInput(_, _, path, _, _, _, _) -> path\}
		get-java-package = {package: \ CompileASTInput(_, _, _, package, _, _, _) -> package\}
		get-output-folder = {folder: \ CompileASTInput(_, _, _, _, folder, _, _) -> folder\}
		get-pack-include-path = {path: \ CompileASTInput(_, _, _, _, _, _, path) -> path\}
		get-main-module-name = {path: \ CompileASTInput(_, _, _, _, _, main-module, _) -> main-module\}
		
	compile-asts(input-for-module|circular-module-names) = let
	
		
		
		/* Selects from a list of inputs the input with the module name, which is first in lexicographical order. But of the
		 * given main-module-name is contained, this one is taken.
		 * Returns a pair of the other inputs and the selected ones
		 * The module name is extracted by select-module-name from the input
		 *
		 * @param select-module-name: a -> String
		 * @type [a] -> ([a], a)
		 */ 
		determine-circular-result-module(select-module-name | main-module-name) = {x, xs:
			?[x|xs];
			!(xs, ([], x));
			foldl( {other-modules, first-module, current-module:
				?(current-module, (other-modules, first-module));
				if (<select-module-name;equal(|main-module-name)>  first-module)  <+ (<tmap(select-module-name);string-gt> (current-module, first-module))
					then !([current-module | other-modules], first-module)
					else !([first-module | other-modules], current-module)
				end })
			}
				
		rewrite-imports(|circular-module-names) = {module-name, ast, path, java-package, output-folder, generate-main, pack-include-path, transformed-ast, new-libs,  imported-rtree-files, main-module-name: \
			input -> (module-name, transformed-ast, new-libs, path, main-module-name, imported-rtree-files)
			where
				log(|Notice(), ["Rewrite imports"]);
				module-name := <get-module-name> input;
				ast := <get-ast> input;
				path := <get-path> input;
				java-package := <get-java-package> input;
				output-folder := <get-output-folder> input;
				main-module-name := <get-main-module-name> input;
				pack-include-path := <get-pack-include-path> input;
				<separate-compilation-rewrite-imports(|module-name, main-module-name, circular-module-names, java-package, output-folder, pack-include-path)> ast => ((transformed-ast, new-libs), imported-rtree-files)
			\}
			
		combine-modules = {:
			log(|Notice(), ["Combine modules ", <id>]);
			// Import transformation guarantees that all imports are in the first place in the module in a single Imports term
			foldl({imports, content, libs, main-module-name, rtree-files: \
				( (_, Module(_, [Imports(new-imports)| new-content]), new-libs, _, new-main-module-name, new-rtree-files), (moduleName, Module(merged-name, [Imports(merged-imports) | merged-content]), merged-libs, fileName, merged-main-module-name, merged-rtree-files) ) ->
				(moduleName, Module(merged-name, [imports | content]), libs, fileName, main-module-name, rtree-files)
				where
					imports := Imports(<conc;make-set> (new-imports, merged-imports));
					content := <conc> (new-content, merged-content);
					libs := <conc> (new-libs, merged-libs);
					main-module-name := merged-main-module-name;
					<eq> (new-main-module-name, merged-main-module-name);
					rtree-files := <conc>(new-rtree-files, merged-rtree-files)
			\});
			log(|Notice(), ["Result ", <id>])
			}
			
		add-std-lib-import-if-required = let
			add-default-lib-import =  {merged-name, imports, content :
		  		is-generate-stdlib-import;
				log(|Notice(), "Add import to libstratego-lib");
		 		((
		  			?Module(merged-name, [Imports(imports)|content]);
					!Module(merged-name, [Imports(<make-set> [Import("libstratego-lib")|imports]) | content])
				) <+ fatal-err(|["Unable to add default lib import to ", <id>])) 
				}
		in
			(id, try(add-default-lib-import), id, id, id, id)
		end
			
		call-front-end(|pack-include-path) = {moduleName,merged-ast, fileName, files, spec:
			?(moduleName, merged-ast, _, fileName, _, _);
			
			log(|Notice(), ["Import transformation for ", moduleName]);
			log(|Notice(), ["Use libraries:   " , <get-config> "-la"]);
			log(|Notice(), ["Pre pack ",merged-ast]);
			<pack-stratego(|pack-include-path)> IncludeAST(merged-ast,fileName) => (files, spec);
			log(|Notice(), ["After pack ", files, " " , spec]);
			log(|Notice(), ["Calling Frontend for ", moduleName]);
			!spec;
			tfc1(|"Stratego-Sugar-Cong", "pack");
         	strc-output-ast;
  	  		frontend;
			strc-optimize 
			}
			
		create-rtree-file(|module-name, generate-main, dep-rtree-files) =  {rtree-file:
			log(|Info(), ["Calculating transitive externals for ", module-name]);
			calculate-transitive-externals(
				and(is-remove-overlays-from-externals,<b-true> generate-main)
						|dep-rtree-files
				) => rtree-file;
			<provide-for(|<input-for-module> module-name)> rtree-file;
			!rtree-file
			}
			
		call-back-end = {ops, defs:
			// Remove Overlays for Backend, they are only important for externals
			\Specification([Signature([Constructors(ops)]), _ , Strategies(defs)]) -> Specification([Signature([Constructors(ops)]), Strategies(defs)])\;
			strj-back-end
			}
				
			
		generate-dummy-module-input(|result-module-name, main-module-name, java-package, output-folder, pack-include-path) = {module-name, file-name: \
			(module-name, _, _, file-name, _, _) ->
					CompileASTInput(module-name, Module(module-name, [Imports([Import(result-module-name)])]), file-name, java-package, output-folder, main-module-name, pack-include-path) 
			\}
		
		create-dummy-modules(|java-package, output-folder, pack-include-path) = {dummy-inputs, other-modules, result-module-name, main-module-name: \
			 (other-modules, (result-module-name, _,_,_,main-module-name,_)) -> ()
			where
				log(|Notice(), 120);
				dummy-inputs := <map(generate-dummy-module-input(|result-module-name, main-module-name, java-package, output-folder, pack-include-path))> other-modules;
				log(|Notice(), 121);
				<map(
					log(|Notice(), ["Compiling circular dummy module for ", <get-module-name>]);
					![<id>];
					compile-asts(input-for-module|circular-module-names))> dummy-inputs
		\}
				 
		
	in {inputs, java-package, output-folder, pack-include-path, other-inputs, result-input, result, input, moduleName, merged-ast, new-libs, fileName, libs, generate-main, rtree-file, imported-rtree-files, main-module-name:
		id => inputs;
		log (|Notice(), 6);
		where( {first-input:
			!inputs;
			?[first-input|_];
			java-package := <get-java-package> first-input;
			output-folder := <get-output-folder> first-input;
			pack-include-path := <get-pack-include-path> first-input;
			main-module-name := <get-main-module-name> first-input
		});
		log (|Notice(), 7);
		// Rewrite the imports in the AST
		<map(rewrite-imports(|circular-module-names))> inputs;
		log (|Notice(), 8);
		// Circular modules will be merged, make the result module deterministic
		determine-circular-result-module(Fst | main-module-name) => (other-inputs, result-input);
		log (|Notice(), 9);
		combine-modules;
		log (|Notice(), 10);
		add-std-lib-import-if-required;
		log (|Notice(), 11);
		?(moduleName, merged-ast, new-libs, fileName, main-module-name, imported-rtree-files);
		where (generate-main := <b-strategy-successful(fetch-elem(equal(|main-module-name)))> circular-module-names );
		log(|Notice(), ["Generate main ", generate-main]);
		log (|Notice(), 115);
		save-and-set-options(
			log (|Notice(), 12);
			where(<set-config>("-la", <conc;make-set> (<get-config <+ ![]> "-la", new-libs)));
			log (|Notice(), 13);
			call-front-end(|pack-include-path);
			log (|Notice(), 14);
			// TODO Generate rtree
			log(|Notice(), ["Imported rtree files ", imported-rtree-files]);
			where(<create-rtree-file(|moduleName,  generate-main, imported-rtree-files)> <id> => rtree-file);
			log(|Notice(), ["Generated rtree-file " , rtree-file]);
			log(|Notice(), ["Calling Backend for ", moduleName]);
			call-back-end;
			log (|Notice(), 15)
		|generate-main, java-package, output-folder, fileName, moduleName, circular-module-names);
		log (|Notice(), 16);
		where(<create-dummy-modules(|java-package, output-folder, pack-include-path)> (other-inputs, result-input));
		log (|Notice(), 17);
		log (|Notice(), ["Output for " , result-input, " is " , rtree-file]);
		where( {result-module-name:
			result-module-name := <Fst> result-input;
			rules(Output: result-module-name -> CompileASTOutput(rtree-file))})
	} end
	
	in {inputs: {|Output: 
		?inputs;
		<compile-asts(input-for-module|<map(get-module-name)> inputs)> inputs;
		log (|Notice(), 18);
		<map(get-module-name;Output)> inputs;
		log (|Notice(), 19)
	|}}end