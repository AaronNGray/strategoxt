module separate-compilation/rewrite-imports

imports libstrategolib
imports libstrc

imports cleardep/fileutils

imports pluto/builder
imports pluto/buildrequest

imports separate-compilation/utils
imports separate-compilation/fileutils
imports separate-compilation/std-lib-utils
imports separate-compilation/booleans

imports separate-compilation/builder/compile-module-builder
imports separate-compilation/builder/parse-stratego-builder
imports separate-compilation/builder/rtree-stamper
imports separate-compilation/stamper/is-specification


strategies
	
	separate-compilation-rewrite-imports(|module-name, circular-module-names, working-package, working-output, pack-include-path) = {|RTreeFiles :
		let
			to-library-import:
				Import(name) -> Import(<to-java-compilation-rel-file> name)
			
			import-to-flag(|working-package):
				Import(name) -> 
					<conc-strings>(working-package, ".", <to-java-compilation-folder;string-char-replace(|'/','.')> name)
				
			
		
					
			require-imported-module(|imported-module-name) = {rtree-file:
				if <equal>(module-name, imported-module-name)
					then	log(|Info(), ["Module imports itself ", module-name])
					else
						// Require to build the imported module, then the rtree file can be used
						<require-build> BuildAtOnceBuildRequest(<compile-module-builder-factory>, [CompileModuleInput(imported-module-name, pack-include-path, working-package, working-output, False())])
							=> CompileModuleOutput(rtree-file);
						log(|Notice(), ["Require rtree file ", rtree-file]);
						<require-stamper(|<rtree-stamper>)> rtree-file;
						log(|Notice(), ["Collect rtree file ", rtree-file]);
						where (rules(RTreeFiles :+= rtree-file))
						
				end }
				
			
			
			get-file-add-external-file-dependency = {import-name, file: \
				import-name -> ()
				where 
					file := <separate-compilation-get-relative-file> import-name;
					<require> file\}
			
			is-import-module= {ast, parse-input, module-name, file:
				log(|Notice(), ["Is Module import ", <id>]);
				?Import(module-name);
				<parse-stratego-input-for-module;debug> (module-name,pack-include-path, working-output ) => (file, parse-input);
				//<require-stamper(|<is-specification-stamper>)> file; // 
				log(|Notice(), ["Input ", parse-input]);
				<require-build-stamper(|<is-parse-statrego-output-specification-stamper>);debug> BuildRequest(<parse-stratego-builder-factory>, parse-input)
			  			=> ParseStrategoOutput(_, ast);
			  	log(|Notice(), ["Result ", parse-input]);
			  	<?Module(_,_)> ast
			  	}
			  			
			
			process-import-str =
			{ term, name, module-name: 
				  ?(term, <has-extension(|"str")>)
				; where(<\Import(name) -> name\> term => module-name)
				; if <is-import-module> term
					then  // regular module dependency
					   log(|Notice(), ["Import to module ", term])
					 ; if <elem> (module-name, circular-module-names) 
						then fail // Circular, do not transform
						else 
							require-imported-module(|module-name);
							<to-library-import> term  // Transform term to library import
				  	   end
					else // Import contains not a module but a specification -> no module dependency because specification is not named
					   log(|Notice(), ["Import to file but not module ", term])
					 ; <get-file-add-external-file-dependency> module-name
					 ; !term //Leave term untransformed because want to include str file
				  end			
			}
				
			process-import-rtree =
			{ file, term :
				  ?(term, file)
				; where(<has-extension(|"rtree")> file)
				; <require-stamper(|<rtree-stamper>)> AbsolutePath(file)
				; !term
				}
				
			process-import-default-lib = 
			{ lib, term:
				  ?(term, lib)
  				; !term
				; ?Import(<id>)
  				; is-default-lib-rtree
  				; !term
  				// Do not add as dependency, because it is inside a jar and the jar is safe to move and not expected to change
			}
			
				
			
				
	
		in {| File: 
		  log(|Notice(), ["Rewrite ", <id>]);
		  transform-imports-and-move-to-front(
			{import, file:
				  id => import
				; if not(Import(is-default-lib-rtree))
				   then 
					  import-get-file => file
				    ; rules(File: import -> file)
			       end
			},
			  !(<id>, <id;try(File)>)
			; (process-import-str + process-import-rtree + process-import-default-lib)
			, {term:
			  	?term;
			  	if try(File);has-extension(|"str")
				then 
					  where (<is-import-module> term)
					; import-to-flag(|working-package)
				else 
					  ?Import(<id>)
					; where(is-default-lib-rtree)
					; remove-lib-prefix
					; translate-default-library // do not want to collect rtrees, but libraries
				end
			   }
			);
			!(<id>, <bagof-RTreeFiles <+ ![]>)
		|}
		end |}
		
	 	
