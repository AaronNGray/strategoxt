module backend-simplify

imports
  libstratego-lib
  libstrc
  
  lib/dr-scoping
  split-large-strategies
  
signature
 constructors
   Meta: List(Term) -> Term
   Filename: Str -> Term
   
   
   StaticLiftedStartegy : BindRule
   StaticIdFail : BindRule
   StaticDCommandLineStartegy : BindRule
  
strategies

  main-backend-simplify =
    io-wrap(backend-simplify)
  
  backend-simplify =
    dr-scope-all-verbose(
      dollars-for-capitals-top
    ; split-large-strategies
  //  ; lift-definitions
    ; canonicalize
    ; simplify1
    ; mark-bound-unbound-vars
    ; escaping-variables
    ; remove-closure-allocs

	; \x -> <annotate-static-calls>(x, [])\
	
    )

rules
  
  /**
   * Adds dollars to names with capitals (e.g. Desugar becomes $Desugar).
   * Doing so is required for supporting (Windows/Mac) case-insensitive file systems.
   */
  dollars-for-capitals-top =
    topdown(try(
      SVar(dollars-for-capitals)
    + SDefT(dollars-for-capitals, id, id, id)
    + ExtSDef(dollars-for-capitals, id, id)
    ))
   
  dollars-for-capitals =
    // We make an exception for the hand-crafted SRTS_EXT Java classes
    if not(string-starts-with(|"SRTS_EXT")) then
      escape(dollar-for-capital)
    end
  
  dollar-for-capital(rec) :
    [c | cs] -> ['$', c | <rec> cs] where <is-upper> c
  
  undo-dollars-for-capitals =
    escape(undo-dollar-for-capital)
  
  undo-dollar-for-capital(rec) :
    ['$' | cs] -> <rec> cs
  
rules

  remove-closure-allocs =
    {| RemoveClosureAlloc :
      alltd(remove-closure-alloc-let)
    |}
  
  remove-closure-alloc-let :
    Let(def*, s) -> Let(def'*, s')
    with
      def'* := <remove-closure-allocs>
               <filter(not(remove-closure-alloc-def))> def*
    ; s' := <remove-closure-allocs>
            <alltd(remove-closure-alloc-call)> s
    
  remove-closure-alloc-def :
    SDefT(x{a*}, _, _, s) -> []
    where
      <one(ClosureAlloc)> a*
    with
      x' := x{}
    ; rules(RemoveClosureAlloc: x' -> s)
  
  remove-closure-alloc-call :
    CallT(SVar(x), [], _) -> inline
    where
      <RemoveClosureAlloc> x{} => inline
		  

   // Mark strategy calls which needs to be bind statically and not be name for a strategy
   // Collect local definitions
   annotate-static-calls : 
    ( Let(defs,s), current_defs) -> 
			Let(<annotate-static-calls> (defs, new_defs), <annotate-static-calls> (s, new_defs))
		where
			new_defs := <conc>(current_defs, <map(annotate-def-to-sig)> defs)
			
   annotate-static-calls :
     (CallT(SVar(x{a*}), t, s), current_defs) -> CallT(SVar(x'), <annotate-static-calls> (t, current_defs), <annotate-static-calls> (s, current_defs))
     where
       
       x' := <(<need-bind-static>(<annotate-call-to-sig>CallT(SVar(x{a*}), t, s), current_defs) => bindrule;
       			!x{[bindrule | a*]} ) <+
       				 !x{a*}>
	   
			  
   annotate-static-calls :
     ( x, current_defs) -> <all(\y -> <annotate-static-calls> (y, current_defs)\)> x
			  
   // In the following cases this needs to be done are:
   need-bind-static :
   		(name, local-defs) -> StaticLiftedStartegy()
   			where <elem> (name, local-defs) // For local definitions
   need-bind-static :
   		(name, _) -> StaticIdFail()
   			where <elem> (name, ["_Id" , "_Fail"]) // For ID and FAIL
   need-bind-static : 
   		(name, _) -> StaticDCommandLineStartegy()
   			where <elem> (name, <(get-config <+ ![]);map(\(name, _) -> name\;dollars-for-capitals)> "-D") // And for generated constant value stratgies (really?)

   


   annotate-def-to-sig:  SDefT(x,t*,s*,_) -> x{}
   annotate-call-to-sig: CallT(SVar(x), t*, s*) -> x{}
	  
