module stratego/strc/front/call-graph

imports
	stratego/strc/model/model
	stratego/strc/front/rename-defs

strategies

  check-calls =
  {| CcHoArg:
    where(
      m-get-all-def-sigs
      ; map(register-ho-arg)
      ; filter(
          bagof-ModDefinition
          ; filter(not(check-calls-def))
          ; not(?[])
        )
      ; ?[]
    ) |}

  register-ho-arg =
    ?sig@(f, _, _)
    ; rules( CcHoArg :+ f -> sig )

  check-calls-def = 
    where(id
      ; where(sig := <m-def-signature>)
      ; svars-arity
      ; filter(svar-arity-to-sig; not(CheckCall(|sig)))
      ; ?[]
    )

  CheckCall(|dsig) = 
    ?sig
    ; if <not(ModDefinition)> sig then
        if ?(f, 0, 0) then
          <bagof-CcHoArg> f
          ; if ?[] then
		  		!sig;
			  strategy-not-found(|["*** ", dsig, " calls non-existing ", sig])
            //  ; fail
            else if not(?[_]) then
              err(|["*** ", dsig, " calls ", f, 
                    " as higher-order arg, but there is there more",
                    " than one definition for ", f])
              ; fail
            end end
        else
		!sig;
          strategy-not-found(|["*** ", dsig, " calls non-existing ", sig])
         // ; fail
        end
      end
	  
   if-strategy-forward-declaration(sthen, selse) =
      if <get-config> "--strategy-forward-declaration"
        then sthen
        else selse
      end
	  

  strategy-not-found(|msgs) =
  	if-strategy-forward-declaration(where(\(name, m, n) -> ExtSDef(name, <build-dummy-fun-args>m, <build-dummy-term-args>n)\; m-add-def);warn(|msgs),err(|msgs);fail)

	build-dummy-fun-args : 0 -> []
	build-dummy-fun-args : i -> Cons(VarDec("a",FunType([ConstType(Sort("ATerm",[]))],ConstType(Sort("ATerm",[])))), <dec;build-dummy-fun-args> i)
	build-dummy-term-args: 0 -> []
	build-dummy-term-args: i -> Cons(VarDec("l_1117",ConstType(Sort("ATerm",[]))), <dec;build-dummy-term-args> i)

  svar-arity-to-sig :
    (x, (i, j)) -> (x, i, j)

strategies

  /**
   * Remove all definitions that are not called from a
   * definition called (indirectly) by main and remove 
   * constructors that are not used in needed definitions.
   */

  remove-unused-defs =
    {| DefIsNeedeed
     : where(id
         ; <mark-used-defs-and-constructors> ("main_0_0", 0, 0)
         ; <mark-used-defs-and-constructors> ("DYNAMIC_CALLS_0_0", 0, 0)
         ; <map(mark-used-defs-and-constructors)> <bagof-AlwaysNeeded>
         ; m-get-all-def-sigs
         ; map(
              DefIsNeeded
           <+ m-rm-def
           )
	 ; m-get-all-constructors-sigs
	 ; map(ConstructorSigNeeded <+ m-rm-constructor)
       )
     |}

  mark-used-defs-and-constructors = ?sig
    ; if <not(DefIsNeeded)> sig then
        rules( DefIsNeeded : sig )
        ; bagof-ModDefinition
        ; where(topdown(try(DeclareConstructorSigNeeded)))
        ; svars-arity
        ; map(?(<id>,_); CallSignature; mark-used-defs-and-constructors)
      end

  DeclareConstructorSigNeeded =
    ?Op(c, ts)
    ; where(sig := (c, <length> ts))
    ; rules( ConstructorSigNeeded : sig )

  DeclareConstructorSigNeeded =
    ?Cong(c, ts)
    ; where(sig := (c, <length> ts))
    ; rules( ConstructorSigNeeded : sig )

  /**
   * Remove external definitions that are not called from
   * local definitions.
   *
   * This transformation is used for libraries, where all
   * local definitions are needed, but not necessarily all
   * external definitions.
   */

  remove-unused-external-defs =
    {| DefIsNeedeed
     : where(id
         ; m-get-all-local-def-sigs
         ; map(mark-used-defs)
         ; <mark-used-defs> ("DYNAMIC_CALLS_0_0", 0, 0)
         ; m-get-all-external-def-sigs
         ; map(DefIsNeeded <+ m-rm-def)
       )
     |}

  mark-used-defs = ?sig
    ; if <not(DefIsNeeded)> sig then
        rules( DefIsNeeded : sig )
        ; bagof-ModDefinition
        ; svars-arity
        ; map(?(<id>,_); try(CallSignature; mark-used-defs)) // try because of forward declaration of strategies
      end
