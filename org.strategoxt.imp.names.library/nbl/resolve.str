module nbl/resolve

imports
  
  nbl/tasks
  nbl/query
  nbl/lookup
  nbl/uri
  nbl/entries
  index/core
  
signature

  constructors
    
    COMPLETION : String -> COMPLETION
      
rules // Reference resolution
  
  nbl-resolve =
    switch ?t
      case has-annos:
        anno* := <get-annos; nbl-resolve; try(concat)> t; 
        !t{anno*}
      case ?Result(_):
        nbl-resolve-results;
        try(nbl-resolve)
      case ?Use(_): 
        nbl-resolve-uses
      case ?Def(_): 
        id
      otherwise:
        try(all(nbl-resolve))
    end

  nbl-resolve-collect = 
    has-annos;
    get-annos;
    collect-all(nbl-resolve-collect);
    concat
  
  nbl-resolve-collect:
    Use(_) -> def*
    where
      def* := <nbl-resolve-uses>
    
  nbl-resolve-collect:
    Def(_) -> [<id>]
    
  nbl-resolve-collect-one = nbl-resolve-collect; Hd
  
  nbl-resolve-results:
    Result(number) -> results
    where
      if not(results := <nbl-get-value> DoneTask(number, ())) then
        results := <nbl-get-value> FailTask(number, ()) 
      end
      
  nbl-resolve-uses:
    Use(Result(number)) -> def*
    where
      uri* := <nbl-get-value> DoneTask(number, ());
      def* := <mapconcat(\uri -> Def(uri)\; nbl-get-all)> uri*
      
  nbl-resolve-uses:
    Use(uri@URI(_, _)) -> def*
    where
      def* := <nbl-lookup-definitions> uri
      
  nbl-is-reference =
    ?Use(_)
    
  nbl-has-reference =
    collect-one(nbl-is-reference)
    
  nbl-has-reference =
    has-annos;
    get-annos;
    nbl-has-reference
 
  nbl-is-unresolved =
    ?node;
    has-annos;
    get-annos;
    nbl-has-reference;
    [] := <nbl-resolve-collect> node
    
rules // Code completion

  nbl-resolve-collect-uris = 
    has-annos;
    get-annos;
    collect-all(nbl-resolve-collect-uris);
    concat
    
  nbl-resolve-collect-uris = nbl-resolve-results

  nbl-propose-completions:
    ast -> proposals'*
      where
        item        := <collect-one(?COMPLETION(_))> ast;
        index-transaction(
          uri*      := <nbl-resolve-collect-uris; filter(nbl-uri)> item;
          proposal* := <mapconcat(nbl-visible-definitions)> uri*
        );
        proposals'* := <map(nbl-uri; nbl-uri-name)> proposal*

rules // Ambiguities
  
  nbl-get-ambiguities =
    nbl-resolve-collect;
    mapconcat(nbl-get-all-aliases);
    filter(nbl-uri; nbl-uri-parent);
    make-set;
    where(<gt> (<length>, 1))

rules // Duplicate definitions
  
  nbl-get-duplicate-definitions =
    has-annos;
    get-annos;
    collect-one(?Def(_));
    nbl-get-all-definitions;
    make-set;
    where(<gt> (<length>, 1))
