module nbl/resolve

imports
  
  nbl/collect
  nbl/tasks
  nbl/query
  nbl/lookup
  nbl/uri
  nbl/entries
  index/core
  
signature

  constructors
    
    COMPLETION : String -> COMPLETION
      
rules // Reference resolution
    
  nbl-resolve-all = 
    has-annos;
    get-annos;
    collect-all(nbl-resolve-all);
    concat
  
  nbl-resolve-all:
    Use(Result(number)) -> def*
    where
      uri*  := <nbl-get-value> DoneTask(number, ());
      def*  := <mapconcat(\uri -> Def(uri)\; nbl-get-all)> uri*
      
  nbl-resolve-all:
    Use(uri@URI(_, _)) -> def*
    where
       def* := <nbl-lookup-definitions> uri
  
  nbl-resolve = 
    has-annos;
    get-annos;
    collect-one(nbl-resolve)
  
  nbl-resolve:
    Use(Result(number)) -> <Hd> def*
    where
      uri* := <nbl-get-value> DoneTask(number, ());
      def* := <mapconcat(\uri -> Def(uri)\; nbl-get-all)> uri*
      
  nbl-resolve:
    Use(uri@URI(_, _)) -> <Hd> def*
    where
      def* := <nbl-lookup-definitions> uri

rules // New resolve
  
  nbl-resolve-new =
    switch ?t
      case has-annos:
        get-annos;
        nbl-resolve-new;
        try(concat);
        !t{<id>}
      case ?Result(_):
        nbl-resolve-result;
        try(nbl-resolve-new)
      case ?Use(_): 
        nbl-resolve-use
      case ?Def(_): 
        id
      otherwise:
        try(all(nbl-resolve-new))
    end
  
  nbl-resolve-result:
    Result(number) -> [done*, fail*]
    with
      (<nbl-get-value> DoneTask(number, ()) <+ ![]) => done*;
      (<nbl-get-value> FailTask(number, ()) <+ ![]) => fail*
      
  nbl-resolve-use:
    Use(result@Result(number)) -> def*
    where
      def* := <nbl-resolve-result; mapconcat(nbl-get-all-definitions)> result
      
  nbl-resolve-use:
    Use(uri@URI(_, _)) -> def*
    where
      def* := <nbl-lookup-definitions> uri
    
rules // Code completion

  nbl-unresolved-uris = 
    has-annos;
    get-annos;
    collect-all(nbl-unresolved-uri);
    concat
      
  nbl-unresolved-uri:
    Use(result) -> <nbl-resolve-result> result

  nbl-propose-completions:
    ast -> proposals'
      where
        item        := <collect-one(?COMPLETION(_))> ast;
        index-transaction(
          uris      := <nbl-unresolved-uris> item;
          proposals := <mapconcat(nbl-visible-definitions)> uris
        );
        proposals'  := <map(nbl-uri; nbl-uri-name)> proposals

rules // Ambiguity
  
  nbl-get-ambiguities =
    nbl-resolve-all;
    mapconcat(nbl-get-all-aliases);
    filter(nbl-uri; nbl-uri-parent);
    make-set;
    where(<gt> (<length>, 1))

rules // Conditions
	
  nbl-is-reference =
    ?Use(_)
    
  nbl-has-reference =
  	collect-one(nbl-is-reference)
 
  nbl-is-unresolved =
  	?node;
    has-annos;
    get-annos;
    nbl-has-reference;
    <not(nbl-resolve)> node
    
  nbl-is-duplicate-definition =
    has-annos;
    get-annos;
    collect-one(?Def(_));
    nbl-get-all-aliases;
    <gt> (<length>, 1)
