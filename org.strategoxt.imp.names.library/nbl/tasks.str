module nbl/tasks

imports 
  
  task/core
  nbl/lookup
  nbl/collect
  nbl/resolve
  nbl/query
  nbl/interface
  nbl/uri
  nbl/utils
  
signature
  
  constructors
    
    Resolve  : Result * Namespace * Name * List(Prop) * Range -> Instruction
    PropCalc : Property * Term                                -> Instruction
    Match    : ID * Term                                      -> Instruction
    Noop     :                                                   Instruction
    
    Stall : Instruction
        
rules // Resolve
  
  perform-task: 
    Resolve(uri, namespace, name, prop*, range) -> result
    where
      not(<is-list> uri);
      result := <perform-task> Resolve([uri], namespace, name, prop*, range)
  
  perform-task: 
    Resolve(uri*, namespace, name, prop*, range) -> result
    where
      <is-list> uri*;
      // TODO: Get rid of flatten-list?
      resolved* := <flatten-list; remove-all(?Fail(_)); mapconcat(perform-task-resolve(|namespace, name, prop*, range))> uri*;
      switch !resolved*
        case ?[]: 
          result := Fail(<map(nbl-extend-uri(|namespace, name, ()))> uri*)
        case fetch(?Stall()) :
          fail
        otherwise:
          result := Done(<filter(nbl-uri)> resolved*)
      end
      
  perform-task-resolve(|namespace, name, prop*, range): 
    uri -> resolved*
    where
      switch !range
        case All(): resolved* := <nbl-lookup-definitions(nbl-resolve-constraint(|prop*)|namespace, name)> uri
        case One(): resolved* := <nbl-lookup-definitions-scoped(nbl-resolve-constraint(|prop*)|namespace, name)> uri
      end
      
  nbl-resolve-constraint(|prop*):
    entry -> entry'
    where
      results := <map(nbl-resolve-constraint-one(|entry))> prop*;
      if <fetch(?Stall())> results then
        entry' := Stall()
      else
        entry' := entry
      end
      
  nbl-resolve-constraint-one(|entry):
    Prop(type, expectedValue) -> entry'
    where
      value := <nbl-get-property(|type)> entry;
      if value' := <nbl-resolve> value then
        expectedValue'  := <nbl-resolve> expectedValue;
        <eq> (expectedValue', value');
        entry' := entry
      else
        entry' := Stall()
      end

rules // Property calculation
            
  perform-task: PropCalc(prop, term) -> Done(<calc-property> (prop, term))
  
rules // Match
  
  perform-task: Match(key, term) -> Done(<match-term> (key, term))
  
rules // Noop
  
  perform-task: Noop() -> Done()
  
rules // Utility
  
  nbl-result-number:
    Result(num) -> num

rules // Projections
  
  /** @internal */
  nbl-uri-impl:
    Task(uri, _, _) -> uri
  
  /** @internal */  
  nbl-uri-impl:
    Resolve(uri, _, _, _, _) -> uri
  
  /** @internal */
  nbl-uri-impl:
    DoneTask(_, uri) -> uri
    
  /** @internal */
  nbl-uri-impl:
    FailTask(_, uri) -> uri
