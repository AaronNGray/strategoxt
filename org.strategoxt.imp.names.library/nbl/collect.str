module nbl/collect

imports
	
	libstratego-lib
	nbl/tasks
	nbl/entries
	nbl/interface
	nbl/uri
	nbl/utils
	
signature 

	sorts
	
		Unique Import DefScope RefScope

	constructors // def

		Current    :            						DefScope
		Subsequent :            						DefScope
		DefScope   : Namespace * Segment -> DefScope

  constructors // implicit def
    
    IDefCandidate : Namespace * Name * Unique * List(Property) -> ImplicitDef
  
  constructors // use
      
		UseCandidate  : Namespace * List(Property) * RefScope * Range        -> Use
		UseCandidate  : Namespace * Name * List(Property) * RefScope * Range -> Use
	
		Current     :                                     							RefScope
		Surrounding :                                  	 							  RefScope
		Context     : String * Namespace * List(Property) * RefScope -> RefScope
		
    All : Range
    One : Range
	
	constructors // import
	  
	  Imported : Namespace                   -> Namespace
	  Import   : Language * Namespace        -> Property
	  Import   : Language * Namespace * Name -> Property
  
  constructors // property
    
    Prop : Property * Value -> Prop
	
strategies // generic traversal
	
	/*
			This is the main strategy to collect all index elements and tasks from an AST
	*/
	nbl-collect(|lang) = 
		where (new-iset; ?elems);
		where (new-iset; ?tasks);
		nbl-collect(id|lang, elems, tasks, [], []); 
		!(<id>, <iset-elements> elems, <iset-elements> tasks)
	
	/*
			This strategy performs the collection in a topdown traversal. 
			At each node, it tries various calls to generated strategies, which call back to generic strategies.
	*/
	nbl-collect(spaths|lang, elems, tasks, paths, deps) =
		vdebug(!"analyse scope ");
		// handles the scopes of external definitions, e.g. variables in let expressions
		nbl-scope-site(?paths'|lang, paths);
		vdebug(!"analyse def ");
		// handles definition sites
		nbl-def-collect(?cpaths, spaths|lang, elems, tasks, paths');
		vdebug(!"import dependencies ");
		// import dependencies
		nbl-import-dependency-collect(?deps'|lang, elems, tasks, cpaths, deps);
		vdebug(!"visit children ");
		// visit children from left to right
		preserve-annos(force-origins(id#(nbl-siblings(|lang, elems, tasks, cpaths, deps'))));
		vdebug(!"analyse use ");
		// handles use sites
		try(nbl-use-site(|lang, elems, tasks, paths', deps));
	  vdebug(!"analyse imports ");
    // handles import sites
    try(nbl-import-site(|lang, elems, tasks, paths));
		vdebug(!"analyse prop ");
		// handles properties
		try(nbl-prop-site(|lang, elems, tasks, paths'));
    vdebug(!"analyse implicit def ");
    // handles implicit definition sites
    try(nbl-implicit-def-site(|lang, elems, tasks, cpaths));
		vdebug(!"done ")
	
	nbl-siblings(|lang, elems, tasks, paths, deps) = 
		[]
	
	nbl-siblings(|lang, elems, tasks, paths, deps) =
		[nbl-collect(?spaths|lang, elems, tasks, paths, deps)|nbl-siblings(|lang, elems, tasks, spaths, deps)]

rules // generic analysis of scopes
	
	nbl-scope-site(cpaths|lang, paths):
		name{anno*} -> result
		where
			if (anno1*, anno2*) := <split-fetch(?DefScope(ns, segment) => scope )> anno* then
				segment' := <nbl-external-segment> segment;
				paths'   := <update-scope-paths(nbl-extend-uri(|segment')|lang)> (ns, paths);
				// TODO: fix empty annotation list
				result   := <nbl-scope-site(cpaths|lang, paths')> name{anno1*, anno2*}
			else
				match(cpaths|paths);
				result := name{anno*}
			end
	
	nbl-def-scope = !DefScope(<id>, <nbl-anonymous-segment>)
	
	nbl-def-scope(|scope): name{anno*} -> name{scope, anno*}
		
	// call back for generic analysis of anonymous scopes
	nbl-anonymous-scope(cpaths|lang, paths, nss) =
		match(cpaths|<extend-scope-paths(|lang, <nbl-anonymous-segment>)> (nss, paths))	
	
rules // generic analysis of defs
	
	nbl-def-collect(cpaths, spaths|lang, elems, tasks, paths) =
		nbl-def-site(cpaths, spaths|lang, elems, tasks, paths) <+ 
		(
			match(cpaths|paths);
			match(spaths|paths)
		)
	
	// call backs to generic analysis
	
	// TODO: can the alias storage be handled by new-def
	// definition site in current scope
	nbl-def(cpaths, spaths|lang, elems, tasks, paths, ns, unique, defscope, scoped):
		a@name{anno*} -> name{d,anno*}
		where
			defscope := [Current()];
			// get path for namespace of definition site
			ppath    := <lookup <+ <nbl-base-uri> lang> (ns, paths);
			// build path for definition site
			path     := <nbl-extend-uri(|ns, name, unique)> ppath;
			// build Def entry for the index
			d        := <new-def(|elems, path)> a;
			// store non-unique alias in the index
			nbl-def-store-alias(|elems, unique, path, ns, name);
		  // preserve current paths in subsequent scope
		  match(spaths|paths);
			// extend paths in children for scoped namespaces
			match(cpaths|<replace-scope-paths(|path)> (scoped, paths))
		
	// TODO: make this work with lists of def scopes
	// definition site in subsequent scope and/or external	
	nbl-def(cpaths, spaths|lang, elems, tasks, paths, ns, unique, defscope, scoped):
		a@name{anno*} -> name{d, anno*}
		where
			if 
				defscope := [Subsequent()]
			then
				segment  := <nbl-subsequent-segment>;
				// get path for namespace of definition site
				ppath    := <lookup <+ <nbl-base-uri> lang> (ns, paths)
			else
				// TODO: check if we can create the segment here
				[DefScope(ns, segment)] := defscope;
				// get base path for language
				ppath    := <nbl-base-uri> lang
			end;
			// build path for definition site
			path     := <nbl-extend-uri(|segment); nbl-extend-uri(|ns, name, unique)> ppath;
			// build Def entry 
			d        := <new-def(|elems, path)> a;
			// store a non-unique alias in the index
			nbl-def-store-alias(|elems, unique, path, ns, name);
			// TODO: check if this is correct for external definitions
			match(spaths|<extend-scope-paths(|lang, segment)> ([ns], paths));
		  // preserve current paths in children
		  match(cpaths|paths)
		  
	nbl-def-store-alias(|elems, unique, path, ns, name) =
	  if Unique(_) := unique then
      new-alias(|elems, <nbl-replace-uri(|ns, name, <nbl-nonunique-qualifier>)> path, path)
    end

rules // import dependencies
  
  nbl-import-dependency-collect(deps'|lang, elems, tasks, paths, deps) =
    nbl-import-dependency-site(deps'|lang, elems, tasks, paths, deps) <+ 
    (
      match(deps'|deps)
    )
  	
  nbl-import-dependency(deps'|lang, elems, tasks, paths, deps):
    name{anno*} -> name{anno*, reserved*}
    where
      /* Reserve a task number for use as dependency for the subtree of the import. The reserved 
      number is used in nbl-import to create a NoOp task that has a dependency on the resolution
      of the import target. This makes sure that imports are resolved before other resolve tasks. */
    	Reserved(number) := <reserve-task>;
    	reserved*        := [Reserved(number)];
    	match(deps'|[number|deps])

rules // generic analysis of implicit defs

  nbl-implicit-def(|lang, elems, tasks, paths, candidates):
    name -> name
    where
      <map(nbl-implicit-def-candidate(|lang, elems, tasks, paths))> candidates
      
  nbl-implicit-def-candidate(|lang, elems, tasks, paths):
    IDefCandidate(ns, name, unique, props) -> <id>
    where
      // get path for namespace of definition site
      ppath    := <lookup <+ <nbl-base-uri> lang> (ns, paths);
      // build path for definition site
      path     := <nbl-extend-uri(|ns, name, unique)> ppath;
      // build Def entry for the index
      new-def(|elems, path);
      // store non-unique alias in the index
      nbl-def-store-alias(|elems, unique, path, ns, name);
      // build Prop entries for the index
      <map(\Prop(type, result) -> <new-prop(|elems, path, type, result)>\)> props
	
rules // generic analysis of uses
	
	// single candidate
	nbl-use(|lang, elems, tasks, paths, deps, candidate):
		name -> name'
		where
			<not(is-list)> candidate;
			name' := <nbl-use-candidate(|lang, elems, tasks, paths, deps)> (candidate, name)
	
	// list of candidates
	nbl-use(|lang, elems, tasks, paths, deps, candidates):
		name -> name'
		where
			<is-list> candidates;
			name' := <foldl(nbl-use-candidate(|lang, elems, tasks, paths, deps))> (candidates, name)
		
	// candidate in current scope
	nbl-use-candidate(|lang, elems, tasks, paths, deps):
		(UseCandidate(ns, prop*, Current(), range), name{anno*}) -> name{u, anno*}
		where
			uri    := <lookup <+ <nbl-base-uri> lang> (ns, paths);
			result := <new-task(|tasks, <conc> (deps, <dependent-tasks> prop*))> Resolve(uri, ns, <nbl-fix-name> name, prop*, range);
		  u      := <new-use(|elems, result)>
		  
  // named candidate in current scope
  nbl-use-candidate(|lang, elems, tasks, paths, deps):
    (UseCandidate(ns, name, prop*, Current(), range), term{anno*}) -> term{u, anno*}
    where
      uri    := <lookup <+ <nbl-base-uri> lang> (ns, paths);
      result := <new-task(|tasks, <concat> [deps, <dependent-tasks> prop*, <dependent-tasks> name])> Resolve(uri, ns, <nbl-fix-name> name, prop*, range);
      u      := <new-use(|elems, result)>
	
	// candidate in another scope (result of resolution)	  
	nbl-use-candidate(|lang, elems, tasks, paths, deps):
		(c@UseCandidate(ns, prop*, uri@Result(resultNumber), range), name{anno*}) -> name{u, anno*}
		where
			result := <new-task(|tasks, <conc> ([resultNumber|deps], <dependent-tasks> prop*))> Resolve(uri, ns, <nbl-fix-name> name, prop*, range);
		  u      := <new-use(|elems, result)>
		  
	// candidate in context
  nbl-use-candidate(|lang, elems, tasks, paths, deps):
    (UseCandidate(ns, prop*, Context(name', ns', props', refscope'), range), name{anno*}) -> name{u, anno*}
    where 
      _{uri} := <nbl-use-candidate(|lang, elems, tasks, paths, deps)> (UseCandidate(ns', props', refscope', range), name'{});
      result := <new-task(|tasks, <conc> (deps, <dependent-tasks> prop*))> Resolve(uri, ns, <nbl-fix-name> name, prop*, range);
      u      := <new-use(|elems, result)>

rules // generic analysis of imports
  
  nbl-import(|lang, elems, tasks, paths, resolveNs, imports):
    name -> name'
    where
      name' := <foldl(nbl-import-candidate(|lang, elems, tasks, paths, resolveNs))> (imports, name)
        
  nbl-import-candidate(|lang, elems, tasks, paths, resolveNs):
    (import, name) -> name
    where
      importNs    := <nbl-import-namespace> import;
      uri         := <lookup <+ <nbl-base-uri> lang> (importNs, paths);
      Use(res)    := <nbl-collect-use> name;
      Reserved(r) := <nbl-collect-reserved> name;
      <new-task(|tasks, r, [<nbl-result-number> res])> NoOp();
      new-prop(|elems, uri, import, res)
      
  nbl-import-namespace:
    Import(_, Imported(namespace)) -> namespace
      
  nbl-import-namespace:
    Import(_, namespace) -> namespace
    where
      not(Imported(_) := namespace)
      
  nbl-import-namespace:
    Import(_, Imported(namespace), _) -> namespace
      
  nbl-import-namespace:
    Import(_, namespace, _) -> namespace
    where
      not(Imported(_) := namespace)

rules // generic analysis of properties
  
	// call back to generic analysis
	nbl-props(|lang, elems, tasks, prop*):
	  name -> name'
	  where
	    Def(uri) := <nbl-collect-def> name;
		  name'    := <foldl(extend-prop(|elems, uri))> (prop*, name)
		
	extend-prop(|elems, uri):
		(Prop(type, result), name) -> name
		where
		  prop := <new-prop(|elems, uri, type, result)> name

rules // name retrieval
  
  nbl-name = is-string
    
  nbl-fix-name = try(fix-completion-name); strip-annos
  
rules // URI retrieval
  
  nbl-collect-def =
    nbl-name;
    get-annos;
    collect-one(?Def(_))
    
  nbl-collect-use =
    nbl-name;
    get-annos;
    collect-one(?Use(_))
    
  nbl-collect-reserved =
    get-annos;
    collect-one(?Reserved(_))

rules // helpers
	
	replace-scope-paths(|path)         = foldl(update-scope-paths(!path|<nbl-uri-language> path))
	extend-scope-paths(|lang, segment) = foldl(update-scope-paths(nbl-extend-uri(|segment)|lang))
	
	update-scope-paths(update|lang):
		(key, paths) -> result
		where
			  result := <fetch((?key, update))> paths 
			<+ 
			  result := [(key, <nbl-base-uri; update> lang)|paths]
