module nbl/collect

imports
	
	libstratego-lib
	index/utility
	nbl/-
	
signature 

	sorts
	
		Unique Import DefScope RefScope

	constructors
	
	Unique     : Unique
	NonUnique  : Unique
	
	Single     : Namespace * Name -> Import
	All        : Namespace        -> Import
	Imported   : Namespace        -> Import
	
	
	Current    :            						DefScope
	Subsequent :            						DefScope
	DefScope   : Namespace * Segment -> DefScope

	Candidate  : Namespace * List(Property) * RefScope * List(Import) -> Use
	
	Current    :                                     							 RefScope
	Surrounding:                                  	 							 RefScope
	Context    : String * Namespace * List(Property) * RefScope	-> RefScope

	Def        : URI                    -> Def
	Use        : URI                    -> Use
	Prop       : URI * Property * Value -> Prop
	
strategies // generic traversal
	
	nbl-collect(|lang) = 
		where (new-iset; ?elems);
		where (new-iset; ?tasks);
		nbl-collect(id|lang, elems, tasks, []); 
		!(<id>, <iset-elements> elems, <iset-elements> tasks)
	
	nbl-collect(spaths|lang, elems, tasks, paths) =
		vdebug(!"analyse scope ");
		nbl-scope-site(?paths'|lang, paths);
		vdebug(!"analyse def ");
		nbl-def-collect(?cpaths, spaths|lang, elems, tasks, paths');
		vdebug(!"visit children ");
		preserve-annos(force-origins(id#(nbl-siblings(|lang, elems, tasks, cpaths))));
		vdebug(!"analyse use ");
		try(nbl-use-site(|lang, elems, tasks, paths'));
		vdebug(!"analyse prop ");
		try(nbl-prop-site(|lang, elems, tasks, paths'));
		vdebug(!"done ")
	
	nbl-siblings(|lang, elems, tasks, paths) = 
		[]
	
	nbl-siblings(|lang, elems, tasks, paths) =
		[nbl-collect(?spaths|lang, elems, tasks, paths)|nbl-siblings(|lang, elems, tasks, spaths)]

rules // generic analysis of scopes
	
	nbl-scope-site(cpaths|lang, paths):
		name{anno*} -> result
		where
			if (anno1*, anno2*) := <split-fetch(?DefScope(ns, segment) => scope )> anno* then
				segment' := <nbl-external-segment> segment;
				paths'   := <update-scope-paths(nbl-extend-uri(|segment')|lang)> (ns, paths);
				result   := <nbl-scope-site(cpaths|lang, paths')> name{anno1*, anno2*}
			else
				match(cpaths|paths);
				result := name{anno*}
			end
	
	nbl-def-scope = !DefScope(<id>, <nbl-anonymous-segment>)
	
	nbl-def-scope(|scope): name{anno*} -> name{scope, anno*}
		
	// call back for generic analysis of anonymous scopes
	nbl-anonymous-scope(cpaths|lang, paths, nss) =
		match(cpaths|<extend-scope-paths(|lang, <nbl-anonymous-segment>)> (nss, paths))	
	
rules // generic analysis of defs
	
	nbl-def-collect(cpaths, spaths|lang, elems, tasks, paths) =
		nbl-def-site(cpaths, spaths|lang, elems, tasks, paths) <+ 
		(
			match(cpaths|paths);
			match(spaths|paths)
		)
		
	// interface to specific analysis
	nbl-def-site(cpaths, spaths|lang, elems, tasks, paths) = fail
	
	// call backs to generic analysis
	nbl-def(cpaths, spaths|lang, elems, tasks, paths, ns, unique, defscope, scoped):
		a@name{anno*} -> name{d,anno*}
		where
			defscope := [Current()];
			ppath    := <lookup <+ <nbl-base-uri> lang> (ns, paths);
			path     := <nbl-extend-uri(|ns, name, unique)> ppath;
			d        := <new-def(|elems, path)> a;
		  match(spaths|paths);
			match(cpaths|<replace-scope-paths(|path)> (scoped, paths))
			
	nbl-def(cpaths, spaths|lang, elems, tasks, paths, ns, unique, defscope, scoped):
		a@name{anno*} -> name{d, anno*}
		where
			defscope := [Subsequent()];
			segment  := <nbl-subsequent-segment>;
			ppath    := <lookup <+ <nbl-base-uri> lang> (ns, paths);
			path     := <nbl-extend-uri(|segment); nbl-extend-uri(|ns, name, unique)> ppath;
			d        := <new-def(|elems, path)> a;
			match(spaths|<extend-scope-paths(|lang, segment)> ([ns], paths));
		  match(cpaths|paths)
	
	nbl-def(cpaths, spaths|lang, elems, tasks, paths, ns, unique, defscope, scoped):
		a@name{anno*} -> name{d, anno*}
		where
			[DefScope(ns, segment)] := defscope;
			ppath    := <nbl-base-uri> lang;
			path     := <nbl-extend-uri(|segment); nbl-extend-uri(|ns, name, unique)> ppath;
			d        := <new-def(|elems, path)> a;
			match(spaths|<extend-scope-paths(|lang, segment)> ([ns], paths));
		  match(cpaths|paths)
	
rules // generic analysis of uses
	
	// interface to specific analysis
	nbl-use-site(|lang, elems, tasks, paths) = fail
	
	// call back to generic analysis
	nbl-use(|lang, elems, tasks, paths, candidate):
		name -> name'
		where
			<not(is-list)> candidate;
			name' := <nbl-use-candidate(|lang, elems, tasks, paths)> (candidate, name)
	
	nbl-use(|lang, elems, tasks, paths, candidates):
		name -> name'
		where
			<is-list> candidates;
			name' := <foldl(nbl-use-candidate(|lang, elems, tasks, paths))> (candidates, name)
		
	nbl-use-candidate(|lang, elems, tasks, paths):
		(Candidate(ns, props, Current(), imports), name{anno*}) -> name{u, anno*}
		where
			ppath  := <lookup <+ <nbl-base-uri> lang> (ns, paths);
			path   := <nbl-extend-uri(|ns, <strip-annos> name)> ppath; 
			result := <new-task(|tasks)> Resolve(path, props, imports);
		  u      := <new-use(|elems, result)>
	
	nbl-use-candidate(|elems, tasks, paths):
		(Candidate(ns, props, Context(name', ns', props', refscope'), imports), name{anno*}) -> name{u, anno*}
		where	
			_{tempresult} := <nbl-use-candidate(|elems, tasks, paths)> (Candidate(ns', props', refscope', []), name'{});
			result				:= <new-task(|tasks)> Resolve((ns, name{}), tempresult, props, imports);
		  u      				:= <new-use(|elems, result)>

rules // generic analysis of properties
				
	// interface to specific analysis
	nbl-prop-site(|lang, elems, tasks, paths) = fail
	
	// call back to generic analysis
	nbl-props(|lang, elems, tasks, prop*) =
		?name{Def(path)};
		<map(extend-prop(|lang, elems, tasks, path))> prop*
		
	extend-prop(|lang, elems, tasks, path):
		Prop((ns, name), prop, val) -> <new-prop(|elems, path, prop, val)> 
		where
			name':= name{};
			<Hd> path;
			(
				?(ns, name') +
				?(ns, name', _)
			)
			
rules // index uri & value projections
	
  /** @internal */
  index-uri-impl:
    Def(uri) -> uri
    
  /** @internal */  
  index-uri-impl:
    Use(uri) -> uri
    
  /** @internal */  
  index-uri-impl:
    Prop(uri, _, _) -> uri
    
  /** @internal */  
  index-uri-impl:
    _{anno*} -> <fetch-elem(index-uri)> anno*


  /** @internal */  
  index-uris-impl:
    _{anno*} -> <filter(index-uri)> anno*
   
    
  /** @internal */
  index-value-impl:
    Def(value) -> value

  /** @internal */
  index-value-impl:
    Use(value) -> value
    
  /** @internal */
  index-value-impl:
    Prop(_, _, value) -> value
    
  /** @internal */  
  index-value-impl:
    _{anno*} -> <fetch-elem(index-value)> anno*
    
    
  /** @internal */  
  index-values-impl:
    _{anno*} -> <filter(index-value)> anno*
			
rules // helpers
	
	replace-scope-paths(|path)         = foldl(update-scope-paths(!path|<nbl-uri-language> path))
	extend-scope-paths(|lang, segment) = foldl(update-scope-paths(nbl-extend-uri(|segment)|lang))
	
	update-scope-paths(update|lang):
		(key, paths) -> result
		where
			  result := <fetch((?key, update))> paths 
			<+ 
			  result := [(key, <nbl-base-uri; update> lang)|paths]
			
	force-origins(s) =
    ![<id>]; all(s); ?[<id>]
