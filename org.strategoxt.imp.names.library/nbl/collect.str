module nbl/collect

imports
	
	nbl/-
	
signature 

	sorts
	
		Unique Import DefScope RefScope

	constructors
	
	Unique     : Unique
	NonUnique  : Unique
	
	Single     : Namespace * Name -> Import
	All        : Namespace        -> Import
	Imported   : Namespace        -> Import
	
	
	Current    :            DefScope
	Subsequent :            DefScope
	DefScope   : Unknown -> DefScope

	Candidate  : Namespace * List(Property) * RefScope * List(Import) -> Use
	
	Current    :                                     							 RefScope
	Surrounding:                                  	 							 RefScope
	Context    : String * Namespace * List(Property) * RefScope	-> RefScope

	Def        : URI                    -> Def
	Use        : URI                    -> Use
	Prop       : URI * Property * Value -> Prop
	
strategies // generic traversal
	
	nbl-collect(|lang) = 
		where (new-iset; ?elems);
		where (new-iset; ?tasks);
		nbl-collect(id|lang, elems, tasks, []); 
		!(<id>, <iset-elements> elems, <iset-elements> tasks)
	
	nbl-collect(spaths|lang, elems, tasks, paths) =
		vdebug(!"analyse def ");
		nbl-def-collect(?cpaths, spaths|lang, elems, tasks, paths);
		vdebug(!"visit children ");
		preserve-annos(force-origins(id#(nbl-siblings(|lang, elems, tasks, cpaths))));
		vdebug(!"analyse use ");
		try(nbl-use-site(|lang, elems, tasks, paths));
		vdebug(!"analyse prop ");
		try(nbl-prop-site(|lang, elems, tasks, paths));
		vdebug(!"done ")
	
	nbl-siblings(|lang, elems, tasks, paths) = 
		[]
	
	nbl-siblings(|lang, elems, tasks, paths) =
		[nbl-collect(?spaths|lang, elems, tasks, paths)|nbl-siblings(|lang, elems, tasks, spaths)]

rules // generic analysis of defs
	
	nbl-def-collect(cpaths, spaths|lang, elems, tasks, paths) =
		nbl-def-site(cpaths, spaths|lang, elems, tasks, paths) <+ 
		(
			match(cpaths|paths);
			match(spaths|paths)
		)
		
	// interface to specific analysis
	nbl-def-site(cpaths, spaths|lang, elems, tasks, paths) = fail
	
	// call back to generic analysis
	nbl-def(cpaths, spaths|lang, elems, tasks, paths, ns, unique, defscope, scoped):
		a@name{anno*} -> name{d,anno*}
		where
			defscope := [Current()];
			ppath    := <lookup <+ <nbl-base-uri> lang> (ns, paths);
			path     := <nbl-extend-uri(|ID(ns, name, unique))> ppath;
			d        := <new-def(|elems, path)> a;
		  match(spaths|paths);
			match(cpaths|<replace-scope-paths(|path)> (scoped, paths))
			
	nbl-def(cpaths, spaths|lang, elems, tasks, paths, ns, unique, defscope, scoped):
		a@name{anno*} -> name{d, anno*}
		where
			defscope := [Subsequent()];
			segment  := Subsequent(<new>);
			ppath    := <lookup <+ <nbl-base-uri> lang> (ns, paths);
			path     := <nbl-extend-uri(|segment); nbl-extend-uri(|ID(ns, name, unique))> ppath;
			d        := <new-def(|elems, path)> a;
			match(spaths|<extend-scope-paths(|lang, segment)> ([ns], paths));
		  match(cpaths|paths)
	
	// call back for generic analysis of anonymous scopes
	nbl-anonymous-scope(cpaths, spaths|lang, elems, tasks, paths, nss) =
		match(spaths|paths);
		match(cpaths|<extend-scope-paths(|lang, Anonymous(<new>))> (nss, paths))
		
rules // generic analysis of uses
	
	// interface to specific analysis
	nbl-use-site(|lang, elems, tasks, paths) = fail
	
	// call back to generic analysis
	nbl-use(|lang, elems, tasks, paths, candidate):
		name -> name'
		where
			<not(is-list)> candidate;
			name' := <nbl-use-candidate(|lang, elems, tasks, paths)> (candidate, name)
	
	nbl-use(|lang, elems, tasks, paths, candidates):
		name -> name'
		where
			<is-list> candidates;
			name' := <foldl(nbl-use-candidate(|lang, elems, tasks, paths))> (candidates, name)
		
	nbl-use-candidate(|lang, elems, tasks, paths):
		(Candidate(ns, props, Current(), imports), name{anno*}) -> name{u, anno*}
		where
			ppath  := <lookup <+ <nbl-base-uri> lang> (ns, paths);
			path   := <nbl-extend-uri(|ID(ns, name))> ppath; 
			result := <new-task(|tasks)> Resolve(path, props, imports);
		  u      := <new-use(|elems, result)>
	
	nbl-use-candidate(|elems, tasks, paths):
		(Candidate(ns, props, Context(name', ns', props', refscope'), imports), name{anno*}) -> name{u, anno*}
		where	
			_{tempresult} := <nbl-use-candidate(|elems, tasks, paths)> (Candidate(ns', props', refscope', []), name'{});
			result				:= <new-task(|tasks)> Resolve((ns, name{}), tempresult, props, imports);
		  u      				:= <new-use(|elems, result)>

rules // generic analysis of properties
				
	// interface to specific analysis
	nbl-prop-site(|lang, elems, tasks, paths) = fail
	
	// call back to generic analysis
	nbl-props(|lang, elems, tasks, prop*) =
		?name{Def(path)};
		<map(extend-prop(|lang, elems, tasks, path))> prop*
		
	extend-prop(|lang, elems, tasks, path):
		Prop((ns, name), prop, val) -> <new-prop(|elems, path, prop, val)> 
		where
			name':= name{};
			<Hd> path;
			(
				?(ns, name') +
				?(ns, name', _)
			)
			
rules // helpers
	
	replace-scope-paths(|path)         = foldl(update-scope-paths(!path|<nbl-uri-language> path))
	extend-scope-paths(|lang, segment) = foldl(update-scope-paths(nbl-extend-uri(|segment)|lang))
	
	update-scope-paths(update|lang):
		(key, paths) -> result
		where
			result := <fetch((?key, update))> paths <+ 
			result := [(key, <update; nbl-base-uri> lang)|paths]
			
	force-origins(s) =
    ![<id>]; all(s); ?[<id>]
