module nbl/collect

imports
	
	nbl/-
	
signature 

	sorts
	
		Unique Import DefScope RefScope

	constructors
	
	Anonymous	 : Namespace
	 
	Unique     : Unique
	NonUnique  : Unique
	
	Single     : Namespace * Name -> Import
	All        : Namespace        -> Import
	Imported   : Namespace        -> Import
	
	
	Current    :            				 DefScope
	Subsequent :            				 DefScope
	DefScope   : Namespace * Name -> DefScope

	Candidate  : Namespace * List(Property) * RefScope * List(Import) * List(Task) -> Use
	
	Current    :                                     							 RefScope
	Surrounding:                                  	 							 RefScope
	Context    : String * Namespace * List(Property) * RefScope	-> RefScope

	Def        : List(Segment)                    -> Def
	Use        : List(Segment)                    -> Use
	Prop       : List(Segment) * Property * Value -> Prop
	
overlays
	
	Candidate(ns, ps, s, is) = Candidate(ns, ps, s, is, [])
	 
strategies // generic traversal
	
	nbl-collect(|elems, tasks) = 
		nbl-collect(id|elems, tasks, []); 
		!(<id>, <iset-elements> tasks)
	
	nbl-collect(spaths|elems, tasks, paths) =
		vdebug(!"analyse scope ");
		nbl-scope-site(?paths'|paths);
		vdebug(!"analyse def ");
		nbl-def-collect(?cpaths, spaths|elems, tasks, paths');
		vdebug(!"visit children ");
		preserve-annos(force-origins(id#(nbl-siblings(|elems, tasks, cpaths))));
		vdebug(!"analyse use ");
		try(nbl-use-site(|elems, tasks, paths));
		vdebug(!"analyse prop ");
		try(nbl-prop-site(|elems, tasks, paths));
		vdebug(!"done ")
	
	nbl-siblings(|elems, tasks, paths) = 
		[] <+ 
		[nbl-collect(?spaths|elems, tasks, paths)|nbl-siblings(|elems, tasks, spaths)]

rules // generic analysis of defs
	
	nbl-def-collect(cpaths, spaths|elems, tasks, paths) =
		nbl-def-site(cpaths, spaths|elems, tasks, paths) <+ 
		match(cpaths; spaths|paths)
	
rules
	
	// call back to generic analysis
	nbl-scope-site(cpaths|uris):
		name{anno*} -> result
		where
			if (anno1*, anno2*) := <split-fetch(?DefScope(ns, _) => scope )> anno* then
				uri    := <uri-lookup; extend-uri(|ns, name, unique)> (ns, uris) ;
				paths' := <replace-scope-uri(|uri)> (ns, uris);
				result := <nbl-scope-site(cpaths|paths')> name{anno1*, anno2*}
			else
				match(cpaths|uris);
				result := name{anno*}
			end
			
rules
	
	// interface to specific analysis
	nbl-def-site(cpaths, spaths|elems, tasks, paths) = fail
	
	// call back to generic analysis
	nbl-def(cpaths, spaths|elems, tasks, uris, ns, unique, defscope, scoped):
		a@name{anno*} -> name{d,anno*}
		where
			defscope := [Current()];
			uri      := <uri-lookup; extend-uri(|ns, name, unique)> (ns, uris) ;
			d        := <new-def(|elems, uri)> a;
			match(spaths|uris);
			match(cpaths|<replace-scope-uris(|uri)> (scoped, uris))
			
	// nbl-def(cpaths, spaths|elems, tasks, uris, ns, unique, defscope, scoped):
	// 	a@name{anno*} -> name{d, anno*}
	// 	where
	// 		defscope:= [Subsequent()];
	// 		segment := Subsequent();
	// 		path    := [(ns, name, unique), segment|<lookup <+ ![]> (ns, paths)];
	// 		d       := <new-def(|elems, path)> a;
	// 		match(spaths|<extend-scope-uris(|language, ns, name, unique)> ([ns], uris));
	// 	  match(cpaths|uris)
	
	// call back for generic analysis of anonymous scopes
	nbl-anonymous-scope(cpaths, spaths|language, nss, paths) =
		match(spaths|paths);
		match(cpaths|<extend-scope-uris(|language, Anonymous(), <newname>)> (nss, paths))
	
	// call back for generic analysis of external scopes
	nbl-def-scope(|scope): x{anno*} -> x{scope, anno*}
	
	newScope(|ns) = !DefScope(ns, <newname> "")
		
rules // generic analysis of uses
			
	// interface to specific analysis
	nbl-use-site(|elems, tasks, paths) = fail
	
	// call back to generic analysis
	nbl-use(|elems, tasks, paths, candidate):
		name{anno*} -> name{Result(tn), anno*}
		where
			Subtask(tn, _, tasks) := <nbl-use-candidate(|tasks, paths, name)> candidate
	
	nbl-use(|elems, tasks, paths, candidates):
		name{anno*} -> name{result, anno*}
		where
			sts  := <is-list; map(nbl-use-candidate(|tasks, paths, name))> candidates;
			(result, task) := <new-task(|tasks)> Compound(OrderedAlt(), sts)
		
	nbl-use-candidate(|tasks, paths, name):
		Candidate(ns, props, Current(), imports, tasks) -> task
		where
			path := <lookup <+ ![]> (ns, paths);
			task := <new-subtask(|tasks)> [Resolve((ns, name), path, props, imports)|tasks]
	
	nbl-use-candidate(|tasks, paths, name):
		Candidate(ns, props, Context(name', ns', props', refscope'), imports, tasks)  -> task'
		where	
			task@Subtask(tn, _, _) := <nbl-use-candidate(|tasks, paths, name')> Candidate(ns', props', refscope', [], tasks);
			(_, subtask) := <new-task(|tasks)> Resolve((ns, name{}), Result(tn), props, imports);
			task' := <extend-subtask(|subtask)> task

rules // generic analysis of properties
			
	// interface to specific analysis
	nbl-prop-site(|elems, tasks, paths) = fail
	
	// call back to generic analysis
	nbl-props(|elems, tasks, prop*) =
		get-annos;
		fetch-elem(?Def(path));
		<map(extend-prop(|elems, path))> prop*
		
	extend-prop(|elems, path):
		Prop((ns, name), prop, val) -> <new-prop(|elems, path, prop, val)> name
		where
			name':= name{};
			<Hd> path;
			(
				?(ns, name') +
				?(ns, name', _)
			)
			
rules // helpers
	
	replace-scope-uris(|uri) = 
		foldl(replace-scope-uri(|uri))
	
	replace-scope-uri(|uri)	= 
		update-scope-uri(!uri|"")
	
	extend-scope-uris(|language, ns, name, unique) = 
		foldl(update-scope-uri(extend-uri(|ns, name, unique)|language))
	
	update-scope-uri(update|language):
		(key, uris) -> result
		where
			result := <fetch((?key, update))> uris <+ 
			result := [(key, <base-uri; update> language)|uris]
			
	force-origins(s) =
    ![<id>]; all(s); ?[<id>]
    
	
