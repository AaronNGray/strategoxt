module nbl/analysis

imports
  
  index/core
  index/query
  nbl/collect
  nbl/tasks
  nbl/incremental
  nbl/uri
  
signature

  constructors
  
    File   : Path * AST                                                                       -> File
    Result : Partition * AST * AST * List(Entry) * List(Entry) * List(Task) * List(Partition) -> File
      
rules // Single file analysis
  
  nbl-analyze(|language, path, project-path):
    ast -> (ast', entries', errors, dependent)
    with // Setup index
      partition := $[[project-path]/[path]];
      index-setup(|language, [project-path], partition);
      oldEntries := <filter(nbl-diff-entry)> <index-get-all-in-partition> partition;
      <index-clear-partition> partition
    with // Collect tasks
      (ast', entries, tasks) := <nbl-collect(|Language(language))> ast;
       
      <index-add-all(|partition)> entries
    with // Perform tasks
      nbl-collect-reads(
        tasks'             := <merge-tasks> tasks;
        (errors, entries') := <perform-tasks(|partition)> (tasks', entries)
      ) => reads;
          
      <index-add-all(|partition)> reads
    with // Dependent partitions
      newEntries       := <filter(nbl-diff-entry)> entries';
      (added, removed) := <nbl-diff> (oldEntries, newEntries);
      changed          := <conc> (added, removed);
      dependent        := <nbl-get-dependent-partitions; nbl-remove-own-partition(|partition)> changed

rules // Multi file analysis
  
  nbl-analyze-multiple(parse-file, complete-work-unit|language, project-path):
    path* -> result*
    with
      file*   := <map(nbl-analyze-parse-file(parse-file); where(complete-work-unit))> path*;
      result* := <nbl-analyze-multiple-files(complete-work-unit|language, project-path)> file*

  nbl-analyze-parse-file(parse-file):
    path -> File(path, ast)
    with
      if not(ast := <file-exists; parse-file> path) then
        ast := ()
      end

  nbl-analyze-multiple-files(complete-work-unit|language, project-path):
    file* -> result3*
    with // Setup index
      index-setup(|language, [project-path], ".")
    with
      // TODO: Can be performed in parallel trivially. 
      result1* := <map(nbl-analyze-multiple-collect(|language); where(complete-work-unit))> file*;
      // TODO: Can be performed in parallel optimistically with re-analysis on inconsistent or outdated data.
      result2* := <map(nbl-analyze-multiple-perform; where(complete-work-unit))> result1*;
      // TODO: Can be performed in parallel trivially.
      result3* := <map(nbl-analyze-multiple-dependent; where(complete-work-unit))> result2*
      
  nbl-analyze-multiple-collect(|language):
    File(partition, ast) -> Result(partition, ast, ast', oldEntry*, entry*, <merge-tasks> task*, [])
    with
      <index-set-current-partition> partition;
      (ast', entry*, task*) := <nbl-collect(|Language(language))> ast;
      oldEntry*             := <filter(nbl-diff-entry)> <index-get-all-in-partition> partition;
      <index-clear-partition> partition;
      <index-add-all(|partition)> entry*
  
  nbl-analyze-multiple-perform:
    Result(partition, ast, ast', oldEntry*, entry*, task*, _) -> 
      Result(partition, ast, ast', oldEntry*, entry'*, error*, [])
    with
      <index-set-current-partition> partition;
      nbl-collect-reads(
        (error*, entry'*) := <perform-tasks(|partition)> (task*, entry*)
      ) => reads;
      <index-add-all(|partition)> reads
      
  nbl-analyze-multiple-dependent:
    Result(partition, ast, ast', oldEntry*, entry*, error*, _) -> 
      Result(partition, ast, ast', oldEntry*, entry*, error*, dependent*)
      with
        <index-set-current-partition> partition;
        newEntry*          := <filter(nbl-diff-entry)> entry*;
        (added*, removed*) := <nbl-diff> (oldEntry*, newEntry*);
        changed            := [added*, removed*];
        dependent*         := <nbl-get-dependent-partitions; nbl-remove-own-partition(|partition)> changed
