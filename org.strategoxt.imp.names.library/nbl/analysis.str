module nbl/analysis

imports
  
  index/core
  index/query
  nbl/collect
  nbl/tasks
  nbl/incremental
  nbl/uri
  
signature

  constructors
  
    File   : Path * AST                                                                       -> File
    Result : Partition * AST * AST * List(Entry) * List(Entry) * List(Task) * List(Partition) -> File
      
rules // Single file analysis
  
  nbl-analyze(|language, path, project-path):
    ast -> (ast', entries, errors, dependent)
    with // Setup index
      partition := $[[project-path]/[path]];
      index-setup(|language, [project-path], partition);
      oldEntries := <filter(nbl-diff-entry)> <index-get-all-in-partition> partition;
      <index-clear-partition> partition
    with // Collect tasks
      (ast', entries, tasks) := <nbl-collect(|Language(language))> ast;
       
      <index-add-all(|partition)> entries
    with // Perform tasks
      nbl-collect-reads(
        tasks' := <merge-tasks> tasks;
        errors := <perform-tasks(|partition)> tasks'
      ) => reads;
          
      <index-add-all(|partition)> reads
    with // Dependent partitions
      newEntries       := <filter(nbl-diff-entry)> entries;
      (added, removed) := <nbl-diff> (oldEntries, newEntries);
      changed          := <conc> (added, removed);
      dependent        := <nbl-get-dependent-partitions; nbl-remove-own-partition(|partition)> changed

rules // Multi file analysis
  
  nbl-analyze-multiple(parse-file, parallel, complete-work-unit|language, project-path):
    path* -> result*
    with
      file*   := <map(nbl-analyze-parse-file(parse-file); where(complete-work-unit))> path*;
      result* := <nbl-analyze-multiple-files(parallel, complete-work-unit|language, project-path)> file*

  nbl-analyze-parse-file(parse-file):
    path -> File(path, ast)
    with
      if not(ast := <file-exists; parse-file> path) then
        ast := ()
      end

  nbl-analyze-multiple-files(parallel, complete-work-unit|language, project-path):
    file* -> result3*
    with 
      result1* := <parallel(all(
        nbl-analyze-multiple-setup(|language, project-path); 
        nbl-analyze-multiple-collect(|language); 
        where(complete-work-unit)
      ))> file*;
      // TODO: Can be performed in parallel optimistically with re-analysis on inconsistent or outdated data.
      result2* := <all(
        nbl-analyze-multiple-setup(|language, project-path); 
        nbl-analyze-multiple-perform; 
        where(complete-work-unit)
      )> result1*;
      result3* := <parallel(all(
        nbl-analyze-multiple-setup(|language, project-path); 
        nbl-analyze-multiple-dependent; 
        where(complete-work-unit)
      ))> result2*
      
  nbl-analyze-multiple-collect(|language):
    File(partition, ast) -> Result(partition, ast, ast', oldEntry*, entry*, <merge-tasks> task*, [])
    with
      (ast', entry*, task*) := <nbl-collect(|Language(language))> ast;
      index-transaction(
        oldEntry*           := <filter(nbl-diff-entry)> <index-get-all-in-partition> partition;
        <index-clear-partition> partition;
        <index-add-all(|partition)> entry*
      )
  
  nbl-analyze-multiple-perform:
    Result(partition, ast, ast', oldEntry*, entry*, task*, _) -> 
      Result(partition, ast, ast', oldEntry*, entry*, error*, [])
    with
      nbl-collect-reads(
        error* := <perform-tasks(|partition)> task*
      ) => reads;
      <index-add-all(|partition)> reads
      
  nbl-analyze-multiple-dependent:
    Result(partition, ast, ast', oldEntry*, entry*, error*, _) -> 
      Result(partition, ast, ast', oldEntry*, entry*, error*, dependent*)
      with
        newEntry*          := <filter(nbl-diff-entry)> entry*;
        (added*, removed*) := <nbl-diff> (oldEntry*, newEntry*);
        changed            := [added*, removed*];
        index-transaction(
          dependent*       := <nbl-get-dependent-partitions; nbl-remove-own-partition(|partition)> changed
        )

  nbl-analyze-multiple-setup(|language, project-path) =
    (?File(partition, _) <+ ?Result(partition, _, _, _, _, _, _));
    index-setup(|language, [project-path], partition)
    
  nbl-analyze-multiple-work-units = 
    length; !(<id>, 4); mul

rules // Projections
  
  nbl-result-dependent:
    Result(_, _, _, _, _, _, dependent*) -> dependent*
