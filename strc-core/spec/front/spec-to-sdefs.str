/**
 * Specification to List of Definitions

	Translation of a specification consisting of a signature,
	rules and strategy definitions to a list of strategy
	definitions.
 */

module spec-to-sdefs
imports Stratego-Sugar desugar stratlib
strategies

  spec-to-sdefs-io = 
    io-wrap(
      try(AddAnnoCongDef)
      ; AddCongruenceDefinitions
    )

/**
 * Congruences from Signature

	Congruences are recognized by the parser as strategy
	calls; The following strategy generates strategy definitions
	from the signature; For instance, the operator declaration

	OpDecl("F", FunType([_, _], _))

	is translated to the strategy definition

	SDef("F", ["x1", "x2"], Cong("F", [SVar("x1"), SVar("x2")]))

 */

rules
  
  MkCongDef : 
    OpDecl(f, ConstType(t)) -> SDefT(f, [], [], Cong(f, []))
    where <not(CongDefined)> (f, 0)
        ; rules(CongDefined : (f, 0) -> ())

  MkCongDef : 
    OpDecl(f, FunType(ts, t)) -> 
    SDefT(f, xdecs, [], Cong(f, <map(MkCall)> xs))
    where <length> ts => n
        ; <not(CongDefined)> (f, n)
        ; rules(CongDefined : (f, n) -> ())
        ; <unzip(new; !(VarDec(<id>, DefaultStrat), <id>))> ts => (xdecs, xs)

  MkCongDefs : 
    Constructors(ods) -> <filter(MkCongDef)> ods

  RegisterCongDef =
    ?ExtSDef(f, xs, []) 
    ; where(<length> xs => n)
    ; rules(CongDefined : (f, n) -> ())

  RegisterCongDef =
    ?ExtSDefInl(f, xs, [], _)
    ; where(<length> xs => n)
    ; rules(CongDefined : (f, n) -> ())

  RegisterCongDef =
    ?SDefT(f, xs, [], _)
    ; where(<length> xs => n)
    ; rules(CongDefined : (f, n) -> ())

strategies

  congdefs = {| CongDefined : filter(MkCongDefs); concat |}

overlays

  // Congruence over Annotations

  AnnoCongDef =
    RDefT("Anno_Cong__", 
         [VarDec("s1",FunType([ConstType(Sort("ATerm",[]))],ConstType(Sort("ATerm",[])))), 
          VarDec("s2",FunType([ConstType(Sort("ATerm",[]))],ConstType(Sort("ATerm",[]))))],
	 [],
         Rule(Anno(Var("x"), Var("y")), 
              Anno(Var("x'"), Var("y'")),
              <seqs> [BAM(Call(SVar("s1"),[]), Var("x"), Var("x'")), 
                    BAM(Call(SVar("s2"),[]), Var("y"), Var("y'"))]))

/*
  AnnoCongDef =
    |[ Anno_Cong__(S1 : ATerm -> ATerm, S2 : ATerm -> ATerm) : 
         X1{Y1} -> X2{Y2}
         where <S1()> X1 => X2; <S2()> Y1 => Y2
    ]|
*/

  AddCongruenceDefinitions : 
    Specification([
      Signature(bsigs), 
      Strategies(sdefs)
    ]) ->
    Specification([
      Signature(bsigs),
      Strategies(<conc> (<congdefs> bsigs, sdefs))
    ])
    where <map(try(RegisterCongDef))> sdefs


  AddAnnoCongDef :
    Specification([
      Signature(bsigs), 
      Strategies(sdefs)
    ]) ->
    Specification([
      Signature(bsigs), 
      Strategies([AnnoCongDef | sdefs])
    ])
    where <not(fetch(  ?SDefT("Anno_Cong__",_,_,_)
		     + ?RDefT("Anno_Cong__",_,_,_)
		     + ?ExtSDef("Anno_Cong__",_,_)
		     + ?ExtSDefInl("Anno_Cong__",_,_,_)))> sdefs
