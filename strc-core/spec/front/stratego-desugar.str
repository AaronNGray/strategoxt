module stratego-desugar
imports libstratego-lib Stratego-Sugar desugar-hl

signature
  constructors
    Con       : Var * Term * SVar   -> Term
    TupleCong : List(Strategy) -> Strategy
    TupleCong : Strategy

strategies
 
  stratego-desugar-io = 
    io-wrap(topdown(repeat(Desugar)))

  pre-desugar =
    topdown(repeat(Desugar); try(DesugarOnce))

rules

  Desugar : 
    Strat|[ <s> t ]| -> |[ !t; s ]| 

  Desugar : 
    |[ s => t ]| -> |[ s; ?t ]|

//  Desugar :
//   |[ t1 := t2 ]| -> |[ !t2; ?t1 ]|

  Desugar :
    Assign(t1, t2) -> Seq(Build(t2), Match(t1))

// rules

  Desugar :
    RDefNoArgs(f, r) -> RDefT(f, [], [], r)

  Desugar :
    RDef(f, xs, r) -> RDefT(f, xs, [], r)

// dynamic rules

  Desugar :
    RDecNoArgs(f) -> RDec(f, [])

  Desugar :
    RDec(f, ss) -> RDecT(f, ss, [])

  Desugar :
    DynRuleIntersectFix(rulenames, s) -> 
    CallT(SVar("dr-fix-and-intersect"), [s], [<mk-rulenames> rulenames])

  Desugar :
    DynRuleIntersect(s1, rulenames, s2) -> 
    CallT(SVar("dr-fork-and-intersect"), [s1, s2], [<mk-rulenames> rulenames])

  Desugar :
    DynRuleUnionFix(rulenames, s) -> 
    CallT(SVar("dr-fix-and-union"), [s], [<mk-rulenames> rulenames])

  Desugar :
    DynRuleUnion(s1, rulenames, s2) -> 
    CallT(SVar("dr-fork-and-union"), [s1, s2], [<mk-rulenames> rulenames])

  Desugar :
    DynRuleIntersectUnionFix(rulenames1, rulenames2, s) ->
    CallT(SVar("dr-fix-and-intersect-union"), [s], [<mk-rulenames> rulenames1, <mk-rulenames> rulenames2])

  Desugar :
    DynRuleIntersectUnion(s1, rulenames1, rulenames2, s2) ->
    CallT(SVar("dr-fork-and-intersect-union"), [s1, s2], [<mk-rulenames> rulenames1, <mk-rulenames> rulenames2])
		    

  mk-rulenames =
    foldr(!NoAnnoList(Op("Nil",[])), 
          !NoAnnoList(Op("Cons", [<Fst>, <Snd>])), 
          !NoAnnoList(Str(<id>)))
    <+ ?RuleNames(<id>)


// strategy definitions

  Desugar :
    SDefNoArgs(f, s) -> SDefT(f, [], [], s)

  Desugar :
    SDef(f, xs, s) -> SDefT(f, xs, [], s)

// strategy calls

  Desugar :
    CallNoArgs(f) -> CallT(f, [], [])

  Desugar :
    Call(f, ss) -> CallT(f, ss, [])

  DesugarOnce :
    PrimNoArgs(f) -> PrimT(<try(un-double-quote)>f, [], [])

  DesugarOnce :
    Prim(f,ts) -> PrimT(<try(un-double-quote)>f, [], ts)

  DesugarOnce :
    PrimT(f,ss,ts) -> PrimT(<try(un-double-quote)>f, ss, ts)

// sugar for choice

  Desugar :
    |[ s1 +> s2 ]| -> |[ s2 <+ s1 ]|
    // RChoice(s1, s2) -> LChoice(s2, s1)

  Desugar :
    |[ if s1 then s2 else s3 end ]| -> |[ where(s1) < s2 + s3 ]|

  Desugar :
    |[ if s1 then s2 end ]| -> |[ where(s1) < s2 + id ]|

  Desugar :
    SwitchChoiceNoOtherwise(s0, b*) -> SwitchChoice(s0, b*, |[ fail ]|)
    // |[ switch s1 sc* end ]| -> |[ switch s1 sc* otherwise fail end ]|

  Desugar :
    SwitchChoice(s1, sc*, s2) -> |[ {x : where(s1 => x); s} ]|
    // |[ switch s1 sc* s2 end ]| -> |[ {x : where(s1 => x); s} ]|
    where new => x
        ; <foldr(!s2, glchoice(|x))> sc* => s

  glchoice(|x) : 
    ((s1, s2), s3) -> |[ if <~s1> x then ~s2 else ~s3 end ]|

  glchoice(|x) :
    (SwitchCase(s1, s2), s3) -> |[ if <~s1> x then ~s2 else ~s3 end ]|

  Desugar :
    |[ where(s) ]| -> |[ {x: ?x; s; !x} ]|
    where new => x

// overlays

  Desugar :
    OverlayNoArgs(f, t) -> Overlay(f, [], t)

  Desugar :
    RuleNoCond(l, r) 	-> Rule(l, r, Id)

  Desugar :
    ParenStrat(x) -> x

// congruences

  Desugar :
    AnnoCong(s1, StrategyCurly(s2)) -> Call(SVar("Anno_Cong__"), [s1, s2])

  Desugar :
    EmptyTupleCong() -> Call(SVar(""), [])

  Desugar :
    TupleCong([x]) -> x

  Desugar :
    TupleCong(ts) -> Call(SVar(""), ts)
    where <not([id])> ts

  Desugar :
    TupleCong(t,ts) -> Call(SVar(""), [t|ts])

  Desugar :
    ExplodeCong(s1, s2) -> 
    |[ {x, x', y, y': (x#(y) -> x'#(y') where <s1> x => x'; <s2> y => y')} ]|
    where new => x; new => x'; new => y; new => y'

  Desugar :
    ListCongNoTail(ts) -> 
    <foldr(!Call(SVar("Nil"),[]),\ (t1, t2) -> Call(SVar("Cons"),[t1,t2]) \ )> ts

  Desugar :
    ListCong(ts,t) -> 
    <foldr(!t,\ (t1, t2) -> Call(SVar("Cons"),[t1,t2]) \ )> ts

  Desugar :
    StrCong(x) -> Match(NoAnnoList(Str(x)))

  Desugar :
    IntCong(x) -> Match(NoAnnoList(Int(x)))

  Desugar :
    RealCong(x) -> Match(NoAnnoList(Real(x)))

  Desugar :
    CharCong(c) -> Match(NoAnnoList(Char(c)))

  /**
   * A quoted congruence is translated to a strategy call.
   */
  Desugar :
    CongQ(f, ss) -> Call(SVar(<escape> f), ss)

/**
 * Term sugar
 */
rules

  Desugar :
    NoAnnoList(Tuple([t])) -> t

  Desugar :
    AnnoList(Tuple([NoAnnoList(t)]), t*) -> AnnoList(t, t*)

  Desugar :
    AnnoList(Tuple([AnnoList(t, t1*)]), t2*) -> AnnoList(t, t1*)

  Desugar :
    Tuple(ts) -> Op("", ts)
    where <not([id])> ts

  Desugar :
    List([]) -> Op("Nil", [])

  Desugar :
    List([t | ts]) -> 
    Op("Cons", [t, <foldr(!NoAnnoList(Op("Nil",[])), 
			  \ (t1, t2) -> NoAnnoList(Op("Cons",[t1,t2])) \ )> ts])

  Desugar :
    ListTail([],t) -> t

  Desugar :
    ListTail([t1 | ts], t2) -> 
    Op("Cons", [t1, <foldr(!t2,\ (t1, t2) -> NoAnnoList(Op("Cons",[t1,t2])) \ )> ts])

  /**
   * Quoted constructors are translated to ordinary Ops, where the
   * symbol is escaped. So, the symbol "foo" is represented as
   * \"foo\".
   */
  Desugar :
    OpQ(f, ts) -> Op(<escape> f, ts)

// Signatures

  Desugar : 
    SortNoArgs(x) -> Sort(x, [])

  Desugar :
    SortList(xs) -> <foldr(!Sort("Nil",[]), !Sort("Cons",[<Fst>,<Snd>]))> xs

  Desugar :
    SortListTl(xs, y) -> <foldr(!y, !Sort("Cons",[<Fst>,<Snd>]))> xs

  Desugar :
    SortTuple(xs) -> 
    Sort("Tuple", [<foldr(!Sort("Nil",[]), !Sort("Cons",[<Fst>,<Snd>]))> xs])


// Characters

  Desugar :
    Char(c) -> Int(<int-to-string>i)
    where <DesugarChar <+ explode-string; DesugarCharGeneric> c => i

  DesugarCharGeneric :
    [39, i, 39] -> i
  DesugarChar :
    "'\\''" -> 39
  DesugarChar :
    "'\\n'" -> 10
  DesugarChar :
    "'\\t'" -> 9
  DesugarChar : // carriage return
    "'\\r'" -> 13
  DesugarChar : // space
    "'\\ '" -> 32

// note: this should not be done in frontend if already done by pack-stratego
  DesugarOnce : 
    Str(x) -> Str(y)
    where <un-double-quote; unescape> x => y

strategies

  DesugarOnce =
    DefaultVarDec(RemoveLeadingPrime)
    + RDefT(RemoveLeadingPrime,id,id,id)
    + RDef(RemoveLeadingPrime,id,id)
    + SDefT(RemoveLeadingPrime,id,id,id)
    + SDef(RemoveLeadingPrime,id,id)
    + VarDec(RemoveLeadingPrime,id)
    + Var(RemoveLeadingPrime)
    + SVar(RemoveLeadingPrime)
    + OpDecl(RemoveLeadingPrime,id)
    + Op(RemoveLeadingPrime,id)

  RemoveLeadingPrime :
    x -> x'
    where <explode-string> x => [39 | cs]
        ; <implode-string> cs => x'

  DesugarOnce :
    CallDynamic(t1,s*,t*) -> CallDynamic(Term |[ <conc-strings>(<cify>t1,t2) ]|,s*,t*)
    where 
      <length>s* ; int-to-string => i
    ; <length>t* ; int-to-string => j
    ; !NoAnnoList(Str(<concat-strings>["_",i,"_",j])) => t2

