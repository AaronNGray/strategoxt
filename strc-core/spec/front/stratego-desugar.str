module stratego-desugar
imports liblib Stratego-Sugar desugar-hl

signature
  constructors
    Con       : Var * Term * SVar   -> Term
    TupleCong : List(Strategy) -> Strategy
    TupleCong : Strategy

strategies
 
  stratego-desugar-io = 
    io-wrap(topdown(repeat(Desugar)))

  pre-desugar =
    topdown(repeat(Desugar); try(DesugarOnce))

rules

  Desugar : 
    Strat|[ <s> t ]| -> |[ !t; s ]| 

  Desugar : 
    |[ s => t ]| -> |[ s; ?t ]|

// rules

  Desugar :
    RDefNoArgs(f, r) -> RDefT(f, [], [], r)

  Desugar :
    RDef(f, xs, r) -> RDefT(f, xs, [], r)

// dynamic rules

  Desugar :
    RDecNoArgs(f) -> RDec(f, [])

  Desugar :
    RDec(f, ss) -> RDecT(f, ss, [])

  Desugar :
    DynRuleIntersectFix(rulenames, s) -> 
    CallT(SVar("dr-fix-and-intersect"), [s], [<mk-rulenames> rulenames])

  Desugar :
    DynRuleIntersect(s1, rulenames, s2) -> 
    CallT(SVar("dr-fork-and-intersect"), [s1, s2], [<mk-rulenames> rulenames])

  Desugar :
    DynRuleUnionFix(rulenames, s) -> 
    CallT(SVar("dr-fix-and-union"), [s], [<mk-rulenames> rulenames])

  Desugar :
    DynRuleUnion(s1, rulenames, s2) -> 
    CallT(SVar("dr-fork-and-union"), [s1, s2], [<mk-rulenames> rulenames])

  mk-rulenames =
    foldr(!Op("Nil",[]), !Op("Cons", [<Fst>, <Snd>]), !Str(<id>))

// strategy rules

  Desugar :
    SRDefNoArgs(f, r) -> SRDefT(f, [], [], r)

  Desugar :
    SRDef(f, xs, r) -> SRDefT(f, xs, [], r)

  Desugar :
    SRDefT(f, xs, ys, StratRule(s1, s2, s3)) -> 
    SDefT(f, xs, ys, Seq(s1, Seq(Where(s3), s2)))

  Desugar :
    SRDefT(f, xs, ys, StratRuleNoCond(s1, s2)) -> 
    SDefT(f, xs, ys, Seq(s1, s2))

// strategy definitions

  Desugar :
    SDefNoArgs(f, s) -> SDefT(f, [], [], s)

  Desugar :
    SDef(f, xs, s) -> SDefT(f, xs, [], s)

// strategy calls

  Desugar :
    CallNoArgs(f) -> CallT(f, [], [])

  Desugar :
    Call(f, ss) -> CallT(f, ss, [])

  DesugarOnce :
    PrimNoArgs(f) -> PrimT(<try(un-double-quote)>f, [], [])

  DesugarOnce :
    Prim(f,ts) -> PrimT(<try(un-double-quote)>f, [], ts)

  DesugarOnce :
    PrimT(f,ss,ts) -> PrimT(<try(un-double-quote)>f, ss, ts)

// sugar for choice

  Desugar :
    RChoice(s1, s2) -> LChoice(s2, s1)

  Desugar :
    |[ if s1 then s2 else s3 end ]| -> |[ where(s1) < s2 + s3 ]|

  Desugar :
    |[ if s1 then s2 end ]| -> |[ where(s1) < s2 + id ]|

  Desugar :
    SwitchChoiceNoOtherwise(s0, b*) -> SwitchChoice(s0, b*, |[ fail ]|)

  Desugar :
    SwitchChoice(s0, b*, s') -> |[ ?t; s0=>t0; s ]|
    where !Var(<new>) => t
        ; !Var(<new>) => t0
        ; let glchoice = \ ((si, si'), stl) -> |[ where(<~si> t0) < <~si'> t + <~stl> t ]| \ 
           in <foldr(!s', glchoice)> b*
          end => s

// overlays

  Desugar :
    OverlayNoArgs(f, t) -> Overlay(f, [], t)

  Desugar :
    RuleNoCond(l, r) 	-> Rule(l, r, Id)

  Desugar :
    StratRuleNoCond(l, r) -> StratRule(l, r, Id)

//  Desugar :
//    StratRule(l, r, s) 	-> Rule(l, r, s)

//  Desugar :
//    Inj(x) -> x

  //Desugar :
  //  InjStrat(x) -> x
 
  Desugar :
    ParenStrat(x) -> x

//  Desugar :
//    AngleStrat(x) -> x

// congruences

  Desugar :
    AnnoCong(s1, StrategyCurly(s2)) -> Call(SVar("Anno_Cong__"), [s1, s2])

  Desugar :
    EmptyTupleCong() -> Call(SVar(""), [])

  Desugar :
    TupleCong([x]) -> x

  Desugar :
    TupleCong(ts) -> Call(SVar(""), ts)
    where <not([id])> ts

  Desugar :
    TupleCong(t,ts) -> Call(SVar(""), [t|ts])

  Desugar :
    ListCongNoTail(ts) -> 
    <foldr(!Call(SVar("Nil"),[]),\ (t1, t2) -> Call(SVar("Cons"),[t1,t2]) \ )> ts

  Desugar :
    ListCong(ts,t) -> 
    <foldr(!t,\ (t1, t2) -> Call(SVar("Cons"),[t1,t2]) \ )> ts

  Desugar :
    ModCong(m, xs) -> Call(SVar(m), xs)

  Desugar :
    ModCongNoArgs(m) -> Call(SVar(m), [])

  Desugar :
    StrCong(x) -> Match(NoAnnoList(Str(x)))

  Desugar :
    IntCong(x) -> Match(NoAnnoList(Int(x)))

  Desugar :
    RealCong(x) -> Match(NoAnnoList(Real(x)))

  Desugar :
    CharCong(c) -> Match(NoAnnoList(Char(c)))

// Term sugar

  Desugar :
    NoAnnoList(Tuple([t])) -> t

  Desugar :
    AnnoList(Tuple([NoAnnoList(t)]), t*) -> AnnoList(t, t*)

  Desugar :
    AnnoList(Tuple([AnnoList(t, t1*)]), t2*) -> AnnoList(t, t1*)

  Desugar :
    Tuple(ts) -> Op("", ts)
    where <not([id])> ts

  Desugar :
    List([]) -> Op("Nil", [])

  Desugar :
    List([t | ts]) -> 
    Op("Cons", [t, <foldr(!NoAnnoList(Op("Nil",[])), 
			  \ (t1, t2) -> NoAnnoList(Op("Cons",[t1,t2])) \ )> ts])

  Desugar :
    ListTail([],t) -> t

  Desugar :
    ListTail([t1 | ts], t2) -> 
    Op("Cons", [t1, <foldr(!t2,\ (t1, t2) -> NoAnnoList(Op("Cons",[t1,t2])) \ )> ts])

// Contexts

  //Desugar :
  //  Con(t1, Con1(t2)) -> Con(t1, t2, Call(SVar("oncetd"),[]))

  DesugarOnce :
    Con(t1, t2, f) -> Con(t1, t2, Call(SVar(f),[]))
    where <is-string> f

  Desugar :
    Con1(t1, t2) -> Con(t1, t2, Call(SVar("oncetd"),[]))

  Desugar :
    Con3(t1, _, t2) ->  Con(t1, t2, Call(SVar("oncetd"),[]))

  Desugar :
    Con4(t1, _, t2, f) -> Con(t1, t2, Call(SVar(f),[]))

// Signatures

  Desugar : 
    SortNoArgs(x) -> Sort(x, [])

  Desugar :
    SortList(xs) -> <foldr(!Sort("Nil",[]), !Sort("Cons",[<Fst>,<Snd>]))> xs

  Desugar :
    SortListTl(xs, y) -> <foldr(!y, !Sort("Cons",[<Fst>,<Snd>]))> xs

  Desugar :
    SortTuple(xs) -> 
    Sort("Tuple", [<foldr(!Sort("Nil",[]), !Sort("Cons",[<Fst>,<Snd>]))> xs])


// Characters

  Desugar :
    Char(c) -> Int(<int-to-string>i)
    where <DesugarChar <+ explode-string; DesugarCharGeneric> c => i

  DesugarCharGeneric :
    [39, i, 39] -> i
  DesugarChar :
    "'\\''" -> 39
  DesugarChar :
    "'\\n'" -> 10
  DesugarChar :
    "'\\t'" -> 9
  DesugarChar : // carriage return
    "'\\r'" -> 13
  DesugarChar : // space
    "'\\ '" -> 32

// Constants

//  DesugarOnce : 
//    Int(x) -> Int(y)
//    where <int-to-string> x => y

//  DesugarOnce : 
//    Real(x) -> Real(y)
//    where <real-to-string> x => y

//  DesugarOnce : 
//    Int(x) -> Int(y)
//    where <string-to-int> x => y

//  DesugarOnce : 
//    Real(x) -> Real(y)
//    where <string-to-real> x => y

// note: this should not be done in frontend if already done by pack-stratego
  DesugarOnce : 
    Str(x) -> Str(y)
    where <un-double-quote; unescape> x => y

strategies

  DesugarOnce =
    DefaultVarDec(RemoveLeadingPrime)
    + RDefT(RemoveLeadingPrime,id,id,id)
    + RDef(RemoveLeadingPrime,id,id)
    + SDefT(RemoveLeadingPrime,id,id,id)
    + SDef(RemoveLeadingPrime,id,id)
    + VarDec(RemoveLeadingPrime,id)
    + Var(RemoveLeadingPrime)
    + SVar(RemoveLeadingPrime)
    + OpDecl(RemoveLeadingPrime,id)
    + Op(RemoveLeadingPrime,id)

  RemoveLeadingPrime :
    x -> x'
    where <explode-string> x => [39 | cs]
        ; <implode-string> cs => x'





