module frame-composition
imports liblib Stratego-Core
signature
  constructors
    Offsets : Int * Int -> Annotation
    Closure : String -> Annotation
    ApplyClosure : Annotation
    Frames : String * List(String) * Int -> Annotation

strategies

  // count the number of escaping variables and functions per definition

  frame-composition = 
    io-wrap(annotate-frame-offsets)

  annotate-frame-offsets = 
    id

/*

  ev-let :
    |[ let def1* in s1 end ]| -> |[ let def2* in s2 end ]|
    where {| FrameOf, Closure, VisibleDef, UsedAsArg
           : <map(declare-frame-of)> def1*
	   ; <ev> def1* => def2*
	   ; <ev> s1 => s2
           |}

  ev-sdef :
    |[ f(a1*|a2*) = s ]| -> (|[ f'(a3*|a4*) = s' ]|){(off1, off2)}
    where {| CurrentFrame, NextVarOffSet, NextSVarOffSet, 
             OffSet, Escapes, Closure, FrameOf
           : rules( 
               CurrentFrame :+ _ -> f
               NextVarOffSet+f : f -> 0
	       NextSVarOffSet+f : f -> 0
               Escapes+f : f{t*} -> f{"local",t*}
	       VisibleDef : f
               UsedAsArg+f : f{t*} -> f{"not-used-as-arg", t*}
             )
	   ; <map(declare-str-arg(|f))> a1*
	   ; <map(declare-trm-arg(|f))> a2*
	   ; debug(!"sdef :")
	   ; <ev> s => s'
	   ; debug(!"sdef body:")
           ; <map(escaping-arg)> a1* => a3*
	   ; <map(escaping-arg)> a2* => a4*
           ; <NextSVarOffSet> f => off1
           ; <NextVarOffSet> f => off2
	   ; <UsedAsArg; Escapes> f => f'
           |}

  ev-scope : 
    |[ {x1* : s1} ]| -> |[ {x2* : s2} ]|
    where CurrentFrame => f
	; {| FrameOf, Escapes, OffSet
           : <map(declare-local-var(|f))> x1*
	   ; debug(!"scope decsa :")
	   ; <ev> s1 => s2
	   ; debug(!"scope body :")
	   ; <map(Escapes)> x1* => x2*
	   ; debug(!"scope decsb :")
           |}

  declare-str-arg(|f) =
    ?Typedid|[ x : tp ]|
    ; rules(
        Closure   : SVar(x{t*}) -> SVar(x{"closure",t*})
        FrameOf   : x -> f
        Escapes+x : x{t*} -> x{"local",t*}
        OffSet+x  :- x
      )

  declare-trm-arg(|f) =
    ?Typedid|[ x : tp ]|
    ; where(<declare-local-var(|f)> x)

  declare-local-var(|f) = ?x;
    rules(
      FrameOf   : x -> f
      Escapes+x : x{t*} -> x{"local",t*}
      OffSet+x  :- x
    )

  ev-call :
    |[ f(s1* | t*) ]| -> |[ f(s2* | t*) ]|
    where debug(!"ev-call: ")
	; <map(mark-used-as-arg <+ debug(!"strange str arg: "); fail)> s1* => s2*

  mark-used-as-arg = debug(!"mark-used-as-arg 1: ");
    ?CallT(f{t1*},[],[])
    ; debug(!"mark-used-as-arg 2: ")
    ; dr-print-rule-set(|"UsedAsArg")
    ; rules( UsedAsArg : f{t2*} -> f{"used-as-arg", t2*} )
    ; debug(!"mark-used-as-arg 3: ")

  escaping-arg :
    Typedid|[ x : tp ]| -> Typedid|[ y : tp ]|
    where <Escapes> x => y

  escaping-var :
    Var(x{t1*}){t2*} -> <debug(!"annotated: ")> Var(x{("frames", off, ys),t1*}){t2*}
    where debug(!"escaping-var: ")
	; <FrameOf> x => f
	; debug(!"frame-of: ")
	; bigbagof-CurrentFrame
	; take-until(?f) => ys
	; debug(!"frames: ")
	; if <eq> ([], ys) then
            !"local" => off
          else if <OffSet> x => off then
            id
          else
	    debug(!"no offset defined yet; ");
            <NextVarOffSet> f => off
	    ; debug(!"next offset: ")
 	    ; inc => new-off
	    ; debug(!"next next offset: ")
            ; rules(
                NextVarOffSet.f : f -> new-off
                OffSet.x : x -> off
                Escapes.x : x{t*} -> x{("escapes", off),t*}
              )
	    ; debug(!"rules defined: ")
          end end

  escaping-var :
    SVar(x{t1*}){t2*} -> <debug(!"annotated: ")> SVar(x{("frames", off, ys),t1*}){t2*}
    where debug(!"escaping-var: ")
	; <FrameOf> x => f
	; debug(!"frame of: ")
	; bigbagof-CurrentFrame 
	; debug(!"frames: ")
	; take-until(?f) => ys
	; debug(!"frames: ")
        ; if <VisibleDef> x then
	    debug(!"visible: ")
            ; !"visible" => off
          else if <eq>(f, "top-level") then
            debug(!"top-level: ")
            ; !"top-level" => off
	  else if <eq> ([], ys) then
            debug(!"local: ")
            ; !"local" => off
          else if <OffSet> x => off then
            <debug(!"offset already defined: ")> off
          else
	    debug(!"no offset defined yet; ");
            <NextSVarOffSet> f => off
	    ; debug(!"next offset: ")
 	    ; inc => new-off
	    ; debug(!"next next offset: ")
            ; rules(
                NextSVarOffSet.f : f -> new-off
                OffSet.x : x -> off
                Escapes.x : x{t*} -> x{("escapes", off),t*}
              )
	    ; debug(!"rules defined: ")
	    ; dr-print-rule-set(|"Escapes")
          end end end end

*/
