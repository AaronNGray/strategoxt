/**
 * Annotate strategy invocations and term variable uses with the
 * path to their defining frames, and annotate their declarations as
 * escaping when applicable.
 */

module escaping-variables
imports liblib Stratego-Core

signature
  constructors
    Frames  : String * List(String) -> Annotation
    Frames  : List(String) -> Annotation
    Escapes : Annotation

strategies

  escaping-variables = 
    io-wrap(mark-escaping-variables)

  mark-escaping-variables =
    {| CurrentFrame, FrameOf, Escapes, Closure
     : init-current-frame
     ; alltd(declare-frame-of)
     ; alltd({?|[ f( a1* | a2* ) = s ]|}; ev)
     |}

  init-current-frame =
    rules( CurrentFrame :+ _ -> "top-level" )

  declare-frame-of =
    ?|[ f(a1*|a2*) = s ]|
    ; where( CurrentFrame => g )
    ; rules( 
        FrameOf   : f -> g
        Escapes+f :- f{t*}
        Closure+f :- f{t*}
      )

  ev = //debug(!"in: "); (
    escaping-var <+ ev-sdef <+ ev-scope <+ ev-let 
    <+ all(ev); try(args-should-be-closures)
  //); debug(!"out: ")

  ev-let :
    |[ let def1* in s1 end ]| -> |[ let def3* in s2 end ]|
    where {| FrameOf, Escapes, Closure
           : <map(declare-frame-of)> def1*
	   ; <ev> def1* => def2*
	   ; <ev> s1 => s2
	   ; <map(SDefT(try(Closure; try(Escapes)),id,id,id))> def2* => def3*
           |}

  ev-sdef :
    |[ f(a1*|a2*) = s ]| -> |[ f(a3*|a4*) = s' ]|
    where {| CurrentFrame, Escapes, FrameOf, Closure
           : rules( CurrentFrame :+ _ -> f )
	   ; <map(declare-arg(|f))> a1*
	   ; <map(declare-arg(|f))> a2*
	   ; <ev> s => s'
           ; <map(try(escaping-arg))> a1* => a3*
	   ; <map(try(escaping-arg))> a2* => a4*
           |}

  ev-scope : 
    |[ {x1* : s1} ]| -> |[ {x2* : s2} ]|
    where CurrentFrame => f
	; {| FrameOf, Escapes
           : <map(declare-local-var(|f))> x1*
	   ; <ev> s1 => s2
	   ; <map(try(Escapes))> x1* => x2*
           |}

  declare-arg(|f) =
    ?Typedid|[ x : tp ]|
    ; where(<declare-local-var(|f)> x)

  escaping-arg :
    Typedid|[ x : tp ]| -> Typedid|[ y : tp ]|
    where <Escapes> x => y

  declare-local-var(|f) = ?x;
    rules(
      FrameOf   : x -> f
      Escapes+x :- x{t*}
    )

  escaping-var =
    Var(escaping-var-id) <+ SVar(escaping-var-id)

  escaping-var-id :
    x{t1*} -> x{Frames(frames),t1*}
    where <frames-to-parent> x => frames
	; if <not(eq)> ([], frames) then
            rules( Escapes.x : x{t*} -> x{Escapes,t*} )
          end

  frames-to-parent =
    where(FrameOf => f)
    ; bigbagof-CurrentFrame
    ; take-until(?f)

  args-should-be-closures = 
    CallT(id,map(arg-should-be-closure),id)

  arg-should-be-closure :
    |[ f~{t1*}(|) ]| -> |[ f~{Closure(x),t1*}(|) ]|
    where <conc-strings> (f, "_cl") => x
	; rules( Closure.f{} : f{t2*} -> f{Closure(x),t2*} )

	// tricky: label should not have annotations, otherwise there is no match   
