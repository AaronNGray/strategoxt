module escaping-variables
imports Stratego-Core
strategies

  // mark variables and function arguments as escaping

  // count the number of escaping variables and functions per definition

  mark-escaping-variables =
    alltd(SDefT(id,id,id,id); ev)

strategies

  ev = 
    ev-var
    <+ ev-sdef
    <+ ev-scope
    <+ all(ev)

  // by default a variable does not escape

  dont-escape = 
    ?x
    ; where( CurrentFrame => f )
    ; rules(
        VarEscape+x : x -> x
        FrameOf     : x -> f
        OffSet+x    :- x
      )

  // if encountered in a nested definition it does escape

  ev-var = 
   (?Var(x) <+ ?SVar(x)); ?y
   ; debug(!"ev-var: ")

   ; where(<not(eq)> (<CurrentFrame>, <FrameOf> x))
   ; debug(!"ev-var escaping: ")

   ; where(
      <OffSet> x => off; debug(!"offset: ")
      <+ <one(FrameOf => f); !<id>{}> y => f'
         ; debug(!"frame: ")
         ; NextOffSet => off
         ; debug(!"next offset: ")
	 ; inc => new-off
         ; debug(!"new next offset: ")
	 ; dr-print-rule-set(|"NextOffSet")
         ; rules(
             NextOffSet.f : f' -> new-off
             OffSet.x : x -> off
           )
	 ; dr-print-rule-set(|"NextOffSet")
         ; where(<NextOffSet> f'; debug(!"NextOffSet: "))
     )
   ; rules( VarEscape.x : x -> x{("escapes", off)} )

   ; one(\ z{t*} -> z{("offset", off), t*} \ )
   ; debug(!"annotation: ")


  // declare parameters of definitions and mark as escaping
  // after traversing body of definition

  ev-sdef =
    ?SDefT(f, xs, ys, s)
    ; {| VarEscape, CurrentFrame, FrameOf, NextOffSet, OffSet
       : where(!Var(f) => f1; !SVar(f) => f2)
       ; rules( 
           CurrentFrame :+ _ -> f
           NextOffSet+f : f1 -> 0
	   NextOffSet+f : f2 -> 0
         )
       ; SDefT(id, map(VarDec(dont-escape,id)),
                   map(VarDec(dont-escape,id)), ev)
       ; SDefT(id, map(VarDec(VarEscape,id)), 
                   map(VarDec(VarEscape,id)), id)
       ; \ sdef -> sdef{(off1, off2)}
           where <NextOffSet> SVar(f) => off1
	       ; <NextOffSet> Var(f) => off2 \
       |}

  // declare local variables of a scope and mark as escaping
  // after traversing body of scope

  ev-scope =
    ?Scope(x*, s)
    ; {| VarEscape, FrameOf
       : Scope(map(dont-escape), ev)
       ; Scope(map(VarEscape), id)
       |}

strategies

  init-frames =
    rules( Frame :+ _ -> "_outermost" )

  frame-of =
    FrameOf <+ !"_outermost"

  function-pointer =
    if not(frame-of => "_outermost") then
      id
    end

  var-access =
    id    

  frame =
    ?f
    ; Frame

  static-link =
    debug(!"static-link: ");
    where(frame-of => g)
    ; debug(!"static-link a: ")
    ; bigbagof-Frame
    ; debug(!"static-link b: ")
    ; take-until(?g)
    ; debug(!"static-link c: ")
    ; foldr(
        !exp|[ sl ]|,
	!exp|[ sl_up(~exp:<Snd>) ]|
      )
    ; debug(!"static-link d: ")
