module fusion
imports Stratego stratego-laws liblib desugar fusion-rules

signature
  constructors
    Mark : Strat

strategies

  fusion-io = 
    io-wrap(
      declare-inline-rules
      ; ( check-library-definitions
        ; alltd(innermost-fusion)

// turn off outermost-fusion while it is not finished (EV)
//        ; alltd(innermost-fusion + outermost-fusion)

        ) <+ log(|Info(),"No innermost here")
    )


  // Inlining strategy definitions

  declare-inline-rules =
    Specification([Signature(id),
                   Strategies(map(declare-inline-rule))])

  declare-inline-rule =
    ?|[ f(a1*|a2*) = s1 ]|;
    rules(
      InlineStrat :
        Strategy|[ f(s*|t*) ]| -> <simplify0> |[ { x* : s4; s3 } ]|
        where <strename> |[ f(a1*|a2*) = s1 ]| => |[ f(a3*|a4*) = s2 ]|
	    ; <ssubs> (<map(?VarDec(<id>,_))> [a3*], [s*], s2) => s3
	    ; <map(?VarDec(<id>,_))> a2* => x*
	    ; !<zip(\ (t, y) -> |[ !t; ?y ]|\ ); seqs>(t*, x*) => s4
    )

  inline-rules = 
    rec x(try(
        Simplify
	+ Choice(x, x)
	+ LChoice(x, x) 
	+ Scope(id, Seq(Match(id),Build(id)))
	+ Scope(id, Seq(Match(id),Seq(id,Build(id))))
	+ InlineStrat; x
    ))

  // Check library definitions
  // note that other implementations might also be correct

  check-library-definitions =
    check-that-try-is-try
    ; check-that-innermost-is-innermost
    ; check-that-bottomup-is-bottomup

  check-that-try-is-try =
    where(
      new => x
      ; (<InlineStrat> Strategy|[ try_1_0(x(|)|) ]|
         <+ log(|Info(),"No definition of try_1_0: ",<id>); fail)
      ; (?|[ x(|) <+ id ]|
         <+ log(|Info(),"try is not try"); fail)
      ; log(|Info(),"try is try ")
    )

  check-that-innermost-is-innermost =
    where(
      new => x
      ; (<InlineStrat> Strategy|[ innermost_1_0(x(|)|) ]|
         <+ log(|Info(),"No definition of innermost_1_0"); fail)
      ; (?|[ bottomup_1_0(try_1_0(x(|); innermost_1_0(x(|)|)|)|) ]|
         <+ {z: ?|[ bottomup_1_0(rec z(try_1_0(x(|); bottomup_1_0(z(|)|)|))|) ]|}
         <+ {z: ?|[ bottomup_1_0(rec z(x(|); bottomup_1_0(z(|)|) <+ id)|)  ]|}
         <+ log(|Info(),"innermost is not innermost"); fail)
      ; log(|Info(),"innermost is innermost ")
    )

  check-that-bottomup-is-bottomup =
    where(
      new => x
      ; (<InlineStrat> Strategy|[ bottomup_1_0(x(|)|) ]|
         <+ log(|Info(),"No definition of bottomup_1_0"); fail)
   // ; ?|[ rec y(all(y(|)); x(|)) ]|
      ; (?|[ all(bottomup_1_0(x(|)|)); x(|) ]|
         <+ log(|Info(),"bottomup is not bottomup"); fail)
      ; log(|Info(),"bottomup is bottomup")
    )

  // The fusion strategy

  innermost-fusion = 
    ?|[ innermost_1_0(s1|) ]| 
    ; log(|Info(),"Application of innermost found")

    ; where(new => x)
    ; where(<seq-over-choice> Strategy|[ bottomup_1_0(x(|)|) ]|)
    ; where(<bottomup-to-var> Strategy|[ bottomup_1_0(x(|)|) ]|)

    ; where(<inline-rules> s1 => s2)
    ; !|[ bottomup_1_0(rec x((mark(|); s2); bottomup_1_0(x(|)|) <+ id)|) ]|
    ; propagate-mark

    ; fuse-with-bottomup
    ; alltd(BottomupToVarIsId-UnCond + BottomupToVarIsId-Cond <+ UnMark)

    ; not(oncetd(?Strategy|[ mark(|) ]|)
          ; say(!"not all marks removed"))
    ; desugar
    ; log(|Info(),"Fused application of innermost")

  // Propagate mark over choice

  propagate-mark = 
    innermost(
	SeqOverChoiceL
	+ SeqOverLChoiceL
	+ SeqOverScopeL 
    )

  fuse-with-bottomup = 
    innermost(
	SeqOverChoiceR
	+ SeqOverLChoiceR
	+ SeqOverScopeR
	+ AssociateR
	+ IntroduceApp
	+ BottomupOverConstructor
    )

  propagate-nf-assertion = 
    is-innermost;
    innermost(
	SeqOverChoiceL
	+ SeqOverLChoiceL
	+ SeqOverScopeL 
	+ AssociateL
	+ IntroduceApp
	+ NormalFormToBuildVars
    )

  // The following rule applies in the context of the transformation
  // above, where we know that the bottomup is the application of the
  // normalisation strategy to all subterms. Since the variable
  // originates in the left-hand side of the rewrite rule, we know
  // it is already in normal form.

  bottomup-to-var-old =
    ?bu
  ; rules(
      BottomupToVarIsId-UnCond :
        |[ mark(|); ?t1; !t2 ]| -> |[ ?t1; !t3 ]|
        where !bu => s
            ; <tvars> t1 => vs
            ; {| Replace : 
                 map(!Var(<id>); {?t; rules(Replace : Term|[ <s> t ]| -> Term|[ t ]|)})
                 ; <alltd(Replace)> t2 => t3 |}

      BottomupToVarIsId-Cond :
        |[ mark(|); ?t1; where(s); !t2 ]| -> |[ ?t1; where(s'); !t2 ]|
        where !bu => s''
            ; <tvars> t1 => vs
            ; {| Replace : 
                 map(!Var(<id>); {?t; rules(Replace : Term|[ <s''> t ]| -> Term|[ t ]|)})
                 ; <alltd(Replace)> (s, t2) => (s', t3) |}
   )

  bottomup-to-var = ?bu;
    rules(
      BottomupToVarIsId-UnCond :
        |[ mark(|); ?t1; !t2 ]| -> |[ ?t1; !t3 ]|
        where <replace-application> (bu, t1, t2) => t3

      BottomupToVarIsId-Cond :
        |[ mark(|); ?t1; where(s); !t2 ]| -> |[ ?t1; where(s'); !t3 ]|
        where <replace-application> (bu, t1, (s, t2)) => (s', t3)
    )

   replace-application :
     (s, t1, t2) -> t3
     where {| Replace : 
              <tvars; map({?x; rules(Replace : Term|[ <s> x ]| -> Term|[ x ]|)})> t1;
              <alltd(Replace)> t2 => t3 
           |}

  // remove mark

  UnMark :
    Strategy|[ mark(|) ]| -> Strategy|[ id ]|

  outermost-fusion :
    |[ outermost_1_0(s1|) ]| -> 
    |[ let f = repeat(rec x(s2 <+ s3)); all(f) in f end ]|
    where log(|Info(),"Application of outermost found")
	; new => x
	; new => f
	; <inline-rules> s1 => s2
        ; derive-hnf-traversal(|x) => s3

  derive-hnf-traversal(|x) =
    collect-guards
    ; debug(!"guards: ")
    ; map(merge-terms(|x))
//    ; foldr1(?[<id>], \ (s1, s2) -> |[ s1 <+ s2 ]|\ ) => s3

  collect-guards = 
  {|Guard :
    rec y(
      Choice(y, y) 
      <+ LChoice(y, y) 
      <+ Scope(id, y)
      <+ Seq(y, id)
      <+ Match({
           ?t@|[ c(t*) ]|
	   ; if <fetch({?|[c2(t2*)]|})> t* then
               rules(
	         Guard :+ () -> c 
	         Guard :+ c -> t
               )
	     end
         })
     )
     ; <bagof-Guard> ()
     ; make-set
     ; map(bagof-Guard)
  |}

  merge-terms(|x) =
    ?[ |[ c(t*) ]| | _]
    ; debug
    ; map({t* : (|[ c(t*) ]| -> t* )})
    ; debug
    ; transpose
    ; debug(!"transposed: ")
    ; map(merge-subterms(|x))
    ; !Cong(c, <id>)

  transpose = 
    map([]); ![] <+ ![<map(Hd)> | <map(Tl); transpose>]

  merge-subterms(|x) :
    t* -> |[ x(|); (s <+ try(x(|))) ]|
    where 
      <foldr(!|[fail]|, \ (s1,s2) -> |[ s1 <+ s2 ]| \, term-to-cong)> t* => s
 
  term-to-cong :
    |[ c(t*) ]| -> Cong(c, <map(!|[id]|)> t*)
    where <map(Var(id))> t*

/*

  derive-hnf-traversal(|x) :
    Term|[ c(t*) ]| -> Cong(c, <map(norm-subterm(|x))> t*)
    where <fetch(?|[ c2(t2*) ]|)> t*

  norm-subterm(|x) :
    Term|[ x ]| -> |[ id ]|

  norm-subterm(|x) :
    Term|[ c(t*) ]| -> |[ x; (c(s1*) <+ try(x)) <+ c(s2*) ]|
    where <map(!|[ id ]|)> t* => s1*
    
*/
