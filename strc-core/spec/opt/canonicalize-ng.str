module canonicalize-ng
imports Stratego-Core libstratego-lib C stratego-laws

strategies

  canonicalize-ng-io =
    io-wrap(canonicalize)

  canonicalize =
    canonicalize-sdef
    <+ canonicalize-let
    <+ try(ImplementTraversalOps); canonicalize-call; canonicalize
    <+ all(canonicalize)

  canonicalize-sdef :
    |[ f(a1*|a2*) = s ]| -> |[ f(a1*|a2*) = s' ]|
    where {| IsClosure
           : where(<map(declare-closure)> a1* )
           ; <canonicalize> s => s'
           |}

  canonicalize-let :
    |[ let def1* in s1 end ]| -> |[ let def2* in s2 end ]|
    where {| IsClosure
           : <map(try(declare-closure-def))> def1* 
	   ; <canonicalize> def1* => def2*
           ; <canonicalize> s1 => s2
           |}

  declare-closure =
    ?VarDec(f, t)
    ; rules( IsClosure : |[ f(|) ]| )

  declare-closure-def =
    ?|[ f(|) = s ]|
    ; rules( IsClosure : |[ f(|) ]| )

  canonicalize-call :
    |[ f(s1*|t*) ]| -> |[ let def* in f(s2*|t*) end ]|
    where <map(IsClosure; !([],<id>) <+ lift-call-arg)> s1*
          ; unzip; (concat, id) => (def*, s2*)
	  ; not(([],id))

  canonicalize-call :
    |[ prim(str,s1*|t*) ]| -> |[ let def* in prim(str,s2*|t*) end ]|
    where <map(IsClosure; !([],<id>) <+ lift-call-arg)> s1*
          ; unzip; (concat, id) => (def*, s2*)
	  ; not(([],id))

  lift-call-arg :
    |[ s ]| -> ([|[ g(|) = s' ]|], |[ g(|) ]|)
    where new => g
	; <canonicalize> s => s'


  ImplementTraversalOps :
    |[ all(s) ]| -> |[ SRTS_all(s|) ]|

  ImplementTraversalOps :
    |[ one(s) ]| -> |[ SRTS_one(s|) ]|

  ImplementTraversalOps :
    |[ some(s) ]| -> |[ SRTS_some(s|) ]|

/*

strategies

  canonicalize-io =
    io-wrap(
      downup2(repeat(Canon + LiftPrimArgs + LiftCallArgs),repeat(Canon))
      ; simplify0
    )

rules

  CallIdFun :
    Id -> CallT(SVar("_Id"),[],[])

  CallFailFun :
    Fail -> CallT(SVar("_Fail"),[],[])

  Canon :
    All(s) -> CallT(SVar("SRTS_all"),[s],[])

  Canon :
    One(s) -> CallT(SVar("SRTS_one"),[s],[])

  Canon :
    Some(s) -> CallT(SVar("SRTS_some"),[s],[])




  Canon =
    let
      canon-args = 
        unzip(try(CallIdFun + CallFailFun)
              ; ( CreateDef1 
	          <+ not(CallT(SVar(id),[],[])); CreateDef2 
	          <+ !(<id>,[])
	          ))
        ; (id, concat; not([]))
    in
      ( ?CallT(f, args1, args2) 
      + ?CallDynamic(f, args1, args2)
      + ?PrimT(f, args1, args2) 
      ) => c#(_) 
    ; <canon-args>args1 => (args1', defs) 
    ; !Let(defs, c#([f, args1', args2]))
    end

  CreateDef1 :
    Let(defs,CallT(SVar(f),[],[])) -> (CallT(SVar(f),[],[]), defs)

  CreateDef2 :
    s -> (CallT(SVar(f),[],[]), [SDefT(f,[],[],s)])
    where new => f





  Canon :
    CallT(f, args1, args2) -> CallT(f, args1', args2)
    where //<map(try(CallIdFun + CallFailFun))> args => args'
      <rec x([(CallIdFun + CallFailFun)|try(x)] <+ [id|x])> args1 => args1'

  Canon :
    PrimT(f, args1, args2) -> PrimT(f, args1', args2)
    where //<map(try(CallIdFun + CallFailFun))> args => args'
      <rec x([(CallIdFun + CallFailFun)|try(x)] <+ [id|x])> args1 => args1'

*/
