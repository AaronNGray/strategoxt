module escaping-variables
imports libstratego-lib Stratego-Core
strategies

  // mark variables and function arguments as escaping

  // count the number of escaping variables and functions per definition

  escaping-variables = 
    io-wrap(mark-escaping-variables)

  mark-escaping-variables =
    {| CurrentFrame, FrameOf, VisibleDef
     : init-current-frame
     ; alltd(declare-frame-of)
     ; alltd({?|[ f( a1* | a2* ) = s ]|}; ev; say(!""); debug(!"mev out: "))
     |}

strategies

  init-current-frame =
    rules( CurrentFrame :+ _ -> "top-level" )

  declare-frame-of =
    ?|[ f(a1*|a2*) = s ]|
    ; where( CurrentFrame => g )
    ; rules( 
        FrameOf : f -> g 
        VisibleDef : f
      )

strategies

  ev = debug(!"in: "); (
      ?Var(_)         < foo(escaping-var)
    + ?SVar(_)        < foo(escaping-var; try(Closure))
    + ?SDefT(_,_,_,_) < foo(ev-sdef)
    + ?Scope(_,_)     < foo(ev-scope)
    + ?Let(_,_)       < foo(ev-let)
    + ?CallT(_,_,_)   < foo(all(ev); ev-call)
    + all(ev)
  ); debug(!"out: ")


  foo(s) = 
    s <+ debug(!"error: "); <exit> 1

  ev-let :
    |[ let def1* in s1 end ]| -> |[ let def2* in s2 end ]|
    where {| FrameOf, Closure, VisibleDef, UsedAsArg
           : <map(declare-frame-of)> def1*
	   ; <ev> def1* => def2*
	   ; <ev> s1 => s2
           |}

  ev-sdef :
    |[ f(a1*|a2*) = s ]| -> (|[ f'(a3*|a4*) = s' ]|){(off1, off2)}
    where {| CurrentFrame, NextVarOffSet, NextSVarOffSet, 
             OffSet, Escapes, Closure, FrameOf
           : rules( 
               CurrentFrame :+ _ -> f
               NextVarOffSet+f : f -> 0
	       NextSVarOffSet+f : f -> 0
               Escapes+f : f{t*} -> f{"local",t*}
	       VisibleDef : f
               UsedAsArg+f : f{t*} -> f{"not-used-as-arg", t*}
             )
	   ; <map(declare-str-arg(|f))> a1*
	   ; <map(declare-trm-arg(|f))> a2*
	   ; debug(!"sdef :")
	   ; <ev> s => s'
	   ; debug(!"sdef body:")
           ; <map(escaping-arg)> a1* => a3*
	   ; <map(escaping-arg)> a2* => a4*
           ; <NextSVarOffSet> f => off1
           ; <NextVarOffSet> f => off2
	   ; <UsedAsArg; Escapes> f => f'
           |}

  ev-scope : 
    |[ {x1* : s1} ]| -> |[ {x2* : s2} ]|
    where CurrentFrame => f
	; {| FrameOf, Escapes, OffSet
           : <map(declare-local-var(|f))> x1*
	   ; debug(!"scope decsa :")
	   ; <ev> s1 => s2
	   ; debug(!"scope body :")
	   ; <map(Escapes)> x1* => x2*
	   ; debug(!"scope decsb :")
           |}

  declare-str-arg(|f) =
    ?Typedid|[ x : tp ]|
    ; rules(
        Closure   : SVar(x{t*}) -> SVar(x{"closure",t*})
        FrameOf   : x -> f
        Escapes+x : x{t*} -> x{"local",t*}
        OffSet+x  :- x
      )

  declare-trm-arg(|f) =
    ?Typedid|[ x : tp ]|
    ; where(<declare-local-var(|f)> x)

  declare-local-var(|f) = ?x;
    rules(
      FrameOf   : x -> f
      Escapes+x : x{t*} -> x{"local",t*}
      OffSet+x  :- x
    )

  ev-call :
    |[ f(s1* | t*) ]| -> |[ f(s2* | t*) ]|
    where debug(!"ev-call: ")
	; <map(mark-used-as-arg <+ debug(!"strange str arg: "); fail)> s1* => s2*

  mark-used-as-arg = debug(!"mark-used-as-arg 1: ");
    ?CallT(f{t1*},[],[])
    ; debug(!"mark-used-as-arg 2: ")
    ; dr-print-rule-set(|"UsedAsArg")
    ; rules( UsedAsArg : f{t2*} -> f{"used-as-arg", t2*} )
    ; debug(!"mark-used-as-arg 3: ")

  escaping-arg :
    Typedid|[ x : tp ]| -> Typedid|[ y : tp ]|
    where <Escapes> x => y

  escaping-var :
    Var(x{t1*}){t2*} -> <debug(!"annotated: ")> Var(x{("frames", off, ys),t1*}){t2*}
    where debug(!"escaping-var: ")
	; <FrameOf> x => f
	; debug(!"frame-of: ")
	; bigbagof-CurrentFrame
	; take-until(?f) => ys
	; debug(!"frames: ")
	; if <eq> ([], ys) then
            !"local" => off
          else if <OffSet> x => off then
            id
          else
	    debug(!"no offset defined yet; ");
            <NextVarOffSet> f => off
	    ; debug(!"next offset: ")
 	    ; inc => new-off
	    ; debug(!"next next offset: ")
            ; rules(
                NextVarOffSet.f : f -> new-off
                OffSet.x : x -> off
                Escapes.x : x{t*} -> x{("escapes", off),t*}
              )
	    ; debug(!"rules defined: ")
          end end

  escaping-var :
    SVar(x{t1*}){t2*} -> <debug(!"annotated: ")> SVar(x{("frames", off, ys),t1*}){t2*}
    where debug(!"escaping-var: ")
	; <FrameOf> x => f
	; debug(!"frame of: ")
	; bigbagof-CurrentFrame 
	; debug(!"frames: ")
	; take-until(?f) => ys
	; debug(!"frames: ")
        ; if <VisibleDef> x then
	    debug(!"visible: ")
            ; !"visible" => off
          else if <eq>(f, "top-level") then
            debug(!"top-level: ")
            ; !"top-level" => off
	  else if <eq> ([], ys) then
            debug(!"local: ")
            ; !"local" => off
          else if <OffSet> x => off then
            <debug(!"offset already defined: ")> off
          else
	    debug(!"no offset defined yet; ");
            <NextSVarOffSet> f => off
	    ; debug(!"next offset: ")
 	    ; inc => new-off
	    ; debug(!"next next offset: ")
            ; rules(
                NextSVarOffSet.f : f -> new-off
                OffSet.x : x -> off
                Escapes.x : x{t*} -> x{("escapes", off),t*}
              )
	    ; debug(!"rules defined: ")
	    ; dr-print-rule-set(|"Escapes")
          end end end end

/*

strategies

  ev = 
    escaping-var
    //<+ closure-strategy
    //<+ local-strategy
    //<+ toplevel-strategy
    <+ ev-sdef
    <+ ev-scope
    <+ ev-let
    <+ all(ev)

  // declare parameters of definitions and mark as escaping
  // after traversing body of definition

  ev-sdef :
    |[ f(a1*|a2*) = s ]| -> (|[ f(a3*|a4*) = s' ]|){(off1, off2)}
    where <dont-escape> f
	; rules( IsClosure :- f )
	; {| VarEscape, CurrentFrame, NextSVarOffSet, NextVarOffSet, 
	     FrameOf, OffSet, IsClosure
           : rules( 
               CurrentFrame :+ _ -> f
               NextVarOffSet+f : f -> 0
	       NextSVarOffSet+f : f -> 0
             )
           ; <map(VarDec(dont-escape,id))> [a1*,a2*]
           ; <ev> s => s'
           ; <map(VarDec(VarEscape,id))> a1* => a3*
           ; <map(VarDec(VarEscape,id))> a2* => a4*
           ; <NextSVarOffSet> f => off1
           ; <NextVarOffSet> f => off2
           |}

  init-current-frame =
    rules( CurrentFrame :+ _ -> "top-level" )

  // by default a variable does not escape

  dont-escape = 
    ?x
    ; where( CurrentFrame => f )
    ; rules(
        VarEscape+x : x -> x
        FrameOf     : x -> f
        OffSet+x    :- x
        IsClosure   : x
      )

*/

/*

  // if encountered in a nested definition it does escape

  escaping-var :
    Var(x{t1*}){t2*} -> Var(x{("offset", off, frames), t1*}){t2*}
    where debug(!"ev-var: ")
	; <FrameOf> x => f
	; debug(!"frame: ")
	; bigbagof-CurrentFrame
	; debug(!"all frames: ")
	; take-until(?f) => frames
	; debug(!"frames: ")
	; if <?[]> frames then
	    !"local" => off
	    ; debug(!"local: ")
	  else if <OffSet> x => off then
	    <debug(!"offset: ")> off
          else
            <NextVarOffSet> f => off
            ; debug(!"next offset: ")
 	    ; inc => new-off
            ; debug(!"new next offset: ")
	    ; dr-print-rule-set(|"NextOffSet")
            ; rules(
                NextVarOffSet.f : f -> new-off
                OffSet.x : x -> off
              )
	    ; dr-print-rule-set(|"NextOffSet")
            ; <NextVarOffSet> f
            ; debug(!"NextOffSet: ")
          end end
	; rules( VarEscape.x : x -> x{("escapes", off)} )
	; debug(!"escaping-var: done")

*/

/*


  closure-strategy :
    SVar(x) -> SVar(x{"closure"})
    where <IsClosure> x

  local-strategy :
    SVar(f) -> SVar(f{"local"})
    where debug(!"local-strategy: ")
	; <debug; eq> (<CurrentFrame>, <FrameOf> f)

  toplevel-strategy :
    SVar(f) -> SVar(f{"toplevel", frames})
    where <not(FrameOf)> f
	; bigbagof-CurrentFrame => frames


  ev-let :
    |[ let def* in s end ]| -> s'
    where {| FrameOf 
           : all(ev) => s'
	   |}

  // declare local variables of a scope and mark as escaping
  // after traversing body of scope

  ev-scope :
    |[ {x1* : s1} ]| -> |[ {x2* : s2} ]|
    where {| VarEscape, FrameOf
           : <map(dont-escape)> x1*
           ; <ev> s1 => s2
           ; <map(VarEscape)> x1* => x2*
           |}

*/

/*

  escaping-var = 
    (?Var(x) <+ ?SVar(x)); ?y
    ; debug(!"ev-var: ")
    ; where(<not(eq)> (<CurrentFrame>, <FrameOf => f> x))
    ; where(
        bigbagof-CurrentFrame
        ; take-until(?f)
        ; (init <+ debug(!"*** strange frames: ")) => frames
      )
    ; debug(!"ev-var escaping: ")
    ; where(
       <OffSet> x => off; debug(!"offset: ")
       <+ <one(FrameOf => f); !<id>{}> y => f'
          ; debug(!"frame: ")
          ; NextOffSet => off
          ; debug(!"next offset: ")
 	  ; inc => new-off
          ; debug(!"new next offset: ")
	  ; dr-print-rule-set(|"NextOffSet")
          ; rules(
              NextOffSet.f : f' -> new-off
              OffSet.x : x -> off
            )
	  ; dr-print-rule-set(|"NextOffSet")
          ; where(<NextOffSet> f'; debug(!"NextOffSet: "))
      )
    ; rules( VarEscape.x : x -> x{("escapes", off)} )
    ; one(\ z{t*} -> z{("offset", off, frames), t*} \ )
    ; debug(!"annotation: ")

*/


/*

strategies

  init-frames =
    rules( Frame :+ _ -> "_outermost" )

  frame-of =
    FrameOf <+ !"_outermost"

  function-pointer =
    if not(frame-of => "_outermost") then
      id
    end

  var-access =
    id    

  frame =
    ?f
    ; Frame

  static-link =
    debug(!"static-link: ");
    where(frame-of => g)
    ; debug(!"static-link a: ")
    ; bigbagof-Frame
    ; debug(!"static-link b: ")
    ; take-until(?g)
    ; debug(!"static-link c: ")
    ; foldr(
        !exp|[ sl ]|,
	!exp|[ sl_up(~exp:<Snd>) ]|
      )
    ; debug(!"static-link d: ")

*/
