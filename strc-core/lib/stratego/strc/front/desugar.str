/**
 * Translating high-level constructs to low-level ones.
 *
 * @author Eelco Visser 1998 - 2004
 */

module desugar

imports 
  Stratego-Sugar
  stratego/strc/front/DefaultStrat 
  stratego/strc/lib/stratlib 
  stratego/strc/front/stratego-desugar
  stratego/strc/front/desugar-hl

strategies // Desugaring Strategies

  /**
   * Desugar all definitions in specification
   *
   * Note that inline bodies of external definitions are _not_
   * desugared. These are assumed to be in StrategoCore. This should
   * be checked.
   */

  desugar-spec = 
    map(
      SDef(id, id, desugar) 
      + SDefT(id, id, id, desugar)
      + ExtSDef(id, id, id) 
      + ExtSDefInl(id, id, id, id)
      <+ debug(!"not a definition: "); fail
    )

  desugar = 
    topdown(
      try(desugarRule)
      ; repeat(
          LiftPrimArgs
	  <+ LiftCallArgs 
	  <+ LiftTopLevelBuildApp
	  <+ LiftBuildApps
	  <+ LiftTopLevelMatchApp
	  <+ LiftMatchApps 
	  <+ Desugar
        )
    )

rules // Lift non-variable arguments to primitives.

  LiftPrimArgs : 
    Prim(f, ts) -> Scope(xs, Seq(<seqs>s, PrimT(f, [], ts')))
    where <fetch(not(Var(id)))> ts
        ; <unzip(LiftPrimArg); (concat, unzip(id))> ts => (xs, (s, ts'))

  LiftPrimArgs : 
    PrimT(f, ss, ts) -> Scope(xs, Seq(<seqs>s, PrimT(f, ss, ts')))
    where <fetch(not(Var(id)))> ts
        ; <unzip(LiftPrimArg); (concat, unzip(id))> ts => (xs, (s, ts'))

  LiftCallArgs : 
    CallT(f, ss, ts) -> Scope(xs, Seq(<seqs>s, CallT(f, ss, ts')))
    where <fetch(not(Var(id)))> ts
        ; <unzip(LiftPrimArg); (concat, unzip(id))> ts => (xs, (s, ts'))

  LiftCallArgs :
    CallDynamic(t, ss, ts) -> Scope(xs, Seq(<seqs>s, CallDynamic(t', ss, ts')))
      where 
        <fetch(not(Var(id)))> [t|ts] 
      ; <unzip(LiftPrimArg);(concat, unzip(id))> [t|ts] => (xs, (s, [t'|ts']))

  LiftPrimArg :
    Var(x) -> ([], (Id, Var(x)))

  LiftPrimArg :
    t -> ([x], (Where(Seq(Build(t), Match(Var(x)))), Var(x)))
    where <not(Var(id))> t; new => x


/*
 Strategy Applications

	Factoring out strategy applications; The right-hand side of a
	rule can contain applications of a strategy to a term; This is
	factored out by translating it to a condition that applies the
	strategy and matches the result against a new variable, which
	is then used in the rhs;  In fact this can be generalized to
	applications in arbitrary builds;

*/

rules

  LiftTopLevelBuildApp :
    |[ !<s> t ]| -> |[ !t; s ]|

  LiftBuildApps : 
    |[ !t ]| -> s
    where {| AddApp
	   : <sometd(LiftBuildApp)> t => t'
	   ; <repeat(once-AddApp)> |[ !t' ]| => s
	   |}

  LiftBuildApp :
    Term|[ <s> t ]| -> Term|[ x ]|
    where new => x
        ; rules( AddApp :+ s' -> |[ {x : where(<s> t => x); s'} ]| )

  LiftBuildApp :
    Term|[ <s> ]| -> Term|[ x ]|
    where new => x
        ; rules( AddApp :+ s' -> |[ {x : where(s => x); s'} ]| )

  LiftTopLevelMatchApp :
    |[ ?<s> t ]| -> |[ s; ?t ]|

  LiftMatchApps : 
    |[ ?t ]| -> s
    where {| AddApp
	   : <sometd(LiftMatchApp)> t => t'
	   ; <repeat(once-AddApp)> |[ ?t' ]| => s
	   |}

  LiftMatchApp :
    Term|[ <s> t ]| -> Term|[ x ]|
    where new => x
        ; rules( AddApp :+ s' -> |[ {x : s'; !x; !t; s} ]| )

  LiftMatchApp :
    Term|[ <s> ]| -> Term|[ x ]|
    where new => x
        ; rules( AddApp :+ s' -> |[ {x : s'; !x; s} ]| )

strategies

/*
 Rules to Strategies

	A rule corresponds to a strategy that first matches the
	left-hand side, then checks the conditions and finally builds
	the right-hand side; The left-hand side and right-hand side
	should be in basic term format, as defined by the predicate
	|bterm|;
 */

  pureterm = not(topdown(Con(id, id, id) + App(id, id)))

  buildterm = not(topdown(Con(id, id, id) + Wld))

rules

  RtoS : |[ (t1 -> t2 where s) ]| -> |[ ?t1; where(s); !t2 ]|
         where <pureterm> t1 ; <buildterm> t2

strategies // Desugaring single rules

  desugarRule = 
    rec x(try(Scope(id, x) + RtoS))
