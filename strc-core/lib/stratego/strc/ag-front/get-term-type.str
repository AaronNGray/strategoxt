module get-term-type
imports
  libstratego-lib
  libstratego-ag
  Stratego

imports
  stratego/strc/ag-front/stratego-attributes

signature
  constructors
    UnknowProd: ProdRef
    ProdSymb  : SymbRef -> ProdRef
    TermType  : ProdRef * List(String) * Option(List(TermType)) -> TermType

rules
  GetTermType: As(Var(n), t) -> TermType(p, [n | names], children)
    where <GetTermType> t => TermType(p, names, children)

  GetTermType: Tuple(l) -> TermType(UnknowProd(), [], Some(<map(GetTermType)> l))
  GetTermType: term@Op(name, l) -> type
    where
      <bagof-ProdName2Ref> name => prods
    ; where(!TermType(UnknowProd(), [], Some(<map(GetTermType)> l)) => type')
    ; < unify-prod-with-term-type => [<id>]
     <+ (map(Any2Text), id)
      ; err(|["Cannot find one unification solution for the term ", term, "."]); fail
      > (prods, type') => type

  GetTermType: term@OpInj(t, l) -> type
    where
      <get-opdecl-sorts> OpDeclInj(t) => (ls, s@<Rsymb-pd>)
    ; filter(not(get-production-name); where(Rprod-u => ls)) => prods
    ; where(!TermType(UnknowProd(), [], Some(<map(GetTermType)> l)) => type')
    ; < unify-prod-with-term-type => [<id>]
     <+ where(!ls => [])
      ; !TermType(ProdSymb(s), [], None())
     <+ (map(Any2Text), id)
      ; err(|["Cannot find one unification solution for the term ", term, "."]); fail
      > (prods, type') => type

  GetTermType: Var(n) -> TermType(UnknowProd(), [n], None())
  GetTermType: Wld() -> TermType(UnknowProd(), [], None())

  GetTermType: NoAnnoList(t) -> <GetTermType> t

  // Those are not terms !
  GetTermType: AGMatch |[ t ]| -> <GetTermType> AGMatch |[ t where id ]|
  GetTermType: AGMatch |[ t where s ]| -> (ty, s)
    where <GetTermType> t => ty

  GetTermType: AGTerm |[ ~m: m ]| -> ty
    where <GetTermType> m => (ty, s)

  GetTermType: AGTerm |[ ~m*: m ]| -> TermType(p, [], Some(term-type*))
    where
      <not([id])> m
    ; <map(GetTermType)> m
    ; where(unzip => (term-type*, s*))
    ; register-rewrite-production => p

  get-term-type =
    GetTermType
 <+ err(|"Cannot find the ''type'' of the following term: ")
  ; fail

strategies
  unify-prod-with-term-type =
    ?(prods, type@TermType(p, names, children))
  ; switch !p
      case UnknowProd(); !children => None():
        where(<foldr(![], union, Rprod-p)> prods => [s])
      ; ![TermType(ProdSymb(s), names, None())]
      case !children => None():
        ![type]
      case ![p] => prods:
        ![type]
      case ?ProdSymb(s):
        <some(Rprod-p => [s])> prods
      ; ![type]
      case UnknowProd():
        <mapconcat(
          ![TermType(<id>, names, <unify-children(|children)>)]
       <+ unify-with-injection(|type)
       <+ ![]
        )> prods
      otherwise:
        fail
    end

  unify-with-injection(|type) =
    Rprod-u => [s]
  ; <Rsymb-pd> s
  ; filter(
      where(Rprod-u => [_])
    ; where(get-production-name => "")
    )
  ; if <get-term-type-children; (?[] + ?[_, _| _])> type then
      <unify-prod-with-term-type> (<id>, type)
    else
      <unify-prod-with-term-type> (<id>, TermType(UnknowProd(), [], Some([type])))
    end

  unify-children(|children) =
    !(<Rprod-u>, <?Some(<id>)> children)
  ; zip({
      ?(s, type@TermType(p, n, c))
    ; if <ProdSymb(?s) + Rprod-p => [s]> p then
        !type
      else
        <Rsymb-pd> s => prods
      ; if !prods => []; !c => None() then
          !TermType(ProdSymb(s), n, c)
        else
          <unify-prod-with-term-type> (prods, type) => [<id>]
        end
      end
    })
  ; !Some(<id>)

strategies
  get-term-type-production =
    ?TermType(<is-production>, _, _)

  get-term-type-symbol =
    ?TermType(<id>, _, _)
  ; ( ?ProdSymb(<id>)
    + Rprod-p => [<id>]
    )
  ; is-symbol

  get-term-type-labels =
    ?TermType(_, <id>, _)

  get-term-type-children =
    ?TermType(_, _, <?Some(<id>)>)

  get-term-type-main-labels =
    ![<id> | <get-term-type-children>]
  ; map-with-index({
      ?(i, <id>)
    ; !(<dec> i, <get-term-type-labels>, <get-term-type-symbol>)
    })

rules
  TermType2AliasTerm(this): TermType(p, names@[_ | _], children)
    -> <
     dbg(|"enter TermType2AliasTerm");
     alias-identifers(| <this> TermType(p, [], children) )
   ; dbg(|"leave TermType2AliasTerm")
   > names

rules
  TermType2ChildTerm: _ -> <
      dbg(|"enter TermType2ChildTerm")
    ; fail
    >

  TermType2ChildTerm: TermType(UnknowProd(), [], _)
    -> Term |[ _ ]|

  TermType2ChildTerm: this@TermType(_, [], _)
    -> Term |[ (srt)() ]|
      where <get-term-type-symbol; SortRef2Sort> this => srt

  TermType2ChildTerm: this@TermType(_, [_| _], _)
    -> <TermType2AliasTerm(TermType2ChildTerm)> this

  TermType2ChildTerm: _ -> <
      dbg(|"fails TermType2ChildTerm")
    ; fail
    >

rules
  TermType2Term(child): _ -> <
      dbg(|"enter TermType2Term")
    ; fail
    >

  TermType2Term(child): TermType(p, [], Some(l))
    -> Term |[ (tp)(~term*: <map(child)> l) ]|
      where
        <test(get-production-name < "" + id)> p
      ; <Rprod-p => [<SortRef2Sort; !Type |[ ~srt:<id> ]|>]> p => srt
      ; <Rprod-u; map(SortRef2Sort; !Type |[ ~srt:<id> ]|)> p => srt*
      ; tp := FunType(srt*, srt)

  TermType2Term(child): TermType(p, [], Some(l))
    -> Term |[ ~id: <get-production-name; not("")> p (
                 ~term*: <map(child)> l
               )
       ]|

  TermType2Term(child): this@TermType(_, [], None())
    -> <TermType2ChildTerm> this

  TermType2Term(child): this@TermType(_, [_| _], _)
    -> <TermType2AliasTerm(TermType2Term(child))> this

  TermType2Term(child): _ -> <
      dbg(|"fails TermType2Term")
    ; fail
    >

strategies
  TermType2RootTerm =
    TermType2Term(TermType2ChildTerm)

  add-term-type-children-labels(|basename) =
    dbg(|"enter add-term-type-children-labels");
    TermType(id, id,
      None()
    + Some(map-with-index({index:
        ?(index, <id>)
      ; TermType(
          id
        , ![<conc-strings> (basename, <int-to-string> index) | <id>]
        , id
        )
      }))
    )
  ; dbg(|"leave add-term-type-children-labels")
