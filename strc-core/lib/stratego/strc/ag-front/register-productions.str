module stratego/strc/ag-front/register-production
imports
  libstratego-lib
  libstratego-ag
  Stratego

imports
  stratego/strc/ag-front/register-symbols

rules
  GetOpDeclName: OpDecl(n, _) -> n

  get-opdecl-name = GetOpDeclName

  GetTypeSorts: FunType(a, r) -> (<map(GetTypeSorts)> a, s)
    where <GetTypeSorts> r => ([], s)

  GetTypeSorts: ConstType(s) -> ([], s)

  GetOpDeclSorts: OpDecl(_, t) -> <GetTypeSorts> t
  GetOpDeclSorts: OpDeclInj(t) -> <GetTypeSorts> t

  get-opdecl-sorts =
    GetOpDeclSorts
  ; normalize-sorts-type
  ; (map(sort-2-ref), sort-2-ref)
 <+ err(|"Cannot find the ''type'' of this constructor declaration: ")
  ; fail

  normalize-sorts-type =
    (map( \ ([], s) -> s \ ), id )
 <+ err(|"Cannot normalized the ''type'': ")
  ; fail

strategies
  is-opdecl =
    OpDecl(id, id)
  + OpDeclInj(id)

  implicit-productions =
    dr-all-keys(|"Sort2Ref")
  ; mapconcat({
      ?l@ Sort |[ List(~srt: e) ]|
    ; ![|[ : ~srt: l ]|
      , |[ : ~srt: e * ~srt: l -> ~srt: l ]|
      ]
   <+ ![]
    })

  register-production =
    restore(
      ?opdecl
    ; get-opdecl-sorts => (uses, produce)
    ; new-production(| uses, produce ) => this
    ; if <get-opdecl-name> opdecl => name then
        set-production-name(|name)
      ; rules(ProdName2Ref:+ name -> this)
      ; where(<dbg(|"register production:")> (opdecl, name, this))
      else
        rules(ProdName2Ref:+ "" -> this)
      ; where(<dbg(|"register production:")> (opdecl, this))
      end
    , err(|"Cannot register the following constructor declaration as a production:")
    )

  register-productions = where(
    <union> (<implicit-productions>, <collect(is-opdecl)>)
  ; remove-all(oncetd(not-handle-sort))
  ; map(register-production)
  )

signature
  constructors
    RewriteRule: TermType * Strategy * TermType -> RewriteProperty

strategies
  register-rewrite-production =
    restore(
      try( \ AGTerm |[ t1 -> t2 ]| -> AGTerm |[ t1 -> t2 where id ]| \ )
    ; ?r@AGTerm |[ t1 -> t2 where s ]|
    ; <get-term-type> t1 => ty1
    ; <get-term-type> t2 => ty2
    ; <topdown(try(
        ?As(_, <id>) + ?OpInj(_, [<id>])
      ))> t2 => t2'
    ; switch !(ty1, ty2)
        case (get-term-type-children, get-term-type-children):
          !|[ ?t1; s; !t2' ]|
        case (get-term-type-children, id):
          !|[ ?t1; s ]|
        case (id, get-term-type-children):
          !|[ s; !t2' ]|
        otherwise:
          !s
      end => s'
    ; dbg(|"5")
    ; <get-term-type-symbol> ty1 => s1
    ; dbg(|"6")
    ; <get-term-type-symbol> ty2 => s2
    ; dbg(|"7")
    ; memo-var(id
      , new-production(| [s1, s2], s2 ) => this
      ; set-production-as-rewrite(|[RewriteRule(ty1, s', ty2)])
      ; rules(ProdName2Ref:+ (s1, s', s2) -> this)
      ; where(<dbg(|"register rewrite production:")> (r, this))
      , <ProdName2Ref> (s1, s', s2)
      )
    , err(|"Cannot register the following rewriting declaration as a production:")
    )
