module stratego/strc/ag-front/stratego-attributes
imports
  libstratego-lib
  libstratego-ag
  Stratego

imports
  stratego/strc/ag-front/basic-stratego-templates

signature
  constructors
        : AttributeType -> AttrProperty
    Type: AttributeKind * Int * Int -> AttributeType

    Term: AttributeKind
    Stra: AttributeKind

strategies
  merge-attribute-type(|t) =
    edit-attribute-properties(
      one-or-add(?Type(_, _, _) => type | t)
    ; where(type := t)
    )

  get-attribute-type =
    get-attribute-properties
  ; fetch-elem(?Type(_, _, _))

  is-term-attribute =
    where(get-attribute-type => Type(Term(), _, _))

  is-stra-attribute =
    where(get-attribute-type => Type(Stra(), _, _))

strategies
  xor(s1, s2) =
    test(s1) < test(s2) + test(not(s2))

  find-or-create-attribute(is-local, is-produced | name, type) =
    ?symb
  ; restore(
      Rsymb-od
    ; one-or-add(
        test(get-attribute-name => name)
      ; xor(is-local, is-attribute-local) => this
      ; dbg(|"Found a similar attribute.")

      , new-attribute(| symb )
      ; set-attribute-name(| name )
      ; if is-local then set-attribute-as-local end
      ; set-attribute-flags(is-produced)
      ; set-attribute-strategy => this
      ; dbg(|"Create a new attribute.")
      )
    ; !this
    , err(|[
        "Cannot create or merge the attribute named ", name
      , " on the sort ", <Any2Text> symb
      ])
    )
  ; restore(merge-attribute-type(| type )
    , <err(|[
        "Cannot merge types for the attribute named ", name
      , " on the sort ", <Any2Text> symb
      ])> (<get-attribute-type <+ !"no-type">, type)
    )

signature
  constructors
    : String -> TopDownIdentifier
    : String -> BottomUpIdentifier
    : String -> LeftToRightIdentifier

strategies
  /**
   * Add flags on attributes to specify to propagate this attributes
   * if it is needed.
   *
   * @type is-produced  _ -> _
   * @type              AttrRef -> AttrRef
   */
  set-attribute-flags(is-produced) =
    switch get-attribute-name
      case test(PropPath => TD() + td-match-name) => td-id:
        add-attribute-td-flag(|td-id)
      case test(PropPath => BU() + bu-match-name) => bu-id:
        add-attribute-bu-flag(|bu-id)
      case (lr-is-name-syn + lr-is-name-inh); where(PropPath => LR() + lr-match-name) => lr-id:
        add-attribute-lr-flag(is-produced | lr-id)
      case PropPath => DefaultValue:
        add-attribute-default-value-flag
      otherwise:
        id
    end

signature
  constructors
    PropStra: Strategy -> AttrProperty

strategies
  /**
   * Add the strategy used to propagate value as property of the attribute.
   *
   * @type              AttrRef -> AttrRef
   */
  set-attribute-strategy =
    if get-attribute-name; PropStra => s then
      edit-attribute-properties(
        one-or-add(PropStra(!s) | PropStra(|[ fail ]|))
      )
    end

  get-attribute-strategy =
    get-attribute-properties
  ; fetch-elem(?PropStra(<id>))

strategies
  /** Copy the attribute on the symbol specified as input.
   *
   * @type              AttrKey * ProdRef * SymbLabel -> EmbeddedLanguage
   */
  copy-attribute-on =
    ?(key, prod, lbl)
  ; <get-attrkey-attrref> key => attr
  ; where(<guess-attribute-name> (attr, lbl) => name)
  ; !LabeledId(<guess-label-sym-name> lbl, name)


  /** Generate a name from an attribute and the label that specify the
   * target symbol
   *
   * @type              AttrRef * SymbLabel -> String
   */
  guess-attribute-name =
    (where(get-lr-attribute-id => basename), ?lbl)
  ; <lr-add-suffix(<is-produced-label> lbl)> basename

  /** @idem */
  guess-attribute-name =
    (where(get-bu-attribute-id => name), id)
  ; !name

  /** @idem */
  guess-attribute-name =
    (where(get-td-attribute-id => name), id)
  ; !name 

  // look at: generate-production-labels
  guess-label-sym-name =
    \ Label(0) -> Root() \
 <+ \ Label(i) -> TermLabel(i) \ // hum ..., strange StrategoId

strategies
  /** Fetch the attribute produced by this code.
   *
   * @type              ProdRef * EmbeddedLanguage -> AttrKey
   */
  fetch-produce =
    ?(_, ADefTerm(ADefT(<is-attrkey>, _, _), _))
  + ?(_, ADefStrategy(ADefT(<is-attrkey>, _, _), _))

  /** Fetch the attributes used by this code.
   *
   * @type              ProdRef * EmbeddedLanguage -> List(AttrKey)
   */
  fetch-uses =
    ?(_, ADefTerm(_, <collect(is-attrkey)>))
  + ?(_, ADefStrategy(_, <collect(is-attrkey)>))

strategies
  suffix-int(|name) =
    <conc-strings> (name, <int-to-string>)

  // If you change the name of the arguments, report to "merge-code" comment.
  generate-stratego-attribute-def(to-labeledid) =
    ?(<id>, body)
  ; where(get-attrkey-attrref; get-attribute-type => Type(k, ls, lt))
  ; !ADefT(<to-labeledid>
     , <range; map(!Typedid |[ ~id: <suffix-int(|"arg's")> ]|)> ls
     , <range; map(!Typedid |[ ~id: <suffix-int(|"arg't")> ]|)> lt
     )
  ; if !k => Term() then
      !ADefTerm(<id>, body)
    else
      !ADefStrategy(<id>, body)
    end

  // generate the same arguments as generate-stratego-attribute-def
  generate-stratego-attribute-call(to-labeledid) =
    where(get-attrkey-attrref; get-attribute-type => Type(k, ls, lt))
  ; !ACallT(<to-labeledid>
     , <range; map(!Strat |[ ~id: <suffix-int(|"arg's")> ]|)> ls
     , <range; map(!Term  |[ ~id: <suffix-int(|"arg't")> ]|)> lt
     )
  ; if !k => Term() then
      !ACallTerm(<id>)
    else
      !ACallStrategy(<id>)
    end

  /**
   * @type create-rule          ProdRef * AttrKey * List(SymbLabel) -> EmbeddedLanguage
   */
  create-strategy = debug-area(
    ?(prod, target, sources)
  ; <map({lbl: ?lbl
    ; <generate-stratego-attribute-call(
        <copy-attribute-on> (target, prod, lbl)
      )> target
    })> sources
  ; if <get-attrkey-attrref; is-term-attribute> target then
      if <get-attrkey-attrref; get-attribute-strategy> target => s then
        concat-terms(|s)
      ; try(\ Term |[ <fail> [~term*:_] ]| -> Term |[ <fail> ]| \)
      else
        concat-terms // should offer the possibility to change that
      end
    else
      if <get-attrkey-attrref; get-attribute-strategy> target => s then
        warn-msg(|"Propagation strategy are not handle in the case of strategy attribute.")
      ; warn-msg(|"Use default propagation strategy.")
      end
    ; create-choice-with-backtracking // bis
    end
  ; <generate-stratego-attribute-def(!target)> (target, <id>)
  ; dbg(|"Rule = ")
  | "create-strategy")

strategies
  /** Merge two semantic rules.
   * Also used to report useless written code when there is no merging involved.
   *
   * Caution: expect that RenameAttributeArgs and
   * generate-stratego-attribute-def are generating the same name of
   * arguments.
   *
   * @type      ProdRef * RuleRef * EmbeddedLanguage -> EmbeddedLanguage
   */
  merge-code = debug-area(
    ?(_, this, code)
  ; <get-rule-code> this
  ; dbg(|"Original code =")
  ; ( ADefTerm(id,
        where(!code => ADefTerm(_, t))
      ; sometd( \ Term |[ default ]| -> t \ )
      )
    + ADefStrategy(id,
        where(!code => ADefStrategy(_, s))
      ; sometd( \ Strat |[ default ]| -> s \ )
      )
    )
  ; dbg(|"Merged code =")
  | "merge-code")

strategies
  add-end-case(|c, s) =
    ?|[ switch id sc* otherwise: s' end ]|
  ; <at-end(![Case |[ case ~strat: c: s ]|])> sc* => sc'*
  ; !|[ switch id sc'* otherwise: s' end ]|

  replace-default-case(|s', s) =
    ?|[ switch id sc* otherwise: s' end ]|
  ; !|[ switch id sc* otherwise: s  end ]|
 <+ err(|"Cannot add multiple semantic rules without conditions.")
  ; fail

  edit-semantic-rule-code(edit) =
    ?this
  ; get-rule-code
  ; ( ?AttrDef |[ ~lid: d := <~strat: <id>> ]|
    ; edit
    ; !AttrDef |[ ~lid: d := <~strat: <id>> ]|
    + ?AttrDef |[ ~lid: d = ~strat: <id> ]|
    ; edit
    ; !AttrDef |[ ~lid: d = ~strat: <id> ]|
    ) => code
  ; <modify-rule(fetch-uses | code)> this


  // "id; .." are used to specify that the user have bound the default value,
  // otherwise it would have been removed by "remove-unbound-default-calls".
  merge-with-default-rule =
    ?(<id>, AttrDef |[ ~lid: _ := t ]|)
  ; edit-semantic-rule-code(
      replace-default-case(|Strat |[ !default ]|, |[ id; !t ]|)
    )

  merge-with-default-rule =
    ?(<id>, AttrDef |[ ~lid: _ = s ]|)
  ; edit-semantic-rule-code(
      replace-default-case(|Strat |[ default ]|, |[ id; s ]|)
    )

  merge-with-conditional-rule =
    ?(<id>, c, AttrDef |[ ~lid: _ := t ]|)
  ; edit-semantic-rule-code(
      add-end-case(| c, |[ !t ]| )
    )

  merge-with-conditional-rule =
    ?(<id>, c, AttrDef |[ ~lid: _ = s ]|)
  ; edit-semantic-rule-code(
      add-end-case(| c, s )
    )

  new-default-rule =
    ?(<id>, prod)
  ; ( ?AttrDef |[ ~lid: d := t ]|
    ; !AttrDef |[ ~lid: d := <switch id otherwise: !default end> ]|
    + ?AttrDef |[ ~lid: d = s ]|
    ; !AttrDef |[ ~lid: d = switch id otherwise: default end ]|
    ) => code
  ; new-rule(fetch-produce, fetch-uses | code, prod)

  // TODO:
  // try to find if one condition is less important compare to another
  // retrieve the information by looking inside the attributes code.
  remove-unbound-default-calls =
    edit-semantic-rule-code(
      try(\ |[ switch id sc* otherwise: !default end ]|
         -> |[ switch id sc* end ]| \
        + \ |[ switch id sc* otherwise: default end ]|
         -> |[ switch id sc* end ]| \)
    ; try(\ |[ switch id case s1: s2 end ]|
         -> |[ where(s1); s2 ]| \
        + \ |[ switch id otherwise: id; s end ]|
         -> |[ s ]| \)
    )

strategies
  is-stratego-attribute = LabeledId(id, id)
  is-stratego-attribute-local = LabeledId(Local(), id)

  find-attribute-index-and-symbol(| labels ) =
    ( Root() + Local() )
  ; <?[<id> | _]> labels
 <+ ?TermLabel(name)
  ; <fetch-elem( (id, one(?name), id) )> labels
 <+ if ?TermLabel(name) then
      err-msg(|["Label identifier \"",name , "\" not bound."])
    else
      err-msg(|["Label \"",<id> , "\" not bound."])
    end
  ; fail


  stratego-attribute-2-attrkey(is-produced | type, labels ) =
    ?attr@LabeledId(<id>, name)
  ; find-attribute-index-and-symbol(| labels ) => (index, _, on)
  ; <find-or-create-attribute(
      <is-stratego-attribute-local> attr
    , is-produced
    | name
    , type
    )> on => this
  ; create-key(| Label(index), this )
  ; where(<dbg(|"register attribute:")> (name, <id>))
 <+ is-attrkey
 <+ err(|"Cannot convert the following attribute to an AttrKey: ")
  ; rules(ERROR := 1)
  ; fail

  escape-stratego-attributes(|labels) = {|ERROR:
    edit-stratego-attributes(stratego-attribute-2-attrkey | labels)
  ; not(ERROR)
  |}

  // look at: guess-label-sym-name
  generate-production-labels =
    ?prod
  ; Rprod-u
  ; map-with-index( \ (i, <id>) -> (i, [i], <id>) \ )
  ; ![(0, [], <Rprod-p => [<id>]> prod) | <id>]

  create-strategy-attr =
    ?(prod, <id>)
  ; escape-stratego-attributes(|<generate-production-labels> prod)

strategies
  edit-stratego-attribute-call(s | kind, labels) =
    ACallT(id, where(length => ls), where(length => lt))
  ; ACallT(s(false | Type(kind, ls, lt), labels ), id, id)

  edit-stratego-attribute-def(s | kind, labels) =
    ADefT(id, where(length => ls), where(length => lt))
  ; ADefT(s(true | Type(kind, ls, lt), labels ), id, id)

  edit-stratego-attributes(s | labels) =
    topdown(try(
      ACallTerm(edit-stratego-attribute-call(s | Term(), labels))
    + ACallStrategy(edit-stratego-attribute-call(s | Stra(), labels))
    + ADefTerm(edit-stratego-attribute-def(s | Term(), labels), id)
    + ADefStrategy(edit-stratego-attribute-def(s | Stra(), labels), id)
    ))

strategies
  is-rewrite-production = fail

  attribute-propagator(|attr, symb, label) =
    ?(prod, _)
  ; if not(<is-rewrite-production> prod) then
      lr-propagation(create-strategy, create-strategy-attr, fetch-produce, fetch-uses, merge-code | attr, symb, label)
    + bu-propagation(create-strategy, create-strategy-attr, fetch-produce, fetch-uses, merge-code | attr, symb, label)
    + td-propagation(create-strategy, create-strategy-attr, fetch-produce, fetch-uses, merge-code | attr, symb, label)
    + default-propagation(create-strategy, create-strategy-attr, fetch-produce, fetch-uses, merge-code | attr, symb, label)
    else
      fail
    end
