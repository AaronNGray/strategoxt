module desugar-matched-terms
imports
  libstratego-lib
  libstratego-ag // should not appear here
  Stratego

imports
  stratego/strc/ag-front/get-term-type

// desugar-matched-variables is required to ensure that the term is correct.
/*
  @ Node(Node(l, _), Node(_, r)):
    where s
    r.env(|) := l.env(|)

is desugared to:

  @ Node(symb1, symb2):
    where s
    // the user code stay on this production
    symb2.tmp1(|) := symb1.tmp0(|)

    // spread the condition
    symb2.tmp1_cond(|) := []

  @ Node(l, _): // no conditions because no user attribute are defined
    root.tmp0(|) := l.env(|)

  @ Node(_, r): // a condition because one user attribute is defined
    where !root.tmp1_cond(|)
    r.env(|) := root.tmp1(|)

  propagation
    tmp0: default-value
    tmp0 = fail

    tmp1: default-value
    tmp1 = fail

    tmp1_cond: default-value
    tmp1_cond = fail
*/
rules
  ReplaceMatchedTerm(|agt):
    |[ @ ~_: ~*defs ]| -> |[ @ ~agt: ~*defs ]|

  ReplaceMatchedTerm(|agt):
    |[ @ ~_: where s ~*defs ]| -> |[ @ ~agt: where s ~*defs ]|

  AddSRCondition(|s):
    |[ @ ~agt: ~*defs ]| -> |[ @ ~agt: where s ~*defs ]|

  AddSRCondition(|s):
    |[ @ ~agt: where s' ~*defs ]| -> |[ @ ~agt: where s; s' ~*defs ]|

  AddAttrDef(|other-defs):
    |[ @ ~agt: ~*defs ]| -> |[ @ ~agt: ~*defs ~*other-defs ]|

  AddAttrDef(|other-defs):
    |[ @ ~agt: where s ~*defs ]| -> |[ @ ~agt: where s ~*defs ~*other-defs ]|

rules
  remove-injections =
    bottomup(try(
      \ OpInj(ConstType(_), []) -> Wld() \
    + \ OpInj(_, l) -> Tuple(l) \
    ; try(\ Tuple([e]) -> e \)
    ))

  agterm-to-term =
    remove-injections

  match-2-build =
    topdown(try(
      \ As(_, t) -> t \
    ))
  ; not(oncetd(?Wld()))
 <+ err(|"Cannot convert he follwing to a build pattern:")
  ; fail

rules
  TermType2AGMatch: t -> AGMatch |[ t' ]|
    where
    dbg(|"enter TermType2AGMatch");
 t' := <TermType2RootTerm> t
    ; dbg(|"leave TermType2AGMatch")

  TermType2AGTerm: t -> AGTerm |[ ~m: m ]|
    where
      !t
    ; dbg(|"enter TermType2AGTerm")
    ; not(
        get-term-type-production
      ; is-production-rewrite
      )
    ; add-term-type-children-labels(|"'symb")
    ; TermType2AGMatch => m
    ; dbg(|"leave TermType2AGTerm")

  TermType2AGTerm: t -> AGTerm |[ ~m*: m* ]|
    where
      !t
    ; where(
        get-term-type-production
      ; is-production-rewrite
      )
    ; add-term-type-children-labels(|"'symb")
    ; get-term-type-children
    ; map(TermType2AGMatch) => m*

strategies
  // fixme: to make variable accessible from any other attribute we have
  // to put the stack in the heap to handle a correct delay call with
  // references to outerscope variables.
  replace-precondition =
    (try(\ AGMatch |[ t1 ]| -> AGMatch |[ t1 where id ]| \), id)
  ; ?(AGMatch |[ t1 where s ]| , n@(sr, s', t, _))
  ; <agterm-to-term> t1 => t'
  ; <match-2-build> t' => t''
  ; <newname> "matched" => f
//  ; <(AddAttrDef(|[
//        |[ local.f(|) := <s'; \ t -> t'' where s \> ]|
//      ])
//    , !|[ !local.f(|) ]|
  ; <(\ |[ @ ~sr : ~*defs ]| -> |[ @ ~sr : ]| \
    , !|[ id ]|
    , !t'
    , at-end(![|[\ t -> t'' where s \ ]|])
    )> n

  initial-precondition(|type) =
    try(\ AGMatch |[ t ]| -> AGMatch |[ t where id ]| \)
  ; ?AGMatch |[ t where s ]|
  ; <agterm-to-term> t => t'
  ; <newname> "matched" => f
  ; !(|[@ ~<TermType2AGTerm> type:
          local.f(|) := <where(s); ?t'>
      ]|
    , |[ !local.f(|) ]|
    , t'
    , [|[ where(s); ?t' ]|]
    )

  // fixme: the traversal should be done here !!
  // to do so we need to access variable of the outer-scope of the delay call definition.
  matched-term-attribute =
    ?(agterm, type)
  ; <?AGTerm |[ ~m*: <id> ]|> agterm
  ; <foldl(replace-precondition)> (
      <Tl>
    , <Hd; initial-precondition(|type)>
    ) => (sr, last, _, ls)
  ; if <get-term-type-production> type => p; is-production-rewrite then
      <set-production-as-rewrite(|
        // fixme: many rewrite with the same type and different conditions.
        ls
      )> p
    end
  ; !(sr, last)
 <+ err(|"Cannot generate the condition to match the current term.")
  ; fail

strategies
  find-labels-in-term-type(| term-index, term-type ) =
    <elem> (<?TermLabel(<id>)>, <get-term-type-labels> term-type)
  ; ![(term-index, term-type)]
 <+ ?lbl
  ; ![(term-index, term-type)
    | < get-term-type-children
      ; add-indices
      ; fetch-elem({child-index, child-type:
          ?(child-index, child-type)
        ; <find-labels-in-term-type(| child-index, child-type )> lbl
        })
      > term-type
    ]

  find-labels-in-term-type(| term-type ) =
    ( Root() + Local() )
  ; ![(1, term-type)]
 <+ find-labels-in-term-type(| 1, term-type )
 <+ ?lbl; !term-type
  ; err(|["Identifier \"",lbl , "\" not bound in an attribute section."])
  ; fail

strategies
  rename-with-child-index(|i) =
    LabeledId(!TermLabel(<conc-strings> ("'symb", <int-to-string> i)), id)

  handle-condition-attributes =
    list-loop({ca:
      if ?(ca, Type(Term(), 0, 0), 0, 1) then
        rules(ConditionAttrDefinitions :+= |[ ~li: ca (|) := [] ]|)
      end
    })

  register-inner-term-copy-rules(is-produced | term-type, child-index, cond-attr) =
    unzip({child-attr, type, user, cond, n', ca, ra:
      ?(child-attr, type, user, cond)
    ; where(<newname> "tmp" => n')
    ; <rename-with-child-index(|child-index)> child-attr => ca
    ; !LabeledId(Root(), n') => ra
    ; split(
        !(ra, type, user, cond)
      , if is-produced then
          <create-copy-rule> (ca, ra, type)
        else
          <create-copy-rule> (ra, ca, type)
        end
      )
    }) => (al', attrdefs)
  ; !attrdefs
  ; if !cond-attr => Some(c) then
      dbg(|"Create rules with condition:");
      list-loop(
        rules(AttrDefinitions :+= |[
          @ ~<Snd; TermType2AGTerm> term-type :
            where !root.c (|) => []
            ~ <id>
        ]|)
      )
    ; ![(LabeledId(Root(), c), Type(Term(), 0, 0), 0, 1) | al']
    else
      dbg(|"Create rules without condition:");
      list-loop(
        rules(AttrDefinitions :+= |[
          @ ~<Snd; TermType2AGTerm> term-type :
            ~ <id>
        ]|)
      )
    ; !al'
    end => al
  ; list-loop({
      ?(LabeledId(_, x), _, _, _)
    ; rules(AttrDefinitions :+= |[
        @ default-value x = fail
      ]|)
    })

  create-inner-term-copy-rules(is-produced | root) =
    \ (t, (al, tl@[(i, _)|_])) -> (al', [t | tl])
      where
        ![t | tl] => root
      ; dbg(|"Is root.")
      ; <if !root => [_,_,_|_] then
          map( (rename-with-child-index(|i), id, id, id) )
        end> al => al'
    \

  create-inner-term-copy-rules(is-produced | root) =
    ?(t, (<id>, tl@[(i, _)| _]))
  ; where(not(![t | tl] => root))
  ; dbg(|"Not root.")
  ; register-inner-term-copy-rules(is-produced | t, i, <
      !None()
    ; if is-produced; !tl => [_] then
        !Some(<newname> "tmp")
      end
    ; dbg(|"Condition attribute:")
    >)
  ; !(<id>, [t | tl])

  create-inner-term-copy-rules(is-produced | root) =
    \ (t, (al, [])) -> (al, [t]) \

  alias-attribute(is-produced | type, term-type) =
    ?attr@LabeledId(lbl, name)
  ; <find-labels-in-term-type(| term-type )> lbl => traversal
  ; where(id => root)
  ; where(Tl; Hd => (child-index, _))
  ; foldr(
      !([(attr, type, 1, 0)], [])
    , create-inner-term-copy-rules(is-produced | root)
    ) => (<id>, _)
  ; handle-condition-attributes
  ; fetch-elem(?(<id>, type, 1, 0))

  alias-attributes(|term-type) =
    edit-stratego-attributes(alias-attribute | term-type)
 <+ err(|"Cannot alias attributes.")
  ; fail

strategies
  desugar-matched-term = {|AttrDefinitions, ConditionAttrDefinitions:
    ?sr
  ; (?|[ @~<id>: where ~_ ~*_ ]| + ?|[ @~<id>: ~*_ ]|) => agt
  ; <get-term-type> agt => type
  ; if <get-term-type-children; one(get-term-type-children)> type then
      <matched-term-attribute> (agt, type) => (match, cond)
    ; <?|[ @~<id>: ~*_ ]|> match => root-agt
    ; <alias-attributes(|type)> sr
    ; ReplaceMatchedTerm(|root-agt)
    ; AddAttrDef(|<bagof-ConditionAttrDefinitions>)
    ; AddSRCondition(|cond)
    ; ![match, <id> | <bagof-AttrDefinitions>]
    ; dbg(|"All desugared rules by desugar-matched-term:")
   <+ err(|"Cannot desugar the matched term of")
    ; fail
    else
      ![sr]
    end
  |}

  desugar-matched-terms =
    memo-scope(
      mapconcat(
        { ?|[ @ ~path x ]| + ?|[ @ ~path x = s ]| }
      ; ![<id>]
     <+ desugar-matched-term
      )
    )
