/**
 * Java output postprocessing.
 *
 * Performs essential Java-to-Java transformations.
 *
 * @author Lennart Kats
 */
module java-postprocess

imports
  libjava-front

overlays

  /**
   * Minimum number of statements in an init method required to split it up,
   * in order to circumvent the 64K method size limit.
   */
  LARGE_METHOD_SIZE = 600

strategies

  java-relabel =
    java-relabel(|"NO_FAIL_LABEL", "NO_SUCCESS_LABEL", "NO_OUTER_LABEL")

  java-relabel(|failure, success, outer-fail) =
    java-relabel-outer-label(|failure, success, outer-fail)
  <+
    java-relabel-success-label(|failure, success, outer-fail)
  <+
    java-relabel-stm(|failure, success, outer-fail)
  <+
    all(java-relabel(|failure, success, outer-fail))
  
  java-relabel-stm(|failure, success, outer-fail) :
    |[ Fail: { bstm* } ]| -> |[ x_label': { bstm'* } ]|
    with
      x_label' := <newname> "Fail"
    ; bstm'*   := <java-relabel(|x_label', success, failure)> bstm*
  
  java-relabel-success-label(|failure, success, outer-fail) :
    |[ Success: { bstm* } ]| -> bstm |[ x_label': { bstm'* } ]|
    with
      x_label' := <newname> "Success"
    ; bstm'*   := <java-relabel(|failure, x_label', outer-fail)> bstm*
   
  java-relabel-outer-label(|failure, success, outer-fail) :
    |[ OuterFail: { bstm* } ]| -> bstm |[ { bstm'* } ]|
    with
      bstm'* := <java-relabel(|outer-fail, success, outer-fail)> bstm*
  
   java-relabel-stm(|failure, success, outer-fail) :
     Id("Fail") -> Id(failure)
   
   java-relabel-stm(|failure, success, outer-fail) :
     Id("Success") -> Id(success)
   
   java-relabel-stm(|failure, success, outer-fail) :
     Id("OuterFail") -> Id(outer-fail)

strategies

  java-split-method =
    try(java-split-method' <+ ![<id>])

  java-split-method' :
    class-body-dec |[
      mod* t x(param*) {
        bstm*
      }
    ]| ->
    class-body-dec* |[ 
      ~*<java-split-method> |[
        mod* t x(param*) {
          x'(e_param*);
          bstm2*
        }
      ]|

      mod2* t x'(param*) {
        bstm1*
      }
    ]|
    where
      <gt> (<length> bstm*, LARGE_METHOD_SIZE())
    with
      x'               := <newname> x
    ; e_param*         := <map(java-param-to-arg)> param*
    ; mod2*            := <map(try(\<Public + Protected> -> Private()\))> mod*
    ; (bstm1*, bstm2*) := <split-at(|LARGE_METHOD_SIZE())> bstm*

  java-param-to-arg :
    param |[ t x ]| -> expr |[ x ]|

strategies

  java-split-class :
    compilation-unit |[
      ~package-dec?:pkgname
      ~import-dec*:imports
      mod* class x {
        ~*members
      }
    ]| ->
    [ compilation-unit |[
        ~package-dec?:pkgname
        ~import-dec*:imports
        mod* class x {
          ~*members'
        }
      ]| 
    | member-classes
    ]
    with
      (member-classes, members') := <partition(to-compilation-unit(|pkgname, imports, mod*))> members

  to-compilation-unit(|pkgname, imports, mod*) :
    type-dec |[
      mod2* class x extends y {
        ~*members
      }
    ]| ->
    compilation-unit |[
      ~package-dec?: pkgname
      ~import-dec*: imports
      mod* class x extends y {
        ~*members
      }
    ]|
