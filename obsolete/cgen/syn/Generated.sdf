module Generated
exports
  sorts TranslationUnit

  context-free syntax
    INTEGERconstant   -> Constant {cons("IntConst")}
    FLOATINGconstant  -> Constant {cons("FloatConst")}
    OCTALconstant     -> Constant {cons("OctConst")}
    HEXconstant       -> Constant {cons("HexConst")}
    CHARACTERconstant -> Constant {cons("CharConst")}

  context-free syntax
    STRINGliteral+ -> StringLiteralList

  context-free syntax
    IDENTIFIER              -> PrimaryExpression {cons("Id")}
    Constant                -> PrimaryExpression
    StringLiteralList       -> PrimaryExpression {cons("StringLit")}
    "(" CommaExpression ")" -> PrimaryExpression {bracket}

  context-free syntax
    PrimaryExpression                                -> PostfixExpression
    PostfixExpression "[" CommaExpression "]"        -> PostfixExpression {cons("ArrayIndex")}
    PostfixExpression "(" ArgumentExpressionList ")" -> PostfixExpression {cons("FunCall")}
    PostfixExpression "." MemberName                 -> PostfixExpression {cons("Field")}
    PostfixExpression "->" MemberName                -> PostfixExpression {cons("DerefMember")}
    PostfixExpression "++"                           -> PostfixExpression {cons("PostIncr")}
    PostfixExpression "--"                           -> PostfixExpression {cons("PostDecr")}

  context-free syntax
    IDENTIFIER  -> MemberName {cons("Id")}
    TypedefName -> MemberName

  context-free syntax
    {AssignmentExpression ","}* -> ArgumentExpressionList

  context-free syntax
    PostfixExpression            -> UnaryExpression
    "++" UnaryExpression         -> UnaryExpression {cons("PreIncr")}
    "--" UnaryExpression         -> UnaryExpression {cons("PreDecr")}
    "sizeof" UnaryExpression     -> UnaryExpression {cons("SizeofExp")}
    "sizeof" "(" TypeName ")"    -> UnaryExpression {cons("SizeofType")}

    "&" CastExpression -> UnaryExpression {cons("Address")}
    "*" CastExpression -> UnaryExpression {cons("Deref")}
    "+" CastExpression -> UnaryExpression {cons("Positive")}
    "-" CastExpression -> UnaryExpression {cons("Negative")}
    "~" CastExpression -> UnaryExpression {cons("Tilde")}
    "!" CastExpression -> UnaryExpression {cons("Negation")}

  context-free syntax
    UnaryExpression                 -> CastExpression
    "(" TypeName ")" CastExpression -> CastExpression {cons("TypeCast")}

  context-free syntax
    CastExpression                              -> MultiplicativeExpression
    MultiplicativeExpression "*" CastExpression -> MultiplicativeExpression {cons("Mul")}
    MultiplicativeExpression "/" CastExpression -> MultiplicativeExpression {cons("Div")}
    MultiplicativeExpression "%" CastExpression -> MultiplicativeExpression {cons("Mod")}

  context-free syntax
    MultiplicativeExpression                        -> AdditiveExpression
    AdditiveExpression "+" MultiplicativeExpression -> AdditiveExpression {cons("Add")}
    AdditiveExpression "-" MultiplicativeExpression -> AdditiveExpression {cons("Subt")}

  context-free syntax
    AdditiveExpression                      -> ShiftExpression
    ShiftExpression "<<" AdditiveExpression -> ShiftExpression {cons("ShiftLeft")}
    ShiftExpression ">>" AdditiveExpression -> ShiftExpression {cons("ShiftRight")}

  context-free syntax
    ShiftExpression                           -> RelationalExpression
    RelationalExpression "<" ShiftExpression  -> RelationalExpression {cons("Lt")}
    RelationalExpression ">" ShiftExpression  -> RelationalExpression {cons("Gt")}
    RelationalExpression "<=" ShiftExpression -> RelationalExpression {cons("Le")}
    RelationalExpression ">=" ShiftExpression -> RelationalExpression {cons("Ge")}

  context-free syntax
    RelationalExpression                         -> EqualityExpression
    EqualityExpression "==" RelationalExpression -> EqualityExpression {cons("Equal")}
    EqualityExpression "!=" RelationalExpression -> EqualityExpression {cons("NotEqual")}

  context-free syntax
    EqualityExpression                   -> ANDexpression
    EqualityExpression "&" ANDexpression -> ANDexpression {cons("And")}

  context-free syntax
    ANDexpression                           -> ExclusiveORExpression
    ANDexpression "^" ExclusiveORExpression -> ExclusiveORExpression {cons("ExOr")}

  context-free syntax
    ExclusiveORExpression                           -> InclusiveORExpression
    ExclusiveORExpression "|" InclusiveORExpression -> InclusiveORExpression {cons("IncOr")}

  context-free syntax
    InclusiveORExpression                           -> LogicalANDExpression
    LogicalANDExpression "&&" InclusiveORExpression -> LogicalANDExpression {cons("LAnd")}

  context-free syntax
    LogicalANDExpression                          -> LogicalORExpression
    LogicalORExpression "||" LogicalANDExpression -> LogicalORExpression {cons("LOr")}

  context-free syntax
    LogicalORExpression                                               -> ConditionalExpression
    LogicalORExpression "?" CommaExpression ":" ConditionalExpression -> ConditionalExpression {cons("IfExp")}

  context-free syntax
    ConditionalExpression                                   -> AssignmentExpression
    UnaryExpression AssignmentOperator AssignmentExpression -> AssignmentExpression {cons("Assign")}

  context-free syntax
    "="   -> AssignmentOperator {cons("AssignEq")}
    "*="  -> AssignmentOperator {cons("AssignMul")}
    "/="  -> AssignmentOperator {cons("AssignDiv")}
    "%="  -> AssignmentOperator {cons("AssignMod")}
    "+="  -> AssignmentOperator {cons("AssignPlus")}
    "-="  -> AssignmentOperator {cons("AssignMin")}
    "<<=" -> AssignmentOperator {cons("AssignSL")}
    ">>=" -> AssignmentOperator {cons("AssignSR")}
    "&="  -> AssignmentOperator {cons("AssignAnd")}
    "^="  -> AssignmentOperator {cons("AssignExp")}
    "|="  -> AssignmentOperator {cons("AssignOr")}

  context-free syntax
    {AssignmentExpression ","}+ -> CommaExpression {cons("Exp")}

  context-free syntax
    ConditionalExpression -> ConstantExpression

  context-free syntax
    {AssignmentExpression ","}* -> CommaExpressionOpt {cons("Exp")}

  context-free syntax
    SueDeclarationSpecifier ";" -> Declaration {cons("Declaration1")}
    SueTypeSpecifier ";"        -> Declaration {cons("Declaration2")}
    DeclaringList ";"           -> Declaration {cons("Declaration3")}
    DefaultDeclaringList ";"    -> Declaration {cons("Declaration4")}

  context-free syntax
    DeclarationQualifierList 	IdentifierDeclarator InitializerOpt? -> DefaultDeclaringList {cons("DefDeclList1")}
    TypeQualifierList 		IdentifierDeclarator InitializerOpt? -> DefaultDeclaringList {cons("DefDeclList2")}
    DefaultDeclaringList "," 	IdentifierDeclarator InitializerOpt? -> DefaultDeclaringList {cons("DefDeclList3")}

  context-free syntax
    DeclarationSpecifier Declarator InitializerOpt? -> DeclaringList {cons("DeclList1")}
    TypeSpecifier 	 Declarator InitializerOpt? -> DeclaringList {cons("DeclList2")}
    DeclaringList "," 	 Declarator InitializerOpt? -> DeclaringList {cons("DeclList3")}

  context-free syntax
    BasicDeclarationSpecifier   -> DeclarationSpecifier
    SueDeclarationSpecifier     -> DeclarationSpecifier
    TypedefDeclarationSpecifier -> DeclarationSpecifier

  context-free syntax
    BasicTypeSpecifier   -> TypeSpecifier
    SueTypeSpecifier     -> TypeSpecifier
    TypedefTypeSpecifier -> TypeSpecifier

  context-free syntax
    StorageClass                                  -> DeclarationQualifierList
    TypeQualifierList StorageClass                -> DeclarationQualifierList {cons("DecQualList1")}
    DeclarationQualifierList DeclarationQualifier -> DeclarationQualifierList {cons("DecQualList2")}

  context-free syntax
    TypeQualifier+ -> TypeQualifierList

  context-free syntax
    StorageClass  -> DeclarationQualifier
    TypeQualifier -> DeclarationQualifier

  context-free syntax
    "const"    -> TypeQualifier {cons("Const")}
    "volatile" -> TypeQualifier {cons("Volatile")}

  context-free syntax
    DeclarationQualifierList BasicTypeName         -> BasicDeclarationSpecifier {cons("DeclSpec1")}
    BasicTypeSpecifier StorageClass                -> BasicDeclarationSpecifier {cons("DeclSpec2")}
    BasicDeclarationSpecifier DeclarationQualifier -> BasicDeclarationSpecifier {cons("DeclSpec3")}
    BasicDeclarationSpecifier BasicTypeName        -> BasicDeclarationSpecifier {cons("DeclSpec4")}

  context-free syntax
    BasicTypeName                    -> BasicTypeSpecifier {cons("TypeSpec1")}
    TypeQualifierList BasicTypeName  -> BasicTypeSpecifier {cons("TypeSpec2")}
    BasicTypeSpecifier TypeQualifier -> BasicTypeSpecifier {cons("TypeSpec3")}
    BasicTypeSpecifier BasicTypeName -> BasicTypeSpecifier {cons("TypeSpec4")}

  context-free syntax
    DeclarationQualifierList ElaboratedTypeName  -> SueDeclarationSpecifier {cons("SueDeclSpec1")}
    SueTypeSpecifier StorageClass                -> SueDeclarationSpecifier {cons("SueDeclSpec2")}
    SueDeclarationSpecifier DeclarationQualifier -> SueDeclarationSpecifier {cons("SueDeclSpec3")}

  context-free syntax
    ElaboratedTypeName                   -> SueTypeSpecifier {cons("SueTypeSpec")}
    TypeQualifierList ElaboratedTypeName -> SueTypeSpecifier {cons("SueTypeSpec")}
    SueTypeSpecifier TypeQualifier       -> SueTypeSpecifier {cons("SueTypeSpec")}

  context-free syntax
    TypedefTypeSpecifier StorageClass                -> TypedefDeclarationSpecifier {cons("TypedDeclSpec1")}
    DeclarationQualifierList TypedefName             -> TypedefDeclarationSpecifier {cons("TypedDeclSpec2")}
    TypedefDeclarationSpecifier DeclarationQualifier -> TypedefDeclarationSpecifier {cons("TypedDeclSpec3")}

  context-free syntax
    TypedefName                        -> TypedefTypeSpecifier {cons("TypedTypeSpec1")}
    TypeQualifierList TypedefName      -> TypedefTypeSpecifier {cons("TypedTypeSpec2")}
    TypedefTypeSpecifier TypeQualifier -> TypedefTypeSpecifier {cons("TypedTypeSpec3")}

  context-free syntax
    "typedef"  -> StorageClass {cons("Typedef")}
    "extern"   -> StorageClass {cons("Extern")}
    "static"   -> StorageClass {cons("Static")}
    "auto"     -> StorageClass {cons("Auto")}
    "register" -> StorageClass {cons("Register")}

  context-free syntax
    "int"      -> BasicTypeName {cons("Int")}
    "char"     -> BasicTypeName {cons("Char")}
    "short"    -> BasicTypeName {cons("Short")}
    "long"     -> BasicTypeName {cons("Long")}
    "float"    -> BasicTypeName {cons("Float")}
    "double"   -> BasicTypeName {cons("Double")}
    "signed"   -> BasicTypeName {cons("Signed")}
    "unsigned" -> BasicTypeName {cons("Unsigned")}
    "void"     -> BasicTypeName {cons("Void")}

  context-free syntax
    StructSpecifier -> ElaboratedTypeName
    UnionSpecifier -> ElaboratedTypeName
    EnumSpecifier -> ElaboratedTypeName

  context-free syntax
    "struct" IdentifierOrTypedefName? "{" MemberDeclarationList "}" -> StructSpecifier {cons("Struct")}
    "struct" IdentifierOrTypedefName                                -> StructSpecifier {cons("StructId")}

  context-free syntax
    "union" IdentifierOrTypedefName? "{" MemberDeclarationList "}" -> UnionSpecifier {cons("Union")}
    "union" IdentifierOrTypedefName                                -> UnionSpecifier {cons("UnionId")}

  context-free syntax
    MemberDeclaration+ -> MemberDeclarationList

  context-free syntax
    TypeSpecifier {MemberDeclarator ","}+ ";" 		    -> MemberDeclaration {cons("MemberDeclaration")}
    TypeQualifierList {MemberIdentifierDeclarator ","}+ ";" -> MemberDeclaration {cons("MemberDeclaration")}

   %% MemberDeclaringList ";"        -> MemberDeclaration {cons("MemberDeclaration")}
   %% MemberDefaultDeclaringList ";" -> MemberDeclaration {cons("MemberDeclaration")}

  %%context-free syntax
  %%  TypeQualifierList MemberIdentifierDeclarator  -> MemberDefaultDeclaringList {cons("TypeQualifierList-MemberIdentifierDeclarator")}
  %%  MemberDefaultDeclaringList "," MemberIdentifierDeclarator -> MemberDefaultDeclaringList {cons("comma2")}

  %%context-free syntax
  %%  TypeSpecifier MemberDeclarator           -> MemberDeclaringList {cons("TypeSpecifier-MemberDeclarator")}
  %%  MemberDeclaringList "," MemberDeclarator -> MemberDeclaringList {cons("comma3")}

  context-free syntax
    Declarator BitFieldSizeOpt -> MemberDeclarator {cons("MemberDecl")}
    BitFieldSize               -> MemberDeclarator

  context-free syntax
    IdentifierDeclarator BitFieldSizeOpt -> MemberIdentifierDeclarator {cons("MemberId")}
    BitFieldSize                         -> MemberIdentifierDeclarator

  context-free syntax
    BitFieldSize? -> BitFieldSizeOpt

  context-free syntax
    ":" ConstantExpression -> BitFieldSize {cons("BitFieldSize")}

  context-free syntax
    "enum" IdentifierOrTypedefName? "{" {Enumerator ","}+ "}" -> EnumSpecifier {cons("Enum")}
    "enum" IdentifierOrTypedefName                         -> EnumSpecifier {cons("EnumId")}

  context-free syntax
    IdentifierOrTypedefName EnumeratorValue? -> Enumerator {cons("Enumerator")}


  context-free syntax
    "=" ConstantExpression -> EnumeratorValue {cons("EnumVal")}

  context-free syntax
    ParameterList           -> ParameterTypeList
    ParameterList "," "..." -> ParameterTypeList {cons("comma5")}

  context-free syntax
    {ParameterDeclaration ","}+ -> ParameterList

  context-free syntax
    (DeclarationSpecifier | TypeSpecifier)  
    (AbstractDeclarator | IdentifierDeclarator | ParameterTypedefDeclarator)?
		-> ParameterDeclaration {cons("ParamDecl")}

    (DeclarationQualifierList | TypeQualifierList)
    (AbstractDeclarator | IdentifierDeclarator)? -> ParameterDeclaration {cons("ParamDecl2")}

  context-free syntax
    {IDENTIFIER ","}+ -> IdentifierList

  context-free syntax
    IDENTIFIER  -> IdentifierOrTypedefName
    TypedefName -> IdentifierOrTypedefName

  context-free syntax
    (TypeSpecifier | TypeQualifierList) AbstractDeclarator? -> TypeName {cons("TypeName")}

  context-free syntax
    "=" Initializer -> InitializerOpt {cons("equal3")}

  context-free syntax
    "{" {Initializer ","}+ ","? "}" -> Initializer {cons("Initializer")}
    AssignmentExpression            -> Initializer

