definition
module AbstractDeclarators
exports
  context-free syntax
    "*" TypeQualifier* -> Pointer     {cons("PointerOf")}
    Pointer+           -> Pointers
    Pointer*           -> PointersOpt

  context-free syntax
    UnaryAbstractDeclarator      -> AbstractDeclarator
    PostfixAbstractDeclarator    -> AbstractDeclarator
    PostfixingAbstractDeclarator -> AbstractDeclarator

  context-free syntax
    Pointers ( PostfixAbstractDeclarator | PostfixingAbstractDeclarator )? -> UnaryAbstractDeclarator {cons("Pointer")}

  context-free syntax
    ArrayAbstractDeclarator                       -> PostfixingAbstractDeclarator
    "(" {ParameterDeclaration ","}+ "," "..." ")" -> PostfixingAbstractDeclarator {cons("ParamListVarArgs")}
    "(" {ParameterDeclaration ","}* ")"           -> PostfixingAbstractDeclarator {cons("ParamList")}

  context-free syntax
    ArrayAbstractDeclarator? "[" ConstantExpression? "]" -> ArrayAbstractDeclarator {cons("ArrayDecl")}

  context-free syntax
    "(" UnaryAbstractDeclarator ")"                              -> PostfixAbstractDeclarator {cons("DeclBracket")}
    "(" PostfixAbstractDeclarator ")"                            -> PostfixAbstractDeclarator {cons("DeclBracket")}
    "(" PostfixingAbstractDeclarator ")"                         -> PostfixAbstractDeclarator {cons("DeclBracket")}
    "(" UnaryAbstractDeclarator ")" PostfixingAbstractDeclarator -> PostfixAbstractDeclarator {cons("FunType")}

module ParameterDeclarators
exports
  context-free syntax
    ( DeclarationQualifierList | TypeQualifiers | DeclarationSpecifier | TypeSpecifier ) 
    ( AbstractDeclarator | IdentifierDeclarator ) -> ParameterDeclaration {cons("ParamDecl")}

    ( DeclarationQualifierList | TypeQualifiers | DeclarationSpecifier | TypeSpecifier ) 
     -> ParameterDeclaration

    ( DeclarationSpecifier | TypeSpecifier ) 
    TypedefDeclarator -> ParameterDeclaration {cons("ParamDeclTD")}

  context-free syntax
    ( TypeSpecifier | TypeQualifiers ) AbstractDeclarator? -> TypeName {cons("TypeName")}

module Enumerators
exports
  context-free syntax
    "enum" IdentifierOrTypedefName? "{" {Enumerator ","}+ "}" -> EnumSpecifier {cons("Enum")}
    "enum" IdentifierOrTypedefName                            -> EnumSpecifier {cons("EnumId")}

  context-free syntax
    IdentifierOrTypedefName EnumeratorValue? -> Enumerator {cons("Enumerator")}

  context-free syntax
    "=" ConstantExpression -> EnumeratorValue {cons("EnumVal")}

module StructsAndUnions
exports
  context-free syntax
    StructSpecifier -> ElaboratedTypeName
    UnionSpecifier  -> ElaboratedTypeName
    EnumSpecifier   -> ElaboratedTypeName

  context-free syntax
    "struct" IdentifierOrTypedefName? "{" MemberDeclaration+ "}" -> StructSpecifier {cons("Struct")}
    "struct" IdentifierOrTypedefName                             -> StructSpecifier {cons("StructId")}

  context-free syntax
    "union" IdentifierOrTypedefName? "{" MemberDeclaration+ "}" -> UnionSpecifier {cons("Union")}
    "union" IdentifierOrTypedefName                             -> UnionSpecifier {cons("UnionId")}

  context-free syntax
    TypeSpecifier {MemberDeclarator ","}+ ";"            -> MemberDeclaration {cons("MemDecl")}
    TypeQualifier+ {MemberIdentifierDeclarator ","}+ ";" -> MemberDeclaration {cons("MemDecl")}

  context-free syntax
    Declarator                         -> MemberDeclarator
    Declarator? ":" ConstantExpression -> MemberDeclarator {cons("BitFieldSize")}

module Expressions
exports
  context-free syntax
    INTEGERconstant   -> Constant {cons("IntConst")}
    FLOATINGconstant  -> Constant {cons("FloatConst")}
    OCTALconstant     -> Constant {cons("OctConst")}
    HEXconstant       -> Constant {cons("HexConst")}
    CHARACTERconstant -> Constant {cons("CharConst")}

  context-free syntax
    STRINGliteral+ -> StringLiteralList {cons("StringLit")}

  context-free syntax
    IDENTIFIER              -> PrimaryExpression
    Constant                -> PrimaryExpression
    StringLiteralList       -> PrimaryExpression
    "(" CommaExpression ")" -> PrimaryExpression {bracket}
 
  context-free syntax
    PrimaryExpression                                -> PostfixExpression
    PostfixExpression "[" CommaExpression "]"        -> PostfixExpression {cons("ArrayIndex")}
    PostfixExpression "(" {AssignmentExpression ","}* ")" -> PostfixExpression {cons("FunCall")}
    PostfixExpression "." MemberName                 -> PostfixExpression {cons("Field")}
    PostfixExpression "->" MemberName                -> PostfixExpression {cons("DerefMember")}
    PostfixExpression "++"                           -> PostfixExpression {cons("PostIncr")}
    PostfixExpression "--"                           -> PostfixExpression {cons("PostDecr")}

  context-free syntax
    IDENTIFIER  -> MemberName
    TypedefName -> MemberName

  context-free syntax
    PostfixExpression         -> UnaryExpression
    "++" UnaryExpression      -> UnaryExpression {cons("PreIncr")}
    "--" UnaryExpression      -> UnaryExpression {cons("PreDecr")}
    "sizeof" UnaryExpression  -> UnaryExpression {cons("SizeofExp")}
    "sizeof" "(" TypeName ")" -> UnaryExpression {cons("SizeofType")}
    "&" CastExpression        -> UnaryExpression {cons("Address")}
    "*" CastExpression        -> UnaryExpression {cons("Deref")}
    "+" CastExpression        -> UnaryExpression {cons("Positive")}
    "-" CastExpression        -> UnaryExpression {cons("Negative")}
    "~" CastExpression        -> UnaryExpression {cons("Tilde")}
    "!" CastExpression        -> UnaryExpression {cons("Negation")}

  context-free syntax
    UnaryExpression                 -> CastExpression
    "(" TypeName ")" CastExpression -> CastExpression {cons("TypeCast")}

  context-free syntax
    CastExpression                              -> MultiplicativeExpression
    MultiplicativeExpression "*" CastExpression -> MultiplicativeExpression {cons("Mul")}
    MultiplicativeExpression "/" CastExpression -> MultiplicativeExpression {cons("Div")}
    MultiplicativeExpression "%" CastExpression -> MultiplicativeExpression {cons("Mod")}

  context-free syntax
    MultiplicativeExpression                        -> AdditiveExpression
    AdditiveExpression "+" MultiplicativeExpression -> AdditiveExpression {cons("Add")}
    AdditiveExpression "-" MultiplicativeExpression -> AdditiveExpression {cons("Subt")}

  context-free syntax
    AdditiveExpression                      -> ShiftExpression
    ShiftExpression "<<" AdditiveExpression -> ShiftExpression {cons("ShiftLeft")}
    ShiftExpression ">>" AdditiveExpression -> ShiftExpression {cons("ShiftRight")}

  context-free syntax
    ShiftExpression                           -> RelationalExpression
    RelationalExpression "<" ShiftExpression  -> RelationalExpression {cons("Lt")}
    RelationalExpression ">" ShiftExpression  -> RelationalExpression {cons("Gt")}
    RelationalExpression "<=" ShiftExpression -> RelationalExpression {cons("Le")}
    RelationalExpression ">=" ShiftExpression -> RelationalExpression {cons("Ge")}

  context-free syntax
    RelationalExpression                         -> EqualityExpression
    EqualityExpression "==" RelationalExpression -> EqualityExpression {cons("Equal")}
    EqualityExpression "!=" RelationalExpression -> EqualityExpression {cons("NotEqual")}

  context-free syntax
    EqualityExpression                   -> ANDexpression
    EqualityExpression "&" ANDexpression -> ANDexpression {cons("And")}

  context-free syntax
    ANDexpression                           -> ExclusiveORExpression
    ANDexpression "^" ExclusiveORExpression -> ExclusiveORExpression {cons("ExOr")}

  context-free syntax
    ExclusiveORExpression                           -> InclusiveORExpression
    ExclusiveORExpression "|" InclusiveORExpression -> InclusiveORExpression {cons("IncOr")}

  context-free syntax
    InclusiveORExpression                           -> LogicalANDExpression
    LogicalANDExpression "&&" InclusiveORExpression -> LogicalANDExpression {cons("LAnd")}

  context-free syntax
    LogicalANDExpression                          -> LogicalORExpression
    LogicalORExpression "||" LogicalANDExpression -> LogicalORExpression {cons("LOr")}

  context-free syntax
    LogicalORExpression                                               -> ConditionalExpression
    LogicalORExpression "?" CommaExpression ":" ConditionalExpression -> ConditionalExpression {cons("IfExp")}

  context-free syntax
    ConditionalExpression                                   -> AssignmentExpression
    UnaryExpression AssignmentOperator AssignmentExpression -> AssignmentExpression {cons("Assign")}

  context-free syntax
    "="   -> AssignmentOperator {cons("AssignEq")}
    "*="  -> AssignmentOperator {cons("AssignMul")}
    "/="  -> AssignmentOperator {cons("AssignDiv")}
    "%="  -> AssignmentOperator {cons("AssignMod")}
    "+="  -> AssignmentOperator {cons("AssignPlus")}
    "-="  -> AssignmentOperator {cons("AssignMin")}
    "<<=" -> AssignmentOperator {cons("AssignSL")}
    ">>=" -> AssignmentOperator {cons("AssignSR")}
    "&="  -> AssignmentOperator {cons("AssignAnd")}
    "^="  -> AssignmentOperator {cons("AssignExp")}
    "|="  -> AssignmentOperator {cons("AssignOr")}

  context-free syntax
    AssignmentExpression                     -> CommaExpression
    AssignmentExpression "," CommaExpression -> CommaExpression    {cons("Comma")}
                                             -> CommaExpressionOpt {cons("EmptyExp")}
    CommaExpression                          -> CommaExpressionOpt

  context-free syntax
    ConditionalExpression -> ConstantExpression



module Types
exports
  context-free syntax
    "typedef"  -> StorageClass {cons("Typedef")}
    "extern"   -> StorageClass {cons("Extern")}
    "static"   -> StorageClass {cons("Static")}
    "auto"     -> StorageClass {cons("Auto")}
    "register" -> StorageClass {cons("Register")}

  context-free syntax
    "int"      -> BasicTypeName {cons("Int")}
    "char"     -> BasicTypeName {cons("Char")}
    "short"    -> BasicTypeName {cons("Short")}
    "long"     -> BasicTypeName {cons("Long")}
    "float"    -> BasicTypeName {cons("Float")}
    "double"   -> BasicTypeName {cons("Double")}
    "signed"   -> BasicTypeName {cons("Signed")}
    "unsigned" -> BasicTypeName {cons("Unsigned")}
    "void"     -> BasicTypeName {cons("Void")}

  context-free syntax
    "const"    -> TypeQualifier {cons("Const")}
    "volatile" -> TypeQualifier {cons("Volatile")}

  context-free syntax
    ( DeclarationQualifierList | TypeQualifier+ ) {IdDecl ","}* ";" -> Declaration {cons("Declaration")}
    ( DeclarationSpecifier | TypeSpecifier ) {VarDecl ","}* ";"     -> Declaration {cons("Declaration2")}

  context-free syntax
    IdentifierDeclarator                 -> IdDecl
    IdentifierDeclarator "=" Initializer -> IdDecl      {cons("IdDeclInit")}
    Declarator                           -> VarDecl
    Declarator "=" Initializer           -> VarDecl     {cons("DeclInit")}
    "{" {Initializer ","}+ "}"           -> Initializer {cons("ArrayInit")}
    "{" {Initializer ","}+ "," "}"       -> Initializer {cons("ArrayInitIncomplete")}
    AssignmentExpression                 -> Initializer {cons("AssignInit")}

  context-free syntax
    TypeQualifier* 
    ( BasicTypeName | ElaboratedTypeName | TypedefName ) 
    ( TypeQualifier | BasicTypeName )* 				-> TypeSpecifier {cons("TypeSpec")}

  context-free syntax
    StorageClass  -> DeclarationQualifier
    TypeQualifier -> DeclarationQualifier

  context-free syntax
    TypeQualifier* StorageClass DeclarationQualifier* 		-> DeclarationQualifierList {cons("DQualifiers")}

  context-free syntax
    TypeQualifier* StorageClass DeclarationQualifier* 
    ( BasicTypeName | ElaboratedTypeName | TypedefName ) 
    ( DeclarationQualifier | BasicTypeName )* 			-> DeclarationSpecifier {cons("DeclSpec")}

module Identifiers
exports
  lexical syntax
    [a-zA-Z\_] [a-zA-Z\_0-9]* -> ID

  lexical restrictions
    ID -/- [a-zA-Z\_0-9]

  context-free syntax
    ID          -> IDENTIFIER  {cons("Id")}
    ID          -> TypedefName {cons("TypeId"), avoid}
    IDENTIFIER  -> IdentifierOrTypedefName
    TypedefName -> IdentifierOrTypedefName



module Statements
exports
  context-free syntax
    LabeledStatement    -> Statement
    CompoundStatement   -> Statement
    ExpressionStatement -> Statement
    SelectionStatement  -> Statement
    IterationStatement  -> Statement
    JumpStatement       -> Statement

  context-free syntax
    IdentifierOrTypedefName ":" Statement   -> LabeledStatement {cons("Label")}
    "case" ConstantExpression ":" Statement -> LabeledStatement {cons("Case")}
    "default" ":" Statement                 -> LabeledStatement {cons("Default")}

  context-free syntax
    "{" Declaration* Statement* "}" -> CompoundStatement {cons("Compound")}

  context-free syntax
    CommaExpressionOpt ";" -> ExpressionStatement {cons("Stat")}

  context-free syntax
    "if" "(" CommaExpression ")" Statement                  -> SelectionStatement {cons("If")}
    "if" "(" CommaExpression ")" Statement "else" Statement -> SelectionStatement {cons("IfElse")}
    "switch" "(" CommaExpression ")" Statement              -> SelectionStatement {cons("Switch")}

  context-free syntax
    "while" "(" CommaExpression ")" Statement                                                -> IterationStatement {cons("While")}
    "do" Statement "while" "(" CommaExpression ")" ";"                                       -> IterationStatement {cons("DoWhile")}
    "for" "(" CommaExpressionOpt ";" CommaExpressionOpt ";" CommaExpressionOpt ")" Statement -> IterationStatement {cons("For")}

  context-free syntax
    "goto" IdentifierOrTypedefName ";" -> JumpStatement {cons("Goto")}
    "continue" ";"                     -> JumpStatement {cons("Continue")}
    "break" ";"                        -> JumpStatement {cons("Break")}
    "return" CommaExpressionOpt ";"    -> JumpStatement {cons("Return")}
    "exit" CommaExpressionOpt ";"      -> JumpStatement {cons("Exit")}

module Program
exports
  sorts TranslationUnit

  context-free syntax
    ExternalDefinition+ -> TranslationUnit {cons("TranslationUnit")}

  context-free syntax
    FunctionDefinition -> ExternalDefinition
    Declaration        -> ExternalDefinition

  context-free syntax
    ( NoTypeSpecifier | DeclarationSpecifier | TypeSpecifier | DeclarationQualifierList |  TypeQualifiers) 
    ( IdentifierDeclarator | OldFun )
    CompoundStatement -> FunctionDefinition {cons("FunDef")}

    TypeQualifier+ -> TypeQualifiers {cons("TypeQualifiers")}

    OldFunctionDeclarator Declaration* -> OldFun {cons("OldFun")}

  context-free syntax
     -> NoTypeSpecifier {cons("NoTypeSpecifier")}

module Declarators
exports
  context-free syntax
    IdentifierDeclarator -> Declarator
    TypedefDeclarator    -> Declarator

  context-free syntax
    PointersOpt IDENTIFIER PostfixingAbstractDeclarator?                   -> IdentifierDeclarator {cons("IdDecl")}
    PointersOpt "(" IdentifierDeclarator ")" PostfixingAbstractDeclarator? -> IdentifierDeclarator {cons("FunDecl")}

  context-free syntax
    PointersOpt TypedefName PostfixingAbstractDeclarator?               -> TypedefDeclarator {cons("TypedefDeclarator1")}
    PointersOpt "(" TypedefDeclarator ")" PostfixingAbstractDeclarator? -> TypedefDeclarator {cons("TypedefDeclarator2")}

  context-free syntax
    PointersOpt ParenIdentifierDeclarator "(" {IDENTIFIER ","}+ ")"         -> OldFunctionDeclarator     {cons("OldFunction1")}
    PointersOpt "(" OldFunctionDeclarator ")" PostfixingAbstractDeclarator? -> OldFunctionDeclarator     {cons("OldFunction2")}
    IDENTIFIER                                                              -> ParenIdentifierDeclarator
    "(" ParenIdentifierDeclarator ")"                                       -> ParenIdentifierDeclarator {bracket}

module Preprocessor
exports
  lexical syntax
    ~[\ \t\n\/]                           -> TokenChar
    [\/]                                  -> Slash
    Slash                                 -> TokenChar
    TokenChar+                            -> Token
    ( [\ \t] | ( [\\] [\n] ) | Comment )+ -> TokWS
    ( [\ \t] | Comment )*                 -> WS
    {Token TokWS}+                        -> TokenSeq
    ~[\"\ \t\n\>]+                        -> FileName

  lexical restrictions
    Slash    -/- [\*]
    Token    -/- ~[\ \t\n\/]
    TokenSeq -/- ~[\ \t\n]
    WS       -/- [\ \t]

  lexical syntax
    "#" WS "define" WS ID WS ( "(" WS {( ID WS ) ( "," WS )}* ")" WS )? TokenSeq? WS [\n] -> ControlLine

  lexical syntax
    "#" WS "undef" WS ID WS [\n]                                     -> ControlLine
    "#" WS "include" WS "<" FileName ">" WS [\n]                     -> ControlLine
    "#" WS "include" WS "\"" FileName "\"" WS [\n]                   -> ControlLine
    "#" WS "include" WS TokenSeq WS [\n]                             -> ControlLineNot
    "#" WS "line" WS [0-9]+ WS ( "\"" WS FileName WS "\"" )? WS [\n] -> ControlLine
    "#" WS Constant ( "\"" WS FileName WS "\"" )? WS [\n]            -> ControlLine
    "#" WS "error" WS TokenSeq? WS [\n]                              -> ControlLine
    "#" WS "pragma" WS TokenSeq? WS [\n]                             -> ControlLine
    "#" WS "if" WS ConstantExpression WS [\n]                        -> IfLine
    "#" WS "if" WS ID WS [\n]                                        -> IfLine
    "#" WS "if" WS ID WS "!=" WS [0-9]+ WS [\n]                      -> IfLine
    "#" WS "ifdef" WS ID WS [\n]                                     -> IfLine
    "#" WS "ifndef" WS ID WS [\n]                                    -> IfLine
    "#" WS "elif" WS ConstantExpression WS [\n]                      -> ElifLine
    "#" WS "else" WS [\n]                                            -> ElseLine

  context-free syntax
    ControlLine -> ExternalDefinition
    ControlLine -> MemberDeclaration

  context-free syntax
    IfLine ExternalDefinition* 
    ( ElifLine ExternalDefinition* )* 
    ( ElseLine ExternalDefinition* )? 
    "#" "endif" -> ExternalDefinition {cons("PpIf")}

module Lexical
exports
  lexical syntax
    [\ \t\n]                        -> LAYOUT
    "/*" ( ~[\*] | Asterisk )* "*/" -> Comment
    Comment                         -> LAYOUT
    [\*]                            -> Asterisk
    "//" ~[\n]* [\n]                -> Comment

  lexical restrictions
    Asterisk -/- [\/]

  context-free restrictions
    LAYOUT? -/- [\ \t\n]

module Constants
exports
  lexical syntax
    [L]? "\"" StringChar* "\"" -> STRINGliteral
    ~[\\\"\n]                  -> StringChar
    [\\] [ntvbrfa\\\?\"]       -> StringChar
    [\\] [x] [0-9A-E] [0-9A-E] -> StringChar
    Octal                      -> StringChar
    [\\] [0-7] [0-7]? [0-7]?   -> Octal

  lexical syntax
    "." [0-9]+ ( [eE] "-"? [0-9]+ )? [fFlL]?        -> FLOATINGconstant
    [0-9]+ "." [0-9]* ( [eE] "-"? [0-9]+ )? [fFlL]? -> FLOATINGconstant
    [0-9]+ [eE] "-"? [0-9]+ [fFlL]?                 -> FLOATINGconstant
    [0-9]+                                          -> INTEGERconstant
    [L]? "'" Char "'"                               -> CHARACTERconstant
    ~[\\\'\n]                                       -> Char
    [\\] [ntvbrfa\\\?\'\"]                          -> Char
    Octal                                           -> Char
    [\\] [x] [0-9A-E] [0-9A-E]                      -> Char

  lexical syntax
    "0" [xX] [0-9]+ -> HEXconstant

  lexical restrictions
    INTEGERconstant HEXconstant FLOATINGconstant -/- [0-9]

module Keywords
exports
  context-free syntax
    "return" -> RETURN {cons("return")}
    "exit"   -> RETURN {cons("exit")}

  context-free syntax
    "auto"     -> IDENTIFIER {reject}
    "double"   -> IDENTIFIER {reject}
    "int"      -> IDENTIFIER {reject}
    "struct"   -> IDENTIFIER {reject}
    "break"    -> IDENTIFIER {reject}
    "else"     -> IDENTIFIER {reject}
    "long"     -> IDENTIFIER {reject}
    "switch"   -> IDENTIFIER {reject}
    "case"     -> IDENTIFIER {reject}
    "enum"     -> IDENTIFIER {reject}
    "register" -> IDENTIFIER {reject}
    "typedef"  -> IDENTIFIER {reject}
    "char"     -> IDENTIFIER {reject}
    "extern"   -> IDENTIFIER {reject}
    "return"   -> IDENTIFIER {reject}
    "exit"     -> IDENTIFIER {reject}
    "union"    -> IDENTIFIER {reject}
    "const"    -> IDENTIFIER {reject}
    "float"    -> IDENTIFIER {reject}
    "short"    -> IDENTIFIER {reject}
    "unsigned" -> IDENTIFIER {reject}
    "continue" -> IDENTIFIER {reject}
    "for"      -> IDENTIFIER {reject}
    "signed"   -> IDENTIFIER {reject}
    "void"     -> IDENTIFIER {reject}
    "default"  -> IDENTIFIER {reject}
    "goto"     -> IDENTIFIER {reject}
    "sizeof"   -> IDENTIFIER {reject}
    "volatile" -> IDENTIFIER {reject}
    "do"       -> IDENTIFIER {reject}
    "if"       -> IDENTIFIER {reject}
    "static"   -> IDENTIFIER {reject}
    "while"    -> IDENTIFIER {reject}

module C
imports Keywords Constants C-Lexical Preprocessor Declarators Program Statements
        Identifiers Types Expressions StructsAndUnions Enumerators
        ParameterDeclarators AbstractDeclarators

