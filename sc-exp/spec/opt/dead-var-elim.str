
/*************************************************************
 * NOTE
 * 
 * Implementation not complete: choices are not taken into account and
 * already bound variables used in a match are discarded.
 *
 **************************************************************/

module dead-var-elim
imports stratlib lib
strategies
 
  dead-var-elim-io =
    iowrap(
      Specification([Signature(id),Strategies(map(dead-var-elim
	; topdown(try(?Var(<!Var(<id>)>){_}))))])
    )

  dead-var-elim = rec dve(
    elim-scope(dve)
    <+ elim-sdef(dve)
    <+ MarkBuild
    <+ PrimT(id, map(dve), map(mark-build-term))
    <+ CallT(id, map(dve), map(mark-build-term))
    <+ Seq(id, dve); Seq(dve, id) 
    <+ elim-choice(dve)
    <+ elim-lchoice(dve)
    <+ elim-guardedlchoice(dve)
    <+ EliminateFromMatch
    <+ all(dve)
  )

  elim-sdef(x) =
    ?SDefT(_,_,_,_)
    ; {| ElimVar :
           SDefT(id, id, map(where(?VarDec(<id>,_); DeclareAlive)), x)
      |}

  elim-scope(x) =
    ?Scope(_,_)
    ; {| ElimVar :
           Scope(map(DeclareDead), x)
           ; EliminateFromScope
      |}

  DeclareDead =
    ?x; rules(ElimVar : Var(x) -> Wld)

  EliminateFromScope =
    Scope(filter(not(!Var(<id>); ElimVar)), id)

  DeclareAlive =
    ?x; rules(ElimVar : Var(x) -> Undefined)

  mark-build-term =
    alltd({?Var(x); debug(!"marking as needed: "); override rules(ElimVar : Var(x) -> Undefined)})

  MarkBuild =
    Build(mark-build-term)

  EliminateFromMatch =
    Match(
      alltd(
        {?Var(x){"bound"}
         ; debug(!"EliminateFromMatch: ")
         ; override rules(ElimVar : Var(x) -> Undefined)})
      ; alltd(?Var(<!Var(<id>)>){_}; ElimVar)
    )

strategies // Choice 

  elim-choice(uv) =
    Choice(id, id)
    ; elim-abstract-choice(Choice(uv,id),Choice(id, uv))

  elim-lchoice(uv) =
    LChoice(id, id)
    ; elim-abstract-choice(LChoice(uv,id),LChoice(id, uv))

  elim-guardedlchoice(uv) =
    GuardedLChoice(id, id, id)
    ; elim-abstract-choice(GuardedLChoice(id,uv,id); GuardedLChoice(uv,id,id)
	           ,GuardedLChoice(id,id,uv))

  elim-abstract-choice(left, right) =
    where(save-ElimVar => bnd0)
    ; left
    ; where(
	save-ElimVar => bndL; <restore-ElimVar> bnd0
      )
    ; right
    ; where(
        <isect-ElimVar> bndL
      )

strategies // Dynamic rule manipulation

  save-ElimVar =
    <table-getlist> "ElimVar"

  clean-ElimVar =
    where(<table-destroy> "ElimVar";
          <table-putlist>("ElimVar", []))

  restore-ElimVar = ?tbl;
    where(<table-destroy> "ElimVar";
          <table-putlist>("ElimVar", tbl))

  isect-ElimVar =
     map(try(?(Scopes,_)
        <+ {?(key, [Defined(_)|_]);
            (where(<table-get> ("ElimVar", key) => [Defined(_)|_])
             <+ !(key, [Undefined]))
           }))
    ; restore-ElimVar
