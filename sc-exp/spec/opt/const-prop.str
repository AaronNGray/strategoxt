module const-prop
imports Stratego lib stratlib unification
strategies

  const-prop-io =
    iowrap(Specification([Signature(id),Strategies(map(const-prop))]))

  const-prop =
    {| CurrentTerm, Binding: cp |}

  cp = 
    prop-match
    <+ prop-build
    <+ prop-scope(cp)
    <+ prop-call(cp)
    <+ prop-seq(cp)
    <+ prop-choice(cp)
    <+ prop-lchoice(cp)
    <+ prop-guardedlchoice(cp)
    <+ prop-let(cp)
    <+ prop-sdef(cp)
    <+ all(cp)

  prop-seq(cp) =
    Seq(cp, cp)

  prop-call(cp) =
    ?CallT(_, _, _)
    ; CallT(id
	   , map(UndefCurrentTerm; cp)
	   , alltd(debug(!"binding? "); Binding; debug(!"binding! ")))
    ; UndefCurrentTerm

  prop-call(cp) =
    ?PrimT(_, _, _)
    ; PrimT(id, cp, alltd(debug(!"binding? "); Binding; debug(!"binding! ")))
    ; UndefCurrentTerm

  prop-scope(cp) =
    ?Scope(xs, _)
    ; {| Binding :
	   where(<map({?x; rules(Binding : Var(x) -> Undefined)})> xs)
           ; Scope(id, cp)
	   ; where(try(
 	       CurrentTerm; oncetd({x: ?Var(x); <fetch(?x)> xs})
               ; UndefCurrentTerm
	     ))
      |}
    
  prop-sdef(cp) =
    ?SDefT(f, _, xs, _)
    ; {| Binding :
	   where(<map({?VarDec(x,_); rules(Binding : Var(x) -> Undefined)})> xs)
           ; SDefT(id, id, id, UndefCurrentTerm; cp)
      |}

  prop-let(cp) =
    ?Let(_,_)
    ; where(save-Binding => bnd0; save-CurrentTerm => trm0)
    ; Let(map(where(UndefCurrentTerm; <restore-Binding> bnd0); cp)
         , where(<restore-CurrentTerm> trm0; <restore-Binding> bnd0); cp)
    
  prop-build =
    ?Build(_)
    ; debug(!"prop-build: ")
    ; Build(alltd(debug(!"binding? "); Binding; debug(!"binding! ")))
    ; debug(!"prop-build: ")
    ; ?Build(t)
    ; rules(
        CurrentTerm : _ -> t
      )
    ; debug(!"prop-build: ")

  prop-match =
    ?Match(_)
    ; debug(!"prop-match: ")
    ; Match(alltd(Binding))
    ; debug(!"prop-match expanded: ")
    ; ?Match(t)
    ; (where(CurrentTerm => ct; debug(!"CurrentTerm: "))
       ; (where(
             <debug(!"match? "); prop-pattern-match; debug(!"match! ")> [(t, ct)]
	     ; map(introduce-binding))
         <+ where(<debug(!"no match with current term: ")> ("strat: ", <id>, "current: ", ct))
            ; !Fail)
      <+ where(<not(oncetd(?Wld + ?As(_,_)))> t)
         ; rules(CurrentTerm : _ -> t)
      <+ id
      )
     ; debug(!"prop-match: ")

  introduce-binding =
    ?(Var(x), t) ; rules(Binding : Var(x) -> t)

  prop-pattern-match = 
    for(\ pairs -> (pairs, []) \
       ,\ ([], sbs) -> sbs \
       ,(UfIdem, id) <+ MatchVar(Var(id)) + (UfDecompose, id) + TermIsVar(Var(id))
	 + AsMatch)

  TermIsVar(isvar) :
    ([(x,y) | ps], sbs) -> (ps, [(y, x) | sbs])
    where <not(isvar)> x; <isvar> y
        ; <not(fetch({z: ?(y,z); <not(eq)> (x, z)}))> sbs

  AsMatch :
    [(As(Var(x),p),t) | ps] -> [(Var(x), t), (p, t) | ps]

  prop-choice(uv) =
    Choice(id, id)
    ; prop-abstract-choice(Choice(uv,id),Choice(id, uv))

  prop-lchoice(uv) =
    LChoice(id, id)
    ; prop-abstract-choice(LChoice(uv,id),LChoice(id, uv))

  prop-guardedlchoice(uv) =
    GuardedLChoice(id, id, id)
    ; prop-abstract-choice(GuardedLChoice(uv,id,id);GuardedLChoice(id,uv,id)
	           ,GuardedLChoice(id,id,uv))

  prop-abstract-choice(left, right) =
    where(save-Binding => bnd0; save-CurrentTerm => trm0)
    ; left
    ; where(
	save-Binding => bndL; <restore-Binding> bnd0
        ; save-CurrentTerm => trm1; <restore-CurrentTerm> trm0
      )
    ; right
    ; where(
        <isect-Binding> bndL; <isect-CurrentTerm> trm1
      )


strategies // Dynamic rule manipulation

  save-Binding =
    <table-getlist> "Binding"

  clean-Binding =
    where(<table-destroy> "Binding";
          <table-putlist>("Binding", []))

  restore-Binding = ?tbl;
    where(<table-destroy> "Binding";
          <table-putlist>("Binding", tbl))

  isect-Binding =
     map(try(?(Scopes,_)
        <+ {?(key, [Defined(_,val)|_]);
            (where(<table-get> ("Binding", key) => [Defined(_,val)|_])
             <+ !(key, [Undefined]))
           }))
    ; restore-Binding


  UndefCurrentTerm =
    rules(CurrentTerm : _ -> Undefined)

  save-CurrentTerm =
    <table-getlist> "CurrentTerm"
    ; debug(!"CurrentTerm saved: ")

  clean-CurrentTerm =
    where(<table-destroy> "CurrentTerm";
          <table-putlist>("CurrentTerm", []))

  restore-CurrentTerm = ?tbl;
    where(<table-destroy> "CurrentTerm";
          <table-putlist>("CurrentTerm", tbl))

  isect-CurrentTerm =
     map(try(?(Scopes,_)
        <+ {?(key, [Defined(_,val)|_]);
            (where(<table-get> ("CurrentTerm", key) => [Defined(_,val)|_])
             <+ !(key, [Undefined]))
           }))
    ; debug(!"CurrentTerm intersected: ")
    ; restore-CurrentTerm
