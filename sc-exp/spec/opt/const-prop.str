module const-prop
imports Stratego lib stratlib unification
strategies

  const-prop-io =
    iowrap(Specification([Signature(id),Strategies(map(const-prop))]))

  const-prop =
    {| CurrentTerm, Binding: cp |}

  cp = 
    prop-match
    <+ prop-build
    <+ prop-scope(cp)
    <+ prop-call(cp)
    <+ prop-seq(cp)
    <+ prop-choice(cp)
    <+ prop-lchoice(cp)
    <+ prop-guardedlchoice(cp)
    <+ prop-let(cp)
    <+ prop-rec(cp)
    <+ prop-not(cp)
    <+ prop-sdef(cp)
    <+ all(cp)

  prop-seq(cp) =
    Seq(cp, cp)

  prop-call(cp) =
    ?CallT(_, _, _)
    ; CallT(id
	   , map(UndefCurrentTerm; cp)
	   , alltd(Binding))
    ; UndefCurrentTerm

  prop-call(cp) =
    ?PrimT(_, _, _)
    ; PrimT(id, cp, alltd(Binding))
    ; UndefCurrentTerm

  prop-rec(cp) =
    ? Rec(_,_)
    ; where(save-Binding => bnd0)
    ; Rec(id, UndefCurrentTerm; cp)
    ; where(UndefCurrentTerm; <restore-Binding> bnd0)

  prop-not(cp) =
    ? Not(_)
    ; where(save-Binding => bnd0)
    ; Not(cp)
    ; where(UndefCurrentTerm; <restore-Binding> bnd0)

  prop-scope(cp) =
    ?Scope(xs, _)
    ; {| Binding :
	   where(<map({?x; rules(Binding : Var(x) -> Undefined)})> xs)
           ; Scope(id, cp)
	   ; where(try(
 	       CurrentTerm; oncetd({x: ?Var(x); <fetch(?x)> xs})
               ; UndefCurrentTerm
	     ))
      |}
    
  prop-sdef(cp) =
    ?SDefT(f, _, xs, _)
    ; {| Binding :
	   where(<map({?VarDec(x,_); rules(Binding : Var(x) -> Undefined)})> xs)
           ; SDefT(id, id, id, UndefCurrentTerm; cp)
      |}

  prop-let(cp) =
    ?Let(_,_)
    ; where(save-Binding => bnd0; save-CurrentTerm => trm0)
    ; Let(map(where(UndefCurrentTerm; <restore-Binding> bnd0); cp)
         , where(<restore-CurrentTerm> trm0; <restore-Binding> bnd0); cp)
    
  prop-build =
    Build(alltd(Binding))
    ; ?Build(t)
    ; rules(CurrentTerm : _ -> t)

  prop-match =
    Match(alltd(Binding))
    ; ?Match(t)
    ; (where(CurrentTerm => ct)
       ; (where(<prop-pattern-match> [(t, ct)]
	        ; map(try(introduce-binding)))
         <+ where(<debug(!"no match with current term: ")> ("strat: ", <id>, "current: ", ct))
            ; !Fail
         )
      <+ where(<not(oncetd(?Wld + ?As(_,_)))> t)
         ; rules(CurrentTerm : _ -> t)
      <+ id
      )

  introduce-binding =
    ?(Var(x), t) 
    ; where(<not(oncetd(?Wld + ?As(_,_)))> t)
    ; rules(Binding : Var(x) -> t)

  prop-pattern-match = 
    for(\ pairs -> (pairs, []) \
       ,\ ([], sbs) -> sbs \
       ,MatchVar(Var(id)) 
	<+ (UfIdem, id)
	<+ (UfDecompose, id) 
	<+ (AsMatch, id)
	<+ (MatchWildCard, id)
// TermIsVar can only be used after integration of
// annotations in abstract syntax
//	<+ (TermIsVar(Var(id)), id)
	<+ (TermIsVarIgnore(Var(id)), id)
    )

  TermIsVar(isvar) :
    [(x,y) | ps] -> [(y, x) | ps]
    where <not(isvar)> x; <isvar> y

  TermIsVarIgnore(isvar) :
    [(x,y) | ps] -> ps
    where <not(isvar)> x; <isvar> y

  MatchWildCard :
    [(Wld, t) | ps] -> ps

  AsMatch :
    [(As(Var(x),p),t) | ps] -> [(Var(x), t), (p, t) | ps]

  prop-choice(uv) =
    Choice(id, id)
    ; prop-abstract-choice(Choice(uv,id),Choice(id, uv))

  prop-lchoice(uv) =
    LChoice(id, id)
    ; prop-abstract-choice(LChoice(uv,id),LChoice(id, uv))

  prop-guardedlchoice(uv) =
    GuardedLChoice(id, id, id)
    ; prop-abstract-choice(GuardedLChoice(uv,id,id);GuardedLChoice(id,uv,id)
	           ,GuardedLChoice(id,id,uv))

  prop-abstract-choice(left, right) =
    where(save-Binding => bnd0; save-CurrentTerm => trm0)
    ; left
    ; where(
	save-Binding => bndL; <restore-Binding> bnd0
        ; save-CurrentTerm => trm1; <restore-CurrentTerm> trm0
      )
    ; right
    ; where(
        <isect-Binding> bndL; <isect-CurrentTerm> trm1
      )


strategies // Dynamic rule manipulation

  save-Binding =
    <table-getlist> "Binding"

  clean-Binding =
    where(<table-destroy> "Binding";
          <table-putlist>("Binding", []))

  restore-Binding = ?tbl;
    where(<table-destroy> "Binding";
          <table-putlist>("Binding", tbl))

  isect-Binding =
     map(try(?(Scopes,_)
        <+ {?(key, [Defined(_,val)|_]);
            (where(<table-get> ("Binding", key) => [Defined(_,val)|_])
             <+ !(key, [Undefined]))
           }))
    ; restore-Binding


  UndefCurrentTerm =
    rules(CurrentTerm : _ -> Undefined)

  save-CurrentTerm =
    <table-getlist> "CurrentTerm"

  clean-CurrentTerm =
    where(<table-destroy> "CurrentTerm";
          <table-putlist>("CurrentTerm", []))

  restore-CurrentTerm = ?tbl;
    where(<table-destroy> "CurrentTerm";
          <table-putlist>("CurrentTerm", tbl))

  isect-CurrentTerm =
     map(try(?(Scopes,_)
        <+ {?(key, [Defined(_,val)|_]);
            (where(<table-get> ("CurrentTerm", key) => [Defined(_,val)|_])
             <+ !(key, [Undefined]))
           }))
    ; restore-CurrentTerm
