\literate[Inlining]

\begin{code}
module inlining
imports Stratego-Amb stratlib lib stratego-laws rename-defs
\end{code}

  \paragraph{Inlining with Definition Environment}

	The inlining strategy uses an environment with all
	the defininitions to be inlined and distributes it over
	the other definitions, substituting bodies for calls to
	operators.

	Heuristics for inlining: inline all operators with arguments.
	Also nullary operators that represent rules (do a match as
	first action).

\begin{code}
overlays

  dont-inline = []

  // create a user-definable list of function that should not and/or functions
  // that should be inlined.

strategies

  inline-strategies = 
    Specification([id,Strategies(inline-sdefs)])

  inline-sdefs = 
    map(simplify0; try(inlineable; AddSDef))
    ; map(inline-sdef)

  inline-sdef =
    rec x({| InlineCall :
             (UndefineSDef <+ repeat(InlineCall0 <+ InlineCall));
	     all(x)
          |})

  UndefineSDef =
    ?SDefT(f,_,_,_);
    rules(
      InlineCall :
        CallT(SVar(f), ss, ts) -> Undefined
    )

  AddSDef =
    ?sdef@SDefT(f, _, _, _)
    ; rules(
      InlineCall : 
        CallT(SVar(f), ss, ts) -> <simplify0> s''
        where //debug(!"InlineCall: ") ;
	     <strename> sdef => SDefT(f, xs, ys, s)
            ; <substitute-args> (xs, ss, s) => s'
	    ; <map(?VarDec(<id>,_))> ys => ys'
	    ; !Scope(ys', 
		     Seq(Seqs(<zip(\ (t,y) -> Seq(Build(t),Match(Var(y)))\ )>(ts, ys')), s')) 
              => s''
            ; rules(InlineCall : CallT(SVar(f), _, _) -> Undefined)
	    //; <debug(!"Inlining: ")> f

      InlineCall0 : 
        CallT(SVar(f), [], []) -> Let([SDefT(g, xs, ys, s)], CallT(SVar(g),[],[]))
        where ///debug(!"InlineCall (0,0): ") ;
	      <strename> sdef => SDefT(f, xs, ys, s)
  	    ; <gt>(<add>(<length> xs, <length> ys), 0)
            ; new => g
            ; rules(InlineCall : CallT(SVar(f), _, _) -> Undefined)
	    //; <debug(!"Inlining: ")> f
    )

  substitute-args = 
    {| SubsArgCall1, SubsArgCall2 :
       ?(xs, ss, s)
       ; <zip(substitute-arg)> (xs, ss)
       ; <topdown(try(SubsArgCall1 + SubsArgCall2))> s
    |}

  substitute-arg =
    ?(VarDec(x, FunType([_],_)), s);
    rules(SubsArgCall1 : CallT(SVar(x), [], []) -> <strename> s)

  substitute-arg =
    ?(VarDec(x, FunType([_,_|_],_)), CallT(SVar(y), [], []));
    rules(SubsArgCall2 : CallT(SVar(x), ss, ts) -> CallT(SVar(y), ss, ts))

  inlineable = 
    //debug(!"inlineable?: ");
    SDefT(not("main_0_0"); ?f, id, id
         , where(not(oncetd(?CallT(SVar(f),[],[])))); body-to-inline)
    // ; where(<not(fetch(?f))> dont-inline)
    // ; where(<debug(!"inlineable: ")> f )

  body-to-inline = 
    rec x(
        Id
	+ Fail
	+ CallT(SVar(id),id,id)
	+ Build(id)
	+ Match(id)
	+ Seq(Match(id), id)
	+ Scope(id, Match(id))
	+ Scope(id, Seq(Match(id), id))
	+ Seq(Scope(id, Seq(Match(id), id)), id)
	+ Cong(id,id)
	+ Choice(x, x)
	+ LChoice(x, x)
	+ GuardedLChoice(x, x, x)
    );
    where(<leq>(<term-size>, 50))

  term-size =
    rec x(crush(!1,add,x))

\end{code}