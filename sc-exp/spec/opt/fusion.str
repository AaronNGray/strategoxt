module fusion
imports Stratego stratego-laws lib strategy-patterns desugar
	fusion-rules verbose

signature
  constructors
    Mark : Strat

strategies

  fusion = 
    iowrap(
      declare-inline-rules
      ; ( check-library-definitions
        ; alltd(innermost-fusion)
        ) <+ if-verbose2(say(!"no innermost here"))
    )


  // Inlining strategy definitions

  declare-inline-rules =
    Specification([Signature(id),
                   Strategies(map(declare-inline-rule))])

  declare-inline-rule =
    ?|[ f(a1*) = s1 ]|;
    rules(
      InlineStrat :
        Strategy|[ f(s*) ]| -> <ssubs> (<map(?VarDec(<id>,_))> [a2*], [s*], s2)
        where <strename> |[ f(a1*) = s1 ]| => |[ f(a2*) = s2 ]|
    )

  inline-rules = 
    rec x(try(
	Choice(x, x)
	+ LChoice(x, x) 
	+ Scope(id, Seq(Match(id),Build(id)))
	+ Scope(id, Seq(Match(id),Seq(id,Build(id))))
	+ InlineStrat; x
    ))

  // Check library definitions
  // note that other implementations might also be correct

  check-library-definitions =
    check-that-try-is-try
    ; check-that-innermost-is-innermost
    ; check-that-bottomup-is-bottomup

  check-that-try-is-try =
    where(
      new => x
      ; (<InlineStrat> Strategy|[ try_1(x()) ]|
         <+ if-verbose2(say(!"no definition of try_1: ")); fail)
      ; (?|[ x() <+ id ]|
         <+ if-verbose1(debug(!"try is not try: ")); fail)
      ; if-verbose2(say(!"try is try "))
    )

  check-that-innermost-is-innermost =
    where(
      new => x
      ; (<InlineStrat> Strategy|[ innermost_1(x()) ]|
         <+ if-verbose2(say(!"no definition of innermost_1: ")); fail)
      ; (?|[ bottomup_1(try_1(x(); innermost_1(x()))) ]|
         <+ {z: ?|[ bottomup_1(rec z(try_1(x(); bottomup_1(z())))) ]|}
         <+ {z: ?|[ bottomup_1(rec z(x(); bottomup_1(z()) <+ id))  ]|}
         <+ if-verbose1(debug(!"innermost is not innermost: ")); fail)
      ; if-verbose2(say(!"innermost is innermost "))
    )

  check-that-bottomup-is-bottomup =
    where(
      new => x
      ; (<InlineStrat> Strategy|[ bottomup_1(x()) ]|
         <+ if-verbose2(say(!"no definition of bottomup_1: ")); fail)
   // ; ?|[ rec y(all(y()); x()) ]|
      ; (?|[ all(bottomup_1(x())); x() ]|
         <+ if-verbose1(debug(!"bottomup is not bottomup: ")); fail)
      ; if-verbose2(say(!"bottomup is bottomup"))
    )

  // The fusion strategy

  innermost-fusion = 
    ?|[ innermost_1(s1) ]| 
    ; if-verbose2(say(!"fusion: application of innermost found"))

    ; where(new => x)
    ; where(<seq-over-choice> Strategy|[ bottomup_1(x()) ]|)
    ; where(<bottomup-to-var> Strategy|[ bottomup_1(x()) ]|)

    ; where(<inline-rules> s1 => s2)
    ; !|[ bottomup_1(rec x((mark(); s2); bottomup_1(x()) <+ id)) ]|
    ; propagate-mark

    ; fuse-with-bottomup
    ; alltd(BottomupToVarIsId-UnCond + BottomupToVarIsId-Cond <+ UnMark)

    ; not(oncetd(?Strategy|[ mark() ]|)
          ; say(!"not all marks removed"))
    ; desugar
    ; if-verbose1(say(!"fused application of innermost"))

  // Propagate mark over choice

  propagate-mark = 
    innermost(
	SeqOverChoiceL
	+ SeqOverLChoiceL
	+ SeqOverScopeL 
    )

  fuse-with-bottomup = 
    innermost(
	SeqOverChoiceR
	+ SeqOverLChoiceR
	+ SeqOverScopeR
	+ AssociateR
	+ IntroduceApp
	+ BottomupOverConstructor
    )

  propagate-nf-assertion = 
    is-innermost;
    innermost(
	SeqOverChoiceL
	+ SeqOverLChoiceL
	+ SeqOverScopeL 
	+ AssociateL
	+ IntroduceApp
	+ NormalFormToBuildVars
    )

  // The following rule applies in the context of the transformation
  // above, where we know that the bottomup is the application of the
  // normalisation strategy to all subterms. Since the variable
  // originates in the left-hand side of the rewrite rule, we know
  // it is already in normal form.

  bottomup-to-var-old =
    ?bu
  ; rules(
      BottomupToVarIsId-UnCond :
        |[ mark(); ?t1; !t2 ]| -> |[ ?t1; !t3 ]|
        where !bu => s
            ; <tvars> t1 => vs
            ; {| Replace : 
                 map(!Var(<id>); {?t; rules(Replace : Term|[ <s> t ]| -> Term|[ t ]|)})
                 ; <alltd(Replace)> t2 => t3 |}

      BottomupToVarIsId-Cond :
        |[ mark(); ?t1; where(s); !t2 ]| -> |[ ?t1; where(s'); !t2 ]|
        where !bu => s''
            ; <tvars> t1 => vs
            ; {| Replace : 
                 map(!Var(<id>); {?t; rules(Replace : Term|[ <s''> t ]| -> Term|[ t ]|)})
                 ; <alltd(Replace)> (s, t2) => (s', t3) |}
   )

  bottomup-to-var = ?bu;
    rules(
      BottomupToVarIsId-UnCond :
        |[ mark(); ?t1; !t2 ]| -> |[ ?t1; !t3 ]|
        where <replace-application> (bu, t1, t2) => t3

      BottomupToVarIsId-Cond :
        |[ mark(); ?t1; where(s); !t2 ]| -> |[ ?t1; where(s'); !t3 ]|
        where <replace-application> (bu, t1, (s, t2)) => (s', t3)
    )

   replace-application :
     (s, t1, t2) -> t3
     where {| Replace : 
              <tvars; map({?x; rules(Replace : Term|[ <s> x ]| -> Term|[ x ]|)})> t1;
              <alltd(Replace)> t2 => t3 
           |}

  // remove mark

  UnMark :
    Strategy|[ mark() ]| -> Strategy|[ id ]|

