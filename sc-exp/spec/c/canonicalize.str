module canonicalize
imports Stratego lib C C-simplify dynamic-rules bound-unbound-vars

strategies

  canonicalize =
    iowrap(
      downup2(repeat(Canon),repeat(Canon))
      ; mark-fresh-vars
      ; mark-bound-unbound-vars
    )

rules

  CallIdFun :
    Id -> CallT(SVar("_id"),[],[])

  CallFailFun :
    Fail -> CallT(SVar("_fail"),[],[])

(*
 
  f(id)  f(g)

  f(x + y) -> let z = x + y in f(z)

*)

/*
  Canon :
    Call(f, args) -> Let(defs', Call(f, args'))
    where <unzip(try(CallIdFun + CallFailFun); 
                 (CreateDef1 <+ 
                  not(Call(SVar(id),[])); CreateDef2 <+ 
                  split(id,![])))> args => (args', defs)
        ; <concat> defs => defs'
        ; not([])
*/

  Canon :
    CallT(f, args1, args2) -> Let(defs', CallT(f, args1', args2))
    where <unzip(try(CallIdFun + CallFailFun); 
                 (CreateDef1 <+ 
                  not(CallT(SVar(id),[],[])); CreateDef2 <+ 
                  split(id,![])))> args1 => (args1', defs)
        ; <concat> defs => defs'
        ; not([])

  Canon :
    PrimT(f, args1, args2) -> Let(defs', PrimT(f, args1', args2))
    where <unzip(try(CallIdFun + CallFailFun); 
                 (CreateDef1 <+ 
                  not(CallT(SVar(id),[],[])); CreateDef2 <+ 
                  split(id,![])))> args1 => (args1', defs)
        ; <concat> defs => defs'
        ; not([])

//  CreateDef1 :
//    Let(defs,Call(SVar(f),[])) -> (Call(SVar(f),[]), defs)

  CreateDef1 :
    Let(defs,CallT(SVar(f),[],[])) -> (CallT(SVar(f),[],[]), defs)

//  CreateDef2 :
//    s -> (Call(SVar(f),[]), [SDef(f,[],s)])
//    where new => f

  CreateDef2 :
    s -> (CallT(SVar(f),[],[]), [SDefT(f,[],[],s)])
    where new => f

/*
  Canon :
    Call(f, args) -> Call(f, args')
    where //<map(try(CallIdFun + CallFailFun))> args => args'
      <rec x([(CallIdFun + CallFailFun)|try(x)] <+ [id|x])> args => args'
*/

  Canon :
    CallT(f, args1, args2) -> CallT(f, args1', args2)
    where //<map(try(CallIdFun + CallFailFun))> args => args'
      <rec x([(CallIdFun + CallFailFun)|try(x)] <+ [id|x])> args1 => args1'

  Canon :
    PrimT(f, args1, args2) -> PrimT(f, args1', args2)
    where //<map(try(CallIdFun + CallFailFun))> args => args'
      <rec x([(CallIdFun + CallFailFun)|try(x)] <+ [id|x])> args1 => args1'

  Canon :
    Bagof(s) -> CallT(SVar("SRTS_bagof"),[s],[])

  Canon :
    All(s) -> CallT(SVar("SRTS_all"),[s],[])

  Canon :
    One(s) -> CallT(SVar("SRTS_one"),[s],[])

  Canon :
    Some(s) -> CallT(SVar("SRTS_some"),[s],[])

  Canon :
    Thread(s) -> CallT(SVar("SRTS_thread"),[s],[])

  Canon :
    Scope([],s) -> s

  Canon :
    Scope(xs,Scope(ys,s)) -> Scope(<conc>(xs,ys),s)

  Canon : 
    Seq(Id, s) -> s

  Canon : 
    Seq(s, Id) -> s

  Canon :
    Seq(Where(s), Build(t)) -> Seq(s, Build(t))

  Canon :
    Seq(Where(s1), Seq(Build(t), s2)) -> Seq(s1, Seq(Build(t), s2))

  Canon :
    SDefT(f, [], [], Rec(x, s)) ->
    SDefT(f, [], [], <alltd(?CallT(SVar(x),[],[]); !CallT(SVar(f),[],[]))> s)

  Canon :
    Rec(x, s) -> Let([SDefT(x, [], [], s)], CallT(SVar(x),[],[]))

//  Canon :
//    SDef([DontInline],f,xs,s) -> SDef(f,xs,s)


strategies

  mark-fresh-vars =
    id
