/**
 * Lists can be used to represent sets of terms.  Using the
 * notion of sets we can define the collection of a set of
 * subterms corresponding to some criterion.
 */
module list-set
imports list-basic list-misc term collect // collect is imported for backwards compatibility

rules
 
  HdMember(mklst) : 
    [x | xs] -> xs where mklst; fetch(?x)

  HdMember'(eq, mklst) : 
     [x | xs] -> xs 
     where mklst; fetch(\y -> <eq> (x, y)\)

strategies

  /**
   * Removes duplicate elements from a list.
   *
   * @type  List(a) -> List(a)
   */
  make-set =
    foldr(![], union, ![<id>])

  /**
   * Removes duplicate elements from a list.
   *
   * @type   List(a) -> List(a)
   * @note   nub is an alias of make-set.
   * @since  0.9.4
   */
  nub = make-set

strategies

  /**
   * Union: Concatenation of two lists, only those elements in the
   * first list are added that are not already in the second list.
   *
   * @type List(a) * List(a) -> List(a)
   */
  union = union(eq)

  // a * a -> fail? :: List(a) * List(a) -> List(a)
  union(eq) : 
    (l1, l2) -> <rec x(
                   ([]; !l2)
                <+ (HdMember'(eq, !l2); x)
                <+ [id | x]
                )> l1

strategies

  /**
   * @type  List(List(a)) -> List(a)
   */
  unions = unions(eq)

  // a * a -> fail? :: List(List(a)) -> List(a)
  unions(eq) = foldr(![], union(eq))

rules

  /**
   * Difference of two lists.
   *
   * @type  (List(a), List(a)) -> List(a)
   */ 
  diff = diff(eq) 

  /**
   * @param  Used to compare the elements. If an application succeeds, then two elements are equal.
   * @type   (List(a), List(a)) -> List(a)
   */
  diff(eq) :
    (l1, l2) -> <rec x(
                   []
                <+ (HdMember'(eq, !l2); x)
                <+ [id | x]
                )> l1

  diff'(eq) = 
      obsolete(!"diff'/1; use diff/1")
    ; diff(eq)

  /**
   * @type  (List(a), List(a)) -> List(a)
   */
  sym-diff = sym-diff(eq)

  /**
   * @param  Used to compare the elements. If an application succeeds, then two elements are equal.
   * @type   (List(a), List(a)) -> List(a)
   */
  sym-diff(eq) =
    <union> (<diff(eq)>, <Swap; diff(eq)>)

strategies

  /**
   * Take the intersection of two sets.
   *
   * Elements are compared using the eq strategy.
   *
   * @type [a] * [a] -> [a]
   */
  isect = isect(eq)


  /**
   * Take the intersection of two sets.
   *
   * The result is the first list, without the elements
   * that are not in the second list. If the first list is not
   * a set (it has duplicates), the result will
   * have duplicates. Note that because of this <isect> (l1, l2) is 
   * not always equal to <isect> (l2, l1).
   *
   * @type eq  a * a ->? _ 
   * @type     [a] * [a] -> [a]
   */
  isect(eq) : 
    (l1, l2) -> <rec x(
                   [] 
                <+ ( where(HdMember'(eq, !l2)); [id | x] )
                <+ ?[_ | <x>]
                )> l1
