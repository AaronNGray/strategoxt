\literate[list-set]

	\begin{abstract}

	Lists can be used to represent sets of terms.  Using the
	notion of sets we can define the collection of a set of
	subterms corresponding to some criterion.

	\end{abstract}

\begin{code}
module list-set
imports list-basic list-misc term collect
// collect is imported for backwards compatibility

rules
 
  HdMember(mklst) : 
    [x | xs] -> xs where mklst; fetch(?x)

  HdMember'(eq, mklst) : 
     [x | xs] -> xs 
     where mklst; fetch(\y -> <eq> (x, y)\)

  // :: List(a) -> List(a)
  make-set =
    foldr(![], union, ![<id>])

\end{code}

	Union: Concatenation of two lists, only those elements in the
	first list are added that are not already in the second list.

\begin{code}
strategies

  // :: List(a) * List(a) -> List(a)
  union = union(eq)

  // a * a -> fail? :: List(a) * List(a) -> List(a)
  union(eq) : 
    (l1, l2) -> <rec x(
                   ([]; !l2)
                <+ (HdMember'(eq, !l2); x)
                <+ [id | x]
                )> l1

  // :: List(List(a)) -> List(a)
  unions = unions(eq)

  // a * a -> fail? :: List(List(a)) -> List(a)
  unions(eq) = foldr(![], union(eq))

\end{code}

	Diff: Difference of two lists

\begin{code}
rules

  // :: List(a) * List(a) -> List(a)
  diff = diff(eq) 

  // a * a -> fail? :: List(a) * List(a) -> List(a)
  diff(eq) :
    (l1, l2) -> <rec x(
                   []
                <+ (HdMember'(eq, !l2); x)
                <+ [id | x]
                )> l1

  diff'(eq) = 
      obsolete(!"diff'/1; use diff/1")
    ; diff(eq)

  // :: List(a) * List(a) -> List(a)
  sym-diff = sym-diff(eq)

  // a * a -> fail? :: List(a) * List(a) -> List(a)
  sym-diff(eq) =
    <union> (<diff(eq)>, <Swap; diff(eq)>)

strategies

  /**
   * Take the intersection of two sets.
   *
   * Elements are compared using the eq strategy.
   *
   * @type [a] * [a] -> [a]
   */
  isect = isect(eq)


  /**
   * Take the intersection of two sets.
   *
   * The result is the first list, without the elements
   * that are not in the second list. If the first list is not
   * a set (it has duplicates), the result will
   * have duplicates. Note that because of this <isect> (l1, l2) is 
   * not always equal to <isect> (l2, l1).
   *
   * @type eq  a * a ->? _ 
   * @type     [a] * [a] -> [a]
   */
  isect(eq) : 
    (l1, l2) -> <rec x(
                   [] 
                <+ ( where(HdMember'(eq, !l2)); [id | x] )
                <+ ?[_ | <x>]
                )> l1

\end{code}
	
% Copyright (C) 1998-2002 Eelco Visser <visser@acm.org>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
% 02111-1307, USA.