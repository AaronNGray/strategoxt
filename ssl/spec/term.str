\literate[term]

	\begin{abstract}
	Some primitives for the manipulation of terms.
	\end{abstract}

\begin{code}
module term
imports simple-traversal list-misc list-set

strategies

  mkterm       = ?(c,ts); prim("SSL_mkterm",c,ts)
  explode-term = ?t; prim("SSL_explode_term",t)
  address-lt   = ?(t1,t2); prim("SSL_address_lt",t1,t2)
  address      = ?t; prim("SSL_address",t)
  
strategies 

  crush(nul, sum) : 
    _#(xs) -> <foldr(nul,sum)> xs

  crush(nul, sum, s) : 
    _#(xs) -> <foldr(nul,sum, s)> xs

  foldr-kids(nul,sum) =
    obsolete(!"foldr-kids/2; use crush/2");
    crush(nul, sum)

  foldr-kids(nul,sum,s) =
    obsolete(!"foldr-kids/3; use crush/3");
    crush(nul, sum, s)
    
strategies      

  node-size =
    crush(!0, add, !1)

  term-size =
    crush(!1, add, term-size)
  
strategies

  at-depth(depth, s) =
      !(<depth> (), <id>)
    ; topdown(
        {d :
           ?(0, <s> )
        <+ ?(d, <id>); all(!(<dec> d, <id>))
        }
      )  
  
\end{code}

	\paragraph{Occurence Counting}

\begin{code}
strategies

  nrofoccs(s) = 
    obsolete(!"nrofoccs/1; use occurrences/1");
    occurrences(s)

  om-occurrences(s) = 
    s; !1 <+ crush(!0, add, occurrences(s))

  occurrences(s) = 
    split(s; !1 <+ !0, crush(!0, add, occurrences(s))); add
\end{code}

\paragraph{Documentation}

	Some primitives for the manipulation of terms.

	\verb|<mkterm> (f, [t1,...,tn])| builds the constructor application
	\verb|f(t1,...,tn)|

	\verb|<explode-term> f(t1,...,tn)| is the inverse of \verb|mkterm|
	and produces \verb|(f, [t1,...,tn])|

	Note: the primitive strategies \verb|mkterm| and \verb|explode-term|
	have been turned into language constructs. The pattern
	\verb|f#(xs)| denotes
	the decomposition of a term into its function symbol \verb|f| and
	its \emph{list} of arguments \verb|xs|. This pattern can be
	used in matching \verb|?f#(xs)| and building \verb|!f#(xs)|
	terms (so also in left- and right-hand sides of rules) and also
	as a congruence \verb|s1#(s2)|.

	\verb|<address-lt> (t1, t2)| compares the address of two terms
	and succeeds if the address of the first is smaller than the
	address of the second. This predicate induces a total ordering
	on terms and can be used to sort terms. Note that this
	relation is valid in one session (but what happens after
	rehashing), but not necessarily between two sessions.

	\verb|<address> t| replaces \verb|t| with its address (an integer).
	This can be used to obtain a unique symbolic reference to a term.

% Copyright (C) 1998-2002 Eelco Visser <visser@acm.org>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
% 02111-1307, USA.