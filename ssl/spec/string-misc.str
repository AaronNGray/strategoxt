/**
 * Contains miscellaneous strategies for processing strings,
 * e.g. trailing-space-trimming, line-splitting, etc.
 */
module string-misc
imports string list-basic list-misc

strategies

  /**
   * Splits a string into a list of tokens, including the empty ones.
   *
   * This strategy differs from string-tokenize in that it produces an empty ""
   * token when two separator chars are encountered, or after a final separator.
   *
   * Example:
   *  <string-tokenize-keep-empty(|['\n'])> "fu\n\nbar\n" => ["fu","","bar",""]
   *
   * @param The list of characters that may separate two tokens.
   * @type sepChars [char]
   * @type    string -> [string]
   * @since 0.9.5
   */
  string-tokenize-keep-empty(|sepChars) =
    explode-string
    ; rec x( ( split-fetch(<elem> (<id>, sepChars))
             ; \ (tchars, cs) -> [tchars|<x> cs] \ )
          <+ ![<id>])
    ; map(implode-string)


  /**
   * Splits a string into a list of tokens, keeping the separating elements as
   * 1-char-strings within the results list, *and* also keeping the empty
   * "" tokens.
   *
   * Example:
   *  <string-tokenize-keep-all(|['\n'])> "fu\n\nbar\n" => ["fu","\n","","\n","bar","\n",""]
   *
   * @param The list of characters that may separate two tokens.
   * @type sepChars [char]
   * @type    string -> [string]
   * @since 0.9.5
   */
  string-tokenize-keep-all(|sepChars) =
    explode-string
    ; rec x( ( split-fetch-keep(where(<elem> (<id>, sepChars)))
             ; \ (tchars, s, cs) -> [tchars|[[s]|<x> cs]] \ )
          <+ ![<id>])
    ; map(implode-string)

  /**
   * Gets all newline('\n')-separated lines in a string.
   * If the string is ended by a newline, the last element of the returned list
   * is the empty string.
   *
   * @type string -> [string]
   * @since 0.9.4
   */
  get-lines =
    string-tokenize-keep-empty(|['\n'])


  /**
   * Applies a strategy to all lines in a string.
   *
   * Lines are expected to be separated by a single '\n'.
   * The last line may be ended by a newline, or not. In the former case, the
   * last line in the resulting string will also be ended by a newline,
   * otherwise not.
   * Initial or intermediate newlines are preserved.
   * The strategy is applied to each line (even the empty ones), *excluding*
   * the newline character. The newline is appended again after application of s
   *
   * @param The strategy that should be applied to each line.
   * @type s string -> string
   * @type   string -> string
   * @since 0.9.4
   */
  all-lines(s) =
    is-string
  ; string-tokenize-keep-empty(|['\n'])
  ; at-last( \ [""] -> [] \  // Do not run s on a final empty line.
           < where(!["\n"] => laststring) // ... but remember that the second last line was delimited by a newline
           + where(![] => laststring))    // ... or not.
  ; map(s)
  ; <separate-by> ("\n", <id>)
  ; <conc> (<id>, laststring) // Restore the final newline, if there was one.
  ; concat-strings


  /**
   * Makes one newline-separated string out of a list of strings
   * @since 0.9.4
   */
  lines =
    separate-by(!"\n")
  ; <conc> (<id>, ["\n"])
  ; concat-strings

  /**
   * Indents every line in a string with spaces.
   *
   * @param The number of spaces to be put in front of every line.
   * @type n int
   * @type string -> string
   * @since 0.9.4
   */
  indent-text(|n) =
    where(<copy-char> (n, ' ') => prefix)
  ; prefix-lines(|prefix)

  /**
   * Prefixes all lines in a string with a string.
   *
   * @param The prefix.
   * @type p string
   * @type   string -> string
   * @since 0.9.4
   */
  prefix-lines(|p) =
    all-lines(<conc-strings> (p, <id>))

strategies
  /**
   * Trims leading and/or trailing characters from a string.
   *
   * Removes the longest substring for which all characters satisfy strategy s.
   * Examples:
   *   <ltrim(?' ')> "   fred  " => "fred  "
   *   <rtrim(?' ')> "   fred  " => "   fred"
   *   <trim(?' ')>  "   fred  " => "fred"
   * 
   * @param should succeed for all elements that have to be trimmed.
   * @since 0.9.5
   */

  ltrim(s) = string-as-chars(ltrim(s))

  rtrim(s) = string-as-chars(rtrim(s))

  trim(s)  = string-as-chars(trim(s))

  /**
   * Checks whether a character is whitespace.
   *
   * Whitespace is a space (32), or a tab (9)
   *
   * @since 0.9.5
   */
  is-whitespace = test('\t' + ' ')

  /**
   * Trims all trailing whitespace in a (single-line) string.
   *
   * @since 0.9.5
   */
  trim-trailing-whitespace =
    rtrim(is-whitespace)

  /**
   * Trims all leading whitespace in a (single-line) string.
   *
   * @since 0.9.5
   */
  trim-leading-whitespace =
    ltrim(is-whitespace)

  /**
   * Trims all trailing *and* leading whitespace in a (single-line) string.
   *
   * @since 0.9.5
   */
  trim-whitespace =
    trim(is-whitespace)

strategies
/**
 * Some shuffling strategies
 */
shuffle-forced =
   where(length; <gt> (<id>, 1))
   ; where(at-suffix(?[x,y|xs]; where(not(<eq> (x, y)))))
   ; rec x({orig: ?orig; shuffle; (where(<eq> (orig, <id>)) < x + id)})
<+ id

shuffle =
  where(is-list)
; map(!(<next-random> (), <id>))
; sort-list(SortL((Fst, Fst); gt))
; map(Snd)

shuffle-word-mids =
  string-tokenize-keep-all(|[' ', '.', ','])
; map(shuffle-word-mid)
; concat-strings

shuffle-word-mid =
  where(is-string)
; (where(strlen; <lt> (<id>, 3))
<+ explode-string
 ; ?[i|cs]
 ; <reverse> cs
 ; ?[l|mid]
 ; where(<shuffle-forced; reverse> mid => shuffledmid)
 ; <concat; implode-string> [[i],shuffledmid, [l]])
