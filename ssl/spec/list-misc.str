module list-misc
imports list-cons list-basic integers
strategies

  member = (?x, fetch(?x))

rules

  FoldR1   : [x, y] -> (x, y)
  FoldR    : [x | xs] -> (x, xs)

  FoldL(s) : ([x | xs], y) -> (xs, <s> (x, y))

  lsplit(f, g) : x -> [<f> x, <g> x]

strategies

  /**
   * foldr, requires a list of length > 1.
   *
   * @type s1  [a] -> b
   * @type s2  a * b -> b
   * @type     [a] -> b
   */
  foldr1(s1, s2) = 
    rec x([id]; s1 <+ FoldR; (id, x); s2)

  /**
   * @type s1  a * b -> b
   * @type     [a] -> b
   */
  foldr1(s) = 
    rec x((FoldR1 <+ FoldR; (id, x)); s)

  /**
   * @type s1  [] -> b
   * @type s2  a * b -> b
   * @type     [a] -> b
   */
  foldr(s1, s2) = 
    []; s1 
    + \ [y|ys] -> <s2>(y, <foldr(s1, s2)> ys) \

  /**
   * s1 :: [] -> b
   * s2 :: c * b -> b
   *  f :: a -> c
   *    :: [a] -> b
   */
  foldr(s1, s2, f)  = 
    []; s1 + 
    \ [y|ys] -> <s2> (<f> y, <foldr(s1, s2, f)> ys) \


  /**
   * s :: a * b -> b
   *   :: [a] * b -> b
   */ 
  foldl(s) = 
    rec x( \ ([], y) -> y \ + FoldL(s); x)

  /**
   * @warning  obsolete, use foldr/3
   */
  mapfoldr(s1, s2, s3) = 
    obsolete(!"mapfoldr; use foldr/3");
    foldr(s1, s3, s2)

  mapfoldr1(s1, s2, s3) = 
    rec x([id]; s1 <+ [s2|x]; \ [a|b]->(a,b)\; s3)

  /** 
   * Transform the elements of a list into lists (map)
   * and concatenate into a single list (concat).
   * 
   * Note: equivalent to map(s); concat
   *
   * @type s :: a -> List(b) 
   * @type   :: List(a) -> List(b)
   */
  mapconcat(s) =
    foldr([], conc, s)

  last = 
    rec x(Last <+ Tl; x)

 /**
  * @inc init
  * @inc empty init
  */
  init = 
    at-last(Tl)

  /**
   * Splits a list into a tuple of its init list and last element.
   *
   * Example:
   *   <split-last> [1, 2, 3, 4] => ([1, 2, 3], 4)
   *   <split-last> [1]          => ([], 1)
   *
   * @since  0.9.4
   * @type   List(a) -> (List(a), a)
   * @inc    split-last
   */
  split-last =
      at-last(?[x]; ![])
    ; !(<id>, x)

 /**
  * @inc copy-test
  */
  copy = 
    for(\ (n,t) -> (n,t,[]) \
       ,\ (0,t,ts) -> ts \
       ,\ (n,t,ts) -> (<subt>(n,1), t, [t|ts]) where <geq>(n,1) \ )

  copy(s) = 
    for(\ (n,t) -> (n,t,[]) \
       ,\ (0,t,ts) -> ts \
       ,\ (n,t,ts) -> (<subt>(n,1), t, [<s> t|ts]) where <geq>(n,1) \ )

  thread-map(s) = 
    rec x(Cons^T(s, x) + Nil^T)

 /**
  * @inc number-test
  */
  number(s) =
    !(<id>, 0); thread-map(!(<s>,<Snd;inc>)); ?(<id>,_)

  take-while(s) = 
    at-suffix([] + ([not(s)|id];![]))

  take-until(s) = 
    at-suffix([] + ([s|id];![]))

  take(isn) = 
    nzip0(id); take-until((isn,id)); map(Snd)

  drop-while(s) = 
    at-suffix(([] + [not(s)|id]);?xs); !xs

  drop-until(s) = 
    at-suffix(([] + [s|id]);?xs); !xs

  /**
   * @warning  alias of split-fetch/1
   */
  split-at(s) = 
    split-fetch(s)

  drop(isn) = 
    nzip0(id); drop-until((isn,id)); map(Snd)

  /** 
   * flatten-list completely flattens a list.
   * See list-misc-test for examples.
   * 
   * type in = a or [in]
   * flatten-list :: [in] -> [a]
   *
   * @inc flatten-test
   */
  flatten-list =
    foldr(![], (is-list, id) < conc-two-lists + MkCons, is-list < flatten-list + id)
