module list-misc
imports list-cons list-basic integers
strategies

  member = (?x, fetch(?x))

rules

  FoldR1   : [x, y] -> (x, y)
  FoldR    : [x | xs] -> (x, xs)

  FoldL(s) : ([x | xs], y) -> (xs, <s> (x, y))

  lsplit(f, g) : x -> [<f> x, <g> x]

strategies

  /**
   * foldr, requires a list of length > 1.
   *
   * @type s1  [a] -> b
   * @type s2  a * b -> b
   * @type     [a] -> b
   */
  foldr1(s1, s2) = 
    rec x([id]; s1 <+ FoldR; (id, x); s2)

  /**
   * foldr, requires a list of length > 1.
   * The additional parameter strategy f is applied to each element just
   * before each folding step.
   *
   * @type s1  [c] -> b
   * @type s2  c * b -> b
   * @type f   a -> c
   * @type     [a] -> b
   */
  foldr1(s1, s2, f) = 
    rec x([f]; s1 <+ FoldR; (f, x); s2)

  /**
   * foldr, requires a list of length > 1.
   * Note that s maps (a, a) to a, only one type is involved.
   *
   * @type s  a * a -> a
   * @type     [a] -> a
   */
  foldr1(s) = 
    rec x((FoldR1 <+ FoldR; (id, x)); s)

  /**
   * @type s1  [] -> b
   * @type s2  a * b -> b
   * @type     [a] -> b
   */
  foldr(s1, s2) = 
    []; s1 
    + \ [y|ys] -> <s2>(y, <foldr(s1, s2)> ys) \

  /**
   * Right fold a list.
   * The additional parameter strategy f is applied to each element just
   * before each folding step.
   *
   * s1 :: [] -> b
   * s2 :: c * b -> b
   *  f :: a -> c
   *    :: [a] -> b
   */
  foldr(s1, s2, f)  = 
    []; s1 + 
    \ [y|ys] -> <s2> (<f> y, <foldr(s1, s2, f)> ys) \


  /**
   * s :: a * b -> b
   *   :: [a] * b -> b
   */ 
  foldl(s) = 
    rec x( \ ([], y) -> y \ + FoldL(s); x)

  /**
   * @warning  obsolete, use foldr/3
   */
  mapfoldr(s1, s2, s3) = 
    obsolete(!"mapfoldr; use foldr/3");
    foldr(s1, s3, s2)

  mapfoldr1(s1, s2, s3) = 
    rec x([id]; s1 <+ [s2|x]; \ [a|b]->(a,b)\; s3)

  /** 
   * Transform the elements of a list into lists (map)
   * and concatenate into a single list (concat).
   * 
   * Note: equivalent to map(s); concat
   *
   * @type s :: a -> List(b) 
   * @type   :: List(a) -> List(b)
   */
  mapconcat(s) =
    foldr([], conc, s)

  last = 
    rec x(Last <+ Tl; x)

 /**
  * @inc init
  * @inc empty init
  */
  init = 
    at-last(Tl)

  /**
   * Splits a list into a tuple of its init list and last element.
   *
   * Example:
   *   <split-last> [1, 2, 3, 4] => ([1, 2, 3], 4)
   *   <split-last> [1]          => ([], 1)
   *
   * @since  0.9.4
   * @type   List(a) -> (List(a), a)
   * @inc    split-last
   */
  split-last =
      at-last(?[x]; ![])
    ; !(<id>, x)

 /**
  * @inc copy-test
  */
  copy = 
    for(\ (n,t) -> (n,t,[]) \
       ,\ (0,t,ts) -> ts \
       ,\ (n,t,ts) -> (<subt>(n,1), t, [t|ts]) where <geq>(n,1) \ )

  copy(s) = 
    for(\ (n,t) -> (n,t,[]) \
       ,\ (0,t,ts) -> ts \
       ,\ (n,t,ts) -> (<subt>(n,1), t, [<s> t|ts]) where <geq>(n,1) \ )

  thread-map(s) = 
    rec x(Cons^T(s, x) + Nil^T)

 /**
  * @inc number-test
  */
  number(s) =
    !(<id>, 0); thread-map(!(<s>,<Snd;inc>)); ?(<id>,_)

  take-while(s) = 
    at-suffix([] + ([not(s)|id];![]))

  take-until(s) = 
    at-suffix([] + ([s|id];![]))

  take(isn) = 
    where(isn => n)
    ; nzip0(id); take-until(?(n,_)); map(Snd)

  drop-while(s) = 
    at-suffix(([] + [not(s)|id]);?xs); !xs

  drop-until(s) = 
    at-suffix(([] + [s|id]);?xs); !xs


  /**
   * @warning  alias of split-fetch/1
   */
  split-at(s) = 
    split-fetch(s)

  drop(isn) = 
    where(isn => n)
    ; nzip0(id); drop-until(?(n,_)); map(Snd)

strategies
  /**
   * Trim elements from start and/or end of a list
   *
   * Removes the biggest sublist from the start and/or end of a list,
   * for which all elements satisfy the strategy s.
   *
   * @type  List(a) -> List(a)
   * @param should succeed for all elements that have to be trimmed.
   * @since 0.9.5
   * @inc   trim-test
   */

  rtrim(s) =
    ![()|<id>] // Add dummy element, or at-suffix-rev will fail at empty lists
  ; at-suffix-rev(
      where( not(?[])     // This only succeeds if we're not at list-end
           ; not([s|id])) // and s fails at the head of the current suffix
    ; ![<Hd>]) // s failed, no further trimming.
  ; Tl // Strip off dummy head element.

  /**
   * Note that ltrim is actually an alias for drop-while
   */
  ltrim(s) = drop-while(s)

  trim(s) = ltrim(s); rtrim(s)

strategies
  /** 
   * flatten-list completely flattens a list.
   * See list-misc-test for examples.
   * 
   * type in = a or [in]
   * flatten-list :: [in] -> [a]
   *
   * @inc flatten-test
   */
  flatten-list =
    foldr(![], (is-list, id) < conc + MkCons, is-list < flatten-list + id)

