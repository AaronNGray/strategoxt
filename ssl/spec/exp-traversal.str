/**
 * This module defines some experimental traversal schemes
 */

module exp-traversal
strategies

  allenv(f | env) = 
    all(f(|env))

  allacc(f | acc) :
    c#(ts) -> (c#(ts'), acc')
    where <mapacc(f | acc)> ts => (ts', acc')

  mapacc(f | acc) :
    [] -> []

  mapacc(f | acc1) :
    [x | xs] -> ([y | ys], acc3)
    where <f(|acc1)> x => (y, acc2)
	; <mappacc(f | acc2) xs => (ys, acc3) 

  /**
   * synthesize values on the way up
   *
   * @type f : a -> (a * b)
   * @type combine : List(b) -> b
   */
  allsyn(f, combine) :
    t@c#(ts) -> (c#(ts'), <combine> vals)
    where <zip(f)> ts => (ts', vals)

  topdown-generic(all : (a -> a) * b -> b, s) =
    s; all(topdown-generic(all, s))

  topdown-syn(s, combine) =
    let all(s) = allcombine(s, combine)
     in topdown-generic(all, s)
    end

  /**
   * synthesize values on the way up and use the original term
   * in the combination
   *
   * @type f : a -> a * List(b)
   * @type combine : a * List(b) -> List(b)
   */
  allpara(f, combine : a * List(b) -> b) :
    t@c#(ts) -> (c#(ts'), <combine(|t)> vals)
    where <zip(f)> ts => (ts', vals)
