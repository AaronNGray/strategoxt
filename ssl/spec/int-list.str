\literate[int-list]

	\begin{abstract}
	Operations on integer lists
	\end{abstract}


\begin{code}
module int-list
imports list integers
strategies

  sum = foldr(!0, add)

  average = split(sum, length); div

  list-min = list-accum(min)

  list-max = list-accum(max)

  list-accum(s) = !(<Tl>, <Hd>); foldl(s)

  add-lists = list-accum(zip(add <+ !""))

  averages = 
  { len: where(length => len);
    add-lists;
    map(try(sect(div, !len)))
  }

  round-list = map(test(sect(leq, !100)) <+ int)

  int-sort = sort-list(SortL(gt))

  is-interval-from = 
  rec r(
    \ (low,[]) -> low \
    <+ {l: \ (low,[x|xs]) -> <r>(x,xs)
           where <add>(low,1) => l
               ; <eq>(x,l)\ }
  )

/**
 * Generates lists of numbers.
 * 
 * The given end point is never part of the generated list; <range> 10 generates a list of 10 values, 
 * exactly the legal indices for items of a sequence of length 10. It is possible to let the range 
 * start at another number.
 *
 * <range> 10 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 * <range> (5, 10)     => [5, 6, 7, 8, 9]
 *
 * The documentation of the range strategy is partly copied from the Python tutorial.
 *
 * @type Int       -> [Int]
 * @type Int * Int -> [Int]
 * @since 0.9.3
 */
strategies

  range = is-int; <range> (0, <id>)
  range = (is-int, is-int); range(|1)

/**
 * Generates lists of numbers using a specified step size.
 *
 * These range variants use a specified increment. This step size is allowed
 * to be negative.
 *
 * <range(|3)>   10          => [0, 3, 6, 9]
 * <range(|3)>   (0, 10)     => [0, 3, 6, 9]
 * <range(|-30)> (-10, -100) => [-10, -40, -70]
 *
 * @type step Int
 * @type      Int       -> [Int]
 * @type      Int * Int -> [Int]
 * @since 0.9.3
 */
strategies

  range(|step) = is-int; <range(|step)> (0, <id>)
  range(|step) = (is-int, is-int); range(<add> (<id>, step))

/**
 * Generates lists of numbers using a 'next' generator.
 *
 *  <range(<mul> (<id>, 2))> 
 *
 * @type next Int -> Int
 *
 * @type      Int       -> [Int]
 * @type      Int * Int -> [Int]
 * @since 0.9.3
 */
strategies

  range(next) = is-int; <range(next)> (0, <id>)
  range(next) = (is-int, is-int); range-next(next) <+ ![]

  /**
   * @warning private helper strategy, do not use directly
   */
  range-next(inc) :
      (start, end) -> [start | tail]
        where <inc> start => next
            ; ( (<lt-lt>  (start, next, end) + <lt-lt>  (end, next, start))
              ; <range(inc)> (next, end)
             <+ (<lt-leq> (start, end, next) + <leq-lt> (next, end, start))
              ; ![]
              ) => tail

rules

  is-interval:
    [x|xs] -> (x,<is-interval-from>(x,xs))

\end{code}

% Copyright (C) 1998-2002 Eelco Visser <visser@acm.org>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
% 02111-1307, USA.