/**
 * A revised version of the pre-0.9.5 dynamic-rules-tools
 * Now using the new hash-tables, and implementing scoping
 * as a 'stack' of hashtables.
 */
module dynamic-rules-refactored

imports tables simple-list-traversal sets

signature
  constructors
    RuleScope : IndexedSet * Hashtable -> RuleScope
    ChangeSet : IndexedSet * Hashtable -> RuleScope

/**
 * Currently active rule set 
 */
strategies

  /**
   * @type  _ -> List(RuleScope)
   */
  dr-get-rule-set(|name) =
    <table-get> ("_rules", name) 
    <+ dr-new-rule-set
       ; dr-set-rule-set(|name)

  dr-set-rule-set(|name) =
    where(<table-put> ("_rules", name, <id>))

  dr-switch-rule-set(|name) =
    where(dr-get-rule-set(|name) => rs)
    ; dr-set-rule-set(|name)
    ; !rs

  // Note: the storing the currently active rule set should
  // be done in a global variable at the C level (probably).
  // We should abstract from that as much as possible and 
  // just consider the rule-set as a value that can be 
  // changed. Manipulating the content should be the same
  // for any storage solution we use.

  // a question to consider: should operations be relative
  // to the current rule-set or should we make a set of 
  // operations that work on a named rule-set and deal
  // with the pointer change at a higer-level?

  // Well, we can actually have two APIs, one working on
  // the implicit global rule-set, and the other working
  // on the explicit representation.

  // whose responsibility is it to initialize the outer scope?
  // In the definition above an initial hashtable is created
  // when no rule-set was available yet.

strategies // high-level API with implicit rule set
 
  // Note that the compiler can generate a specifically named
  // rule for each of the strategies in this API, e.g, 
  // add-rule-name, lookup-rule-name, etc. Then the compiler
  // can specialize the applications.

  dr-scope(s | name) = 
    dr-begin-scope(|name)
    ; (s < dr-end-scope(|name)
         + dr-end-scope(|name); fail)

  /**
   * @type  t -> t
   */
  dr-begin-scope(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-add-scope
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-end-scope(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-leave-scope
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-start-change-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-start-change-set
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-commit-change-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-commit-change-set
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-discard-change-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-discard-change-set
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-label-scope(|name, label) =
    where(
      dr-get-rule-set(|name)
      ; dr-label-scope(|label)
      ; dr-set-rule-set(|name)
    )

  dr-ignore-state(s|name) =
    where(
      dr-new-rule-set
      ; dr-switch-rule-set(|name) => rs
    )
  ; s
  ; where(<dr-set-rule-set(|name)> rs)

  dr-lookup-rule(|name, key) = 
    dr-get-rule-set(|name)
    ; dr-lookup-rule(|key)

  dr-lookup-rule-pointer(|name, key) = 
    dr-get-rule-set(|name)
    ; dr-lookup-rule-pointer(|key)

  dr-set-rule(|name, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|key, [value])
      ; dr-set-rule-set(|name)
    )

  dr-set-rule(|name, label, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|label, key, [value])
      ; dr-set-rule-set(|name)
    )

  dr-undefine-rule(|name, key) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|key, [])
      ; dr-set-rule-set(|name)
    )

  dr-undefine-rule(|name, label, key) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|label, key, [])
      ; dr-set-rule-set(|name)
    )

  dr-add-rule(|name, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-add-to-rule-set(|key, value)
      ; dr-set-rule-set(|name)
    )

  dr-add-rule(|name, label, key, value) =
    where(
      dr-get-rule-set(|name)
      //; debug(!"dr-add-rule1: ")
      ; dr-add-to-rule-set(|label, key, value)
      //; debug(!"dr-add-rule2: ")
      ; dr-set-rule-set(|name)
    )

  /**
   * Intersect live rule-set with given rule set changing the live rule set.
   */

  dr-intersect-with(|name) =
    <dr-intersect-rule-sets>(<dr-get-rule-set(|name)>, <id>)
    ; dr-set-rule-set(|name)

  /**
   * Intersect live rule-set with give rule set changing both.
   */
    
  dr-intersect-symm(|name) =
    <dr-intersect-rule-sets-symm>(<id>, <dr-get-rule-set(|name)>)
    ; dr-set-rule-set(|name)

  dr-union-with(|name) =
    <dr-union-rule-sets>(<dr-get-rule-set(|name)>, <id>)
    ; dr-set-rule-set(|name)

  dr-union-symm(|name) =
    <dr-union-rule-sets-symm>(<id>, <dr-get-rule-set(|name)>)
    ; dr-set-rule-set(|name)


// low-level API working directly on rule-set

strategies // debugging

  dr-save-rule-set =
    alltd(hashtable-getlist)

strategies // scope

  // a rule-set is represented by a list of (label list, hash-table) pairs

  dr-new-scope =
    !RuleScope(<new-iset; iset-add(|())>, <new-hashtable>)

  dr-new-rule-set =
    ![<dr-new-scope>]

  dr-add-scope = 
    ![<dr-new-scope> | <id>]

  dr-destroy-scope =
    RuleScope(iset-destroy, hashtable-destroy)

  dr-leave-scope :
    [scope | scopes] -> scopes
    where <dr-destroy-scope> scope

  dr-get-inner-scope :
    [scope | scopes] -> scope

  dr-label-scope(|label) =
    [ RuleScope(iset-add(|label), id)
      + ChangeSet(iset-add(|label), id)
    | id]
    // todo: distinction between rulescope and changeset necessary here or not??
//    [RuleScope(labels, tbl) | scopes] -> [RuleScope([label | labels], tbl) | scopes]

strategies // change sets
  
  dr-new-change-set =
    !ChangeSet(<new-iset>, <new-hashtable>)

  dr-start-change-set =
    ![<dr-new-change-set> | <id>]

  dr-destroy-change-set =
    ChangeSet(iset-destroy, hashtable-destroy)

  dr-commit-change-set :
    [cs@ChangeSet(labelset, tbl) | rs] -> rs'
    where <hashtable-keys> tbl
        ; foldr(<dr-commit-labels(|labelset)> rs, dr-apply-change(|tbl)) => rs'
        ; <dr-destroy-change-set> cs

  dr-discard-change-set :
    [cs@ChangeSet(_,_) | rs] -> rs
    where <dr-destroy-change-set> cs

  dr-commit-labels(|labelset) =
    [ ChangeSet(<iset-union> (<id>, labelset), id)
      + RuleScope(<iset-union> (<id>, labelset), id)
    | id]

  dr-apply-change(|tbl) :
    (key1@(scpid, key), rs) -> <dr-commit-to-rule-set(|scpid, key, <hashtable-get(|key1)> tbl)> rs

  // commit to ruleset is finding the first ChangeSet (any) *or* the first
  // RuleScope that has the appropriate scopeid (i.e. hashtable pointer)
  // and setting the key-value into it
  dr-commit-to-rule-set(|scpid, key, value) =
    fetch(
      dr-commit-to-change-set(|scpid, key, value)
    + dr-commit-to-rule-scope(|scpid, key, value))
  
  dr-commit-to-change-set(|scpid, key, value) = 
    ?ChangeSet(_, tbl)
  ; where(<hashtable-put(|(scpid, key), value)> tbl)

  dr-commit-to-rule-scope(|scpid, key, value) = 
    ?RuleScope(_,tbl@Hashtable(scpid))
  ; where(<hashtable-put(|key, value)> tbl)

  // note: labelings of current scope should be stored and committed as well.

strategies // looking up

  /**
   * Fetch the most recent definition for key.
   */

  dr-lookup-rule(|key) =
    dr-lookup-rule(fail | key)

  dr-lookup-rule(look | key) =
    ?[RuleScope(_, tbl@Hashtable(hptr)) | rs]
    ; (<look>(hptr, key)
       <+ <hashtable-get(|key)> tbl
       <+ <dr-lookup-rule(look | key)> rs)

  dr-lookup-rule(look1 | key) =
    ?[ChangeSet(_, tbl) | rs]
    ; let look2 = look1 <+ \ key' -> <hashtable-get(|key')> tbl \
       in <dr-lookup-rule(look2 | key)> rs
      end

  /**
   * Fetch the most recent definition for key and return a pointer
   * to the table that defines it.
   */

  dr-lookup-rule-pointer(|key) =
    dr-lookup-rule-pointer(fail | key)

  dr-lookup-rule-pointer(look | key) =
    ?[RuleScope(_, tbl@Hashtable(hptr)) | rs]
    ; (<look>(hptr, key)
       <+ <hashtable-get(|key)> tbl; !(<id>, key, tbl)
       <+ <dr-lookup-rule-pointer(look | key)> rs)

  dr-lookup-rule-pointer(look1 | key) =
    ?[ChangeSet(_, tbl) | rs]
    ; let look2 = look1 <+ \ key' -> <hashtable-get(|key'); !(<id>, key', tbl)> tbl \
       in <dr-lookup-rule-pointer(look2 | key)> rs
      end

strategies // setting a rule

  // A rule is always stored as a mapping from key to a list of values.
  // Setting a rule entails removing previous rules. 

  /**
   * set a rule in the inner scope 
   *
   * The inner scope has label () since all scopes are labeled
   * this way.
   */

  dr-set-in-rule-set(|key, value) = 
    dr-set-in-rule-set(|(), key, value)

  /**
   * set a rule in the scope with specified label
   */

  dr-set-in-rule-set(|label, key, value) =
    dr-set-in-rule-set(dr-set-fail | label, key, value)

  dr-set-fail(|scpid, tbl, key, value) =
    fail

  dr-set-in-rule-set(set : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm 
	   | label, key, value) =
    ?[RuleScope(labelset, tbl@Hashtable(hptr)) | rs]
    ; where(
        <iset-contains(|label)> labelset
        < (set(|hptr, tbl, key, value)
           <+ where(<hashtable-put(|key, value)> tbl))
        + <dr-set-in-rule-set(set | label, key, value)> rs
      )

  dr-set-in-rule-set(set1 : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm 
	   | label, key, value) =
    ?[ChangeSet(labelset, tbl1) | rs]
    ; where(
        let set2(|scpid, tbl2, key, value) =
              set1(|scpid, tbl2, key, value)
              <+ <hashtable-get(|key)> tbl2 => value
                 ; <hashtable-remove(|(scpid, key))> tbl1
              <+ <hashtable-put(|(scpid, key), value)> tbl1
         in if <iset-contains(|label)> labelset
            then <fetch-elem(?RuleScope(_,tbl@Hashtable(hptr)))> rs
                 ; set2(|hptr, tbl, key, value)
            else <dr-set-in-rule-set(set2 | label, key, value)> rs
            end
        end
      )
   

    // what to do if no scope with the label is defined?
    // currently this fails. This might default to adding to
    // the inner scope and labeling that inner scope as
    // well. However, that is quite expensive since
    // it would entail first going through all scopes to
    // establish non-existence of a label.

strategies // extending a rule

  // Extending a rule entails adding a value to the list of values 
  // corresponding to the key. The intended semantics is that all
  // these values are 

  dr-add-to-rule-set(|key, value) = 
    dr-add-to-rule-set(|(), key, value)

  /**
   * add a rule to the scope for label
   *
   * @assert: dr-add-to-rule-set(|l, k, v) 
   *               = set-rule(|l, k, [v | <lookup-rule(|l, k, v) <+ ![]>])
   */
  dr-add-to-rule-set(|label, key, value) =
    dr-add-to-rule-set(dr-add-fail | label, key, value)

  dr-add-fail(|scpid, tbl, key, value) =
    fail

  dr-add-to-rule-set(add : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm 
	     | label, key, value) =
    ?[RuleScope(labelset, tbl@Hashtable(hptr)) | rs]
    ; where(
        <iset-contains(|label)> labelset
        < (add(|hptr, tbl, key, value)
           <+ where(<hashtable-push(|key, value)> tbl))
        + <dr-add-to-rule-set(add | label, key, value)> rs
      )

  dr-add-to-rule-set(add1 : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm 
	     | label, key, value) =
    ?[ChangeSet(labelset, tbl1) | rs]
    ; where(
        let add2(|scpid, tbl2, key, value) =
              add1(|scpid, tbl2, key, value)
              <+ (<hashtable-get(|(scpid, key))> tbl1
                  <+ <hashtable-get(|key)> tbl2
                  <+ ![]) 
	         // check that value not yet member of this set????
                 ; \ values -> <hashtable-put(|(scpid, key), [value | values])> tbl1 \
         in if <iset-contains(|label)> labelset
            then <fetch-elem(?RuleScope(_,tbl@Hashtable(hptr)))> rs
                 ; add2(|hptr, tbl, key, value)
            else <dr-add-to-rule-set(add2 | label, key, value)> rs
            end
        end
      )

strategies // intersection

  /**
   * Intersection of two rule-sets
   *
   * assumption: the scope structure is the same
   * intersection works scope by scope 
   * note that labels are ignored
   */

  dr-intersect-rule-sets =
    eq < fail
    + (dr-intersect-rule-sets1  
       <+ dr-intersect-rule-sets2)

  dr-intersect-rule-sets1 :
    (rs@[RuleScope(labels1, tbl1) | rs1], [RuleScope(labels2, tbl2) | rs2]) -> rs
    where ior(<hashtable-intersect-wempty(|tbl2, [])> tbl1
  	     ,<dr-intersect-rule-sets> (rs1, rs2))

  dr-intersect-rule-sets2 :
    (rs@[ChangeSet(labels1, tbl1) | rs1], [ChangeSet(labels2, tbl2) | rs2]) -> rs
    where ior(<hashtable-intersect-wempty(|tbl2, [])> tbl1
  	     ,<dr-intersect-rule-sets> (rs1, rs2))
// todo: intersect labelsets as well!!

  /**
   * Symmetric intersection of two rule-sets
   *
   * assumption: the scope structure is the same
   * intersection works scope by scope 
   * note that labels are ignored
   */

  dr-intersect-rule-sets-symm =
    eq < fail
    + (dr-intersect-rule-sets-symm1  
       <+ dr-intersect-rule-sets-symm2)

  dr-intersect-rule-sets-symm1 :
    ([RuleScope(labels1, tbl1) | rs1], rs@[RuleScope(labels2, tbl2) | rs2]) -> rs
    where ior(<hashtable-intersect-symm-wempty(|[])> (tbl1, tbl2)
  	     ,<dr-intersect-rule-sets> (rs1, rs2))

  dr-intersect-rule-sets-symm2 :
    ([ChangeSet(labels1, tbl1) | rs1], rs@[ChangeSet(labels2, tbl2) | rs2]) -> rs
    where ior(<hashtable-intersect-symm-wempty(|[])> (tbl1, tbl2)
  	     ,<dr-intersect-rule-sets> (rs1, rs2))

     /* Note:
	First definition of intersection on rule-sets requires that
	entries have exactly the same value. Interesting point here:
	in the current data-flow application we have specialized
	intersections that don't require the rule-tags in the closures
	to be the same, since we know there that the rules are really
	the same.  We should achieve this by creating equal rule tags
	for equivalent rules.
     */

  /**
   * two-way split in data-flow (if-then-else) for list of rules
   */

  dr-fork-and-intersect(s1, s2 | rulenames) = 
    where(
      <map({?rulename
	    ; dr-get-rule-set(|rulename)
            ; !(rulename, <dr-start-change-set>)
            ; dr-start-change-set(|rulename)})> rulenames => rs1
    )
    // ; debug(!"before first branch: ")
    // ; dr-print-rule-sets(|rulenames)
    ; s1
    // ; debug(!"after first branch: ")
    // ; dr-print-rule-sets(|rulenames)
    ; where(
        <map({(?rulename,dr-switch-rule-set(|rulename))})> rs1 => rs2
      )
    ; s2
    // ; debug(!"after second branch: ")
    // ; dr-print-rule-sets(|rulenames)
    ; where(
        <map({?(rulename, <id>)
	      ; try(dr-intersect-with(|rulename))
              ; dr-commit-change-set(|rulename)})> rs2
      )
    // ; debug(!"after intersection: ")
    // ; dr-print-rule-sets(|rulenames)

  /**
   * n-way split in data-flow (case)
   */

  dr-fold-and-intersect(empty, hd, tl : (a -> a) * a -> a | rulenames) = 
    if empty then id 
    else
      where(<map(!(<id>, <dr-get-rule-set(|<id>)>))> rulenames => rs0)
      ; dr-fold-and-intersect(empty, hd, tl | rulenames, rs0)
      ; where(<map(dr-commit-change-set(|<id>))> rulenames)
    end

  dr-fold-and-intersect(empty, hd, tl : (a -> a) * a -> a | rulenames, rs0) = 
    if empty then id
    else
      where(
        <map({?(rulename,<id>)
              ; dr-start-change-set
              ; dr-set-rule-set(|rulename)})> rs0
      )
      ; hd
      ; where(
          <map(!(<id>, <dr-get-rule-set(|<id>)>))> rulenames => rs1
        )
      ; tl(dr-fold-and-intersect(empty, hd, tl | rulenames, rs0))
      ; where(
          <map({?(rulename, <id>); dr-intersect-with(|rulename)})> rs1
        )
    end
  
  /**
   * fork and intersect over a list 
   */

  dr-map-and-intersect(s | rulenames) = 
    let tl(s') = [id | s']
     in dr-fold-and-intersect([], [s|id], tl | rulenames)
    end

  /** 
   * loop in data-flow (while)
   */

  dr-fix-and-intersect(s | rulenames) =
    where(
      <map({?rulename
	    ; dr-get-rule-set(|rulename)
            ; !(rulename, <dr-start-change-set>)
            ; dr-start-change-set(|rulename)})> rulenames => rs
    ); 
    repeat(
      where(
	s 
        ; if <filter({?(rulename,<id>); dr-intersect-symm(|rulename)})> rs
	     ; [] 
          then ?e; fail // no changes in any of the rules
          else id       // some rule changed; continue
          end
      )
    ) 
    ; where(<map(dr-commit-change-set(|<id>))> rulenames)
    ; !e


strategies // union

  /**
   * Union of two rule-sets
   *
   * assumption: the scope structure is the same
   * union works scope by scope 
   * 
   */

  dr-union-rule-sets =
    eq < fail
    + (dr-union-rule-sets1
       <+ dr-union-rule-sets2)

  dr-union-rule-sets1 :
    (rs@[RuleScope(labels1, tbl1) | rs1], [RuleScope(labels2, tbl2) | rs2]) -> rs
    where ior(<hashtable-union(|tbl2)> tbl1
  	     ,<dr-union-rule-sets> (rs1, rs2))
// todo: unions 
  dr-union-rule-sets2 :
    (rs@[ChangeSet(labels1, tbl1) | rs1], [ChangeSet(labels2, tbl2) | rs2]) -> rs
    where ior(<hashtable-union(|tbl2)> tbl1
  	     ,<dr-union-rule-sets> (rs1, rs2))

  dr-union-rule-sets3 =
    ?([ChangeSet(labels1, tbl1) | rs1], [RuleScope(labels2, tbl2) | rs2])
    ; error

  dr-union-rule-sets3 =
    ?([RuleScope(labels2, tbl2) | rs2], [ChangeSet(labels1, tbl1) | rs1])
    ; error


  dr-union-rule-sets-symm =
    eq < fail
    + (dr-union-rule-sets-symm1  
       <+ dr-union-rule-sets-symm2)

  dr-union-rule-sets-symm1 :
    ([RuleScope(labels1, tbl1) | rs1], rs@[RuleScope(labels2, tbl2) | rs2]) -> rs
    where ior(<hashtable-union-symm-wempty(|[])> (tbl1, tbl2)
  	     ,<dr-union-rule-sets> (rs1, rs2))

  dr-union-rule-sets-symm2 :
    ([ChangeSet(labels1, tbl1) | rs1], rs@[ChangeSet(labels2, tbl2) | rs2]) -> rs
    where ior(<hashtable-union-symm-wempty(|[])> (tbl1, tbl2)
  	     ,<dr-union-rule-sets> (rs1, rs2))


  dr-fork-and-union(s1, s2 | rulenames) = 
    where(
      <map({?rulename
	    ; dr-get-rule-set(|rulename)
            ; !(rulename, <dr-start-change-set>)
            ; dr-start-change-set(|rulename)})> rulenames => rs1
    )
    // ; debug(!"before first branch: ")
    // ; dr-print-rule-sets(|rulenames)
    ; s1
    // ; debug(!"after first branch: ")
    // ; dr-print-rule-sets(|rulenames)
    ; where(
        <map({(?rulename,dr-switch-rule-set(|rulename))})> rs1 => rs2
      )
    ; s2
    // ; debug(!"after second branch: ")
    // ; dr-print-rule-sets(|rulenames)
    ; where(
        <map({?(rulename, <id>)
	      ; try(dr-union-with(|rulename))
              ; dr-commit-change-set(|rulename)})> rs2
      )
    // ; debug(!"after union: ")
    // ; dr-print-rule-sets(|rulenames)


  dr-fix-and-union(s | rulenames) =
    where(
      <map({?rulename
	    ; dr-get-rule-set(|rulename)
            ; !(rulename, <dr-start-change-set>)
            ; dr-start-change-set(|rulename)})> rulenames => rs
    ); 
    repeat(
      where(
        //  debug(!"before iteration: ")
        // ; dr-print-rule-sets(|rulenames);
	s 
        // ; debug(!"after iteration: ")
        // ; dr-print-rule-sets(|rulenames)
        ; if <filter({?(rulename,<id>); dr-union-symm(|rulename)})> rs
	     ; [] 
          then ?e; fail // no changes in any of the rules
          else id       // some rule changed; continue
          end
        // ; debug(!"after union: ")
        // ; dr-print-rule-sets(|rulenames)
      )
    )
    ; where(<map(dr-commit-change-set(|<id>))> rulenames)
    ; !e

strategies // rule-set equality

  dr-eq-rule-sets =
  let rseq =
        ?(RuleScope(lbl1, tbl1), RuleScope(lbl2, tbl2))
      ; <iset-eq> (lbl1, lbl2)
      ; <hashtable-eq> (tbl1, tbl2)
    +   ?(ChangeSet(lbl1, tbl1), ChangeSet(lbl2, tbl2))
      ; <iset-eq> (lbl1, lbl2)
      ; <hashtable-eq> (tbl1, tbl2)
   in where(zip(rseq))
  end



strategies // debugging

  dr-debug-rule-set(|name) = dr-debug-rule-set(|name, "")

  dr-debug-rule-set(|name, msg) =
    where(
        (!msg => "" <+ say(!msg))
      ; <debug(!"Ruleset for: ")> name
      ; dr-print-rule-set(|name)
    )

  dr-print-rule-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-print-rule-set
    )

  dr-print-rule-sets(|names) =
    where(
      <map(debug; dr-print-rule-set(|<id>))> names
    )

  dr-print-rule-set =
    where(map(dr-print-scope))

  dr-print-scope =
    ?RuleScope(labelset, tbl)
  ; where(
      debug
    ; <hashtable-keys> tbl
	  ; map(where(<printnl>(stderr, ["  ", <id>, " -> " ]))
          ; where(\ key -> <hashtable-get(|key)> tbl \
                  ; map(<printnl>(stderr, ["    ", <id>]))
                 )
         )
    )

  dr-print-scope =
    ?ChangeSet(labelset, tbl)
  ; where(
      debug
    ; <hashtable-keys> tbl
    ; map(where(<printnl>(stderr, ["  ", <id>, " -> "]))
          ; where(\ key -> <hashtable-get(|key)> tbl \
                  ; <printnl>(stderr, ["    ", <id>]))
         )
    )
