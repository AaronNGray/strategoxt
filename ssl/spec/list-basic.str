\literate[list-basic]

	\begin{abstract}

	Basic functionality on lists. 

	\end{abstract}

	Map: Apply strategy to each element of a list

	Length of a list

	Fetch: Find first list element for which s succeeds

	At tail: apply a strategy to the tail of a list

	At suffix: apply a strategy to some suffix of a list

\begin{code}
module list-basic
imports list-cons

strategies

  Hd     : [x | _] -> x
  Tl     : [_ | l] -> l
  Last   : [x] -> x

  // :: a -> [a]
  MkSingleton = ![<id>]

  // :: [a] -> a * [a]
  split-Cons : [x | xs] -> (x, xs)

  // :: a * [a] -> [a]
  MkCons : (x, xs) -> [x | xs]

strategies

  is-list = ?[] + ?[_ | _]

  map(s) = 
    rec x([] + [s | x]) 

  map1(s) = 
    [s | id]; [id | try(map1(s))] <+ [id | map1(s)]

  reverse-map(s) = 
    [id | reverse-map(s)]; [s | id] <+ []

  list(s) = 
    rec x([] + [s | x])

  list-some(s) =
    rec x([s| id] < [id| list(try(s))] + [id| x])

  list-some-filter(s) =
    rec x([s| id]; [id| filter(s)] <+ [id| x]; Tl)

  length = 
    foldr(!0, add, !1)

  /**
   * @type  a * [a] ->? _
   */
  elem = elem(eq)
  
  /**
   * @type eq  a * a ->? _
   * @type     a * [a] ->? _
   */
  elem(eq) =
    ?(x, <id>); one(where(<eq> (x, <id>)))

  fetch(s) = 
    rec x([s | id] <+ [id | x])

  fetch-elem(s) = 
    fetch(s;?x);!x

  /**
   * splits a list in two at the point where s succeeds.
   *
   * The element to which s was applied is not part of the result. split-fetch
   * fails if s cannot be applied to any of the elements.
   *
   * Examples:
   *   <split-fetch(\ 3 -> 6 \)> [1, 2, 3] => ([1,2], [])
   *   <split-fetch(\ 3 -> 6 \)> [2, 3, 4] => ([2], [4])
   *   <split-fetch(\ 3 -> 6 \)> [3, 4, 5] => ([], [4,5])
   *   not(<split-fetch(\ 3 -> 6 \)> [8, 7, 6])
   *
   * @type s  a ->? _
   * @type    [a] -> [a] * [a]
   */
  split-fetch(s) =
    at-suffix([s|id];[id|?tl];![]); !(<id>, tl)

  at-tail(s) = 
    [id | s]

  at_tail(s) = 
    obsolete(!"at_tail -> at-tail");
    at-tail(s)

  at-end(s) = 
    rec x([id | x] + []; s)
  at_end(s) = 
    obsolete(!"at_end -> at-end");
    rec x([id | x] + []; s)

  at-suffix(s) = 
    rec x(s <+ [id | x])
  at_suffix(s) = 
    obsolete(!"at_suffix -> at-suffix");
    rec x(s <+ [id | x])

  at-suffix-rev(s) = 
    rec x([id | x] <+ s)

  at_last(s) = 
    obsolete(!"at_last -> at-last");
    at-last(s)  

  at-last(s) = 
    rec x([id]; s <+ [id | x])

  split-init-last = 
    at-last(?[x]; ![]); !(<id>, x)

  at-init(s1, s2) =
    rec x([s2] <+ [s1 | x])

  listbu(s) = 
    rec x(([] + [id| x]); s)

  listbu1(s) = 
    [id| listbu1(s)]; try(s) <+ s

  listtd(s) = 
    rec x(s; ([] + [id| x]))

  listdu(s) =
    rec x(s; ([] + [id| x]); s)

  listdu2(s1, s2) = 
    rec x(s1; ([] + [id| x]); s2)

  RevInit : xs -> (xs, [])
  Rev     : ([x| xs], ys) -> (xs, [x| ys])
  RevExit : ([], ys) -> ys

  reverse = 
    reverse-acc(id, ![])

  reverse(s) = 
    reverse-acc(s, ![])

  reverse-acc(s, acc) : 
    [] -> <acc>()

  reverse-acc(s, acc) : 
    [x | xs] -> <{ys:where(![<s>x | <acc>] => ys); reverse-acc(s, !ys)}> xs

rules

  UptoInit : i -> (i, [])
  UptoExit : (i, xs) -> xs where <lt> (i, 0)
  UptoStep : (i, xs) -> (<subt> (i, 1), [i| xs])

strategies

  upto = UptoInit; rec x(UptoExit <+ UptoStep; x)

strategies

  // :: List(a) * -> List(a)
  conc =
    conc-two-lists <+ conc-more-lists

  // :: List(a) * List(a) -> List(a)
  conc-two-lists :
    (l1, l2) -> <at-end(!l2)> l1

  // :: List(a) * -> List(a)
  conc-more-lists :
    "" # (xs) -> <concat> xs

  // :: List(List(a)) -> List(a)
  concat =
    rec x([] + \ [l | ls] -> <at-end(<x> ls)> l\ )

strategies

  // :: a * List(b) -> List(a or b)
  separate-by :
    (a, xs) -> <[] + [id | rec x( [] + [id | x]; ![a | <id>])]> xs

  // _ -> a :: List(b) -> List(a or b)
  separate-by(s) = dissuader(!"separate-by/1; Use separate-by/0 and term wrap patterns: <separate-by> (a, <id>)");
    <separate-by> (<s> (), <id>)

  Sep(s) = obsolete(!"Sep/1; This is a private and obsolete util rule of separate-by");
    \ [x| xs] -> [<s>(), x | xs] \

strategies

  // :: [[a]] -> [[a]]
  matrix-transpose =
      map(?[]); ![]
    +   map(split-Cons)
      ; unzip
      ; (id, matrix-transpose)
      ; MkCons

  // <for-each-pair(s)>(xs, ys) produces the list of pairs <s>(x,y) 
  // for each pair of x from xs and y from ys.

  for-each-pair(s) =
    ?(xs, ys); <map(\ x -> <map(<s>(x,<id>))> ys \ )> xs
\end{code}

% Copyright (C) 1998-2002 Eelco Visser <visser@acm.org>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
% 02111-1307, USA.