/**
 * Hash tables support constant time storing and retrieving of 
 * values associated with keys. This module provides an interface
 * to the hash-table facility provided by the ATerm library.
 */
module tables
imports list

/**
 * Hashtable representations
 */
signature
  constructors
    Hashtable : ImplDep -> Hashtable

/**
 * Hashtable construction and deconstruction
 */
strategies

  new-hashtable =
    new-hashtable(|117,75)

  new-hashtable(|initial_size, max_load) =
    prim("SSL_hashtable_create", initial_size, max_load); !Hashtable(<id>)

  hashtable-destroy =
    ?Hashtable(tbl); prim("SSL_hashtable_destroy", tbl); !Hashtable(<id>)

/**
 * Hashtable operations
 */
strategies
  hashtable-put(|key, value) =
    ?Hashtable(tbl); prim("SSL_hashtable_put", tbl, key, value); !Hashtable(<id>)

  hashtable-get(|key) =
    ?Hashtable(tbl); prim("SSL_hashtable_get", tbl, key)

  hashtable-remove(|key) =
    ?Hashtable(tbl); prim("SSL_hashtable_remove", tbl, key); !Hashtable(<id>)
  
  hashtable-keys =
    ?Hashtable(tbl); prim("SSL_hashtable_keys", tbl)

/**
 * Hashtable bulk operations
 */
strategies

  /**
   * Gets the contents of a hashtable as a list of key-value tuples.
   */
  hashtable-getlist =
    ?htbl
  ; hashtable-keys
  ; map(\ x -> (x, <hashtable-get(|x)> htbl) \)

  /**
   * Puts a list of key-value tuples into a hashtable.
   */
  hashtable-putlist(|kv*) =
    ?htbl
  ; where(<map(\ (key, value) -> <hashtable-put(|key, value)> htbl \)> kv*)

  /**
   * Creates a new hashtable and copies the entire contents of the current
   * table into the new one.
   */
  hashtable-copy =
    hashtable-getlist => kv*
  ; new-hashtable(|<length>, 75)
  ; hashtable-putlist(|kv*)

/**
 * Stack operations (when stored values in hashtables are list-based stacks)
 */
strategies
  /**
   * pushes value on top of the stack for key.
   * Current term is the hashtable and remains untouched.
   */
  hashtable-push(|key, value) =
    hashtable-put(|key, [value | <hashtable-get(|key) <+ ![]>])

  /**
   * pushes values on top of the stack for key.
   * Current term is the hashtable and remains untouched.
   */
  hashtable-pushlist(|key, value) =
    hashtable-put(|key, <conc>(value, <hashtable-get(|key) <+ ![]>))

  /**
   * pushes union of values and already present values 
   * Current term is the hashtable and remains untouched.
   */
  hashtable-pushunion(|key, value) =
    hashtable-put(|key, <union>(value, <hashtable-get(|key) <+ ![]>))

  /**
   * pops off the top element of the stack for key.
   * Current term is the hashtable and remains untouched.
   */
  hashtable-pop(|key) =
    hashtable-put(|key, <hashtable-get(|key); Tl>)

  /**
   * Gets the top value from the stack for key (the stack remains untouched)
   * Current term is the hashtable, output is the top value.
   */
  hashtable-peek(|key) =
    hashtable-get(|key); Hd

  /**
   * Gets the top value from the stack for key and pops it off the stack.
   * Current term is the hashtable, output is the top value.
   */
  hashtable-peekpop(|key) =
    where(hashtable-peek(|key) => val)
  ; hashtable-pop(|key)
  ; !val

  /**
   * Intersect hashtables
   *
   * Changes tbl1; fails if no changes are made
   * Assumes that both hashtables contains lists as values, and intersects
   * the two listvalues for each key.
   */

  hashtable-intersect(|tbl2) = ?tbl1;
    where(

      hashtable-keys
      ; filter({key, val1, val2: 
          ?key
          ; <hashtable-get(|key)> tbl1 => val1
          ; <isect>(val1, <hashtable-get(|key) <+ ![]> tbl2) => val2
          ; not(?val1)
          ; <hashtable-put(|key, val2)> tbl1
        }) => changes1

      ; <hashtable-keys> tbl2
      ; filter({key, val1, val2: 
          ?key
          ; not(<hashtable-get(|key)>tbl1)
          ; <hashtable-put(|key, [])> tbl1
        }) => changes2

      ; (<not([])> changes1 <+ <not([])> changes2)

    )

  /**
   * Union of hashtables
   *
   * Changes tbl1; fails if no changes are made
   */

  hashtable-union(|tbl2) = ?tbl1;
    where(
      <hashtable-keys> tbl2
      ; filter({key, val1, val2 : 
          ?key
          ; <hashtable-get(|key) <+ ![]> tbl1 => val1
          ; <union>(<hashtable-get(|key)> tbl2, val1) => val2
          ; not(?val1)
          ; <hashtable-put(|key, val2)> tbl1
        })
      ; not([])
    )

/**
 * Legacy table strategies
 */
strategies

  /**
   * Retrieves the primitive table-table as a Hashtable
   */
  table-hashtable =
    prim("SSL_table_hashtable"); !Hashtable(<id>)

  /**
   * Retrieves a named table by looking it up in the table-table.
   */
  lookup-table(|name) =
    table-hashtable
  ; (  hashtable-get(|name)
    <+ where(<table-create> name); hashtable-get(|name))

 /**
  * Creates a table with a given name, which can be any term.
  */
  table-create = 
    ?name
  ; where(new-hashtable => htbl)
  ; where(table-hashtable; hashtable-put(|name, htbl))

 /**
  * Destroy a table with a given name, which can be any term.
  */
  table-destroy = 
    ?name
  ; where(table-hashtable
    ; where(lookup-table(|name)
          ; hashtable-destroy)
    ; hashtable-remove(|name)
    )

 /**
  * Associate a value with a key in a table. 
  *
  * E.g. <table-put> (t1, key, value) associates value with key in the t1 table.
  */
  table-put = 
  where(
    ?(name,key,value)
  ; lookup-table(|name)
  ; hashtable-put(|key, value)
  )

 /**
  * Get the value associated with a key from a table.
  * 
  * E.g. <table-get> (t1, key) yields the value associated to key or fails in the t1 table.
  */
  table-get = 
    ?(name,key)
  ; lookup-table(|name)
  ; hashtable-get(|key)

 /**
  * Remove association of a key in a table.
  *
  * E.g. <table-remove> (t1, key) removes the entry for key from table t1.
  */
  table-remove = 
  where(
    ?(name,key)
  ; lookup-table(|name)
  ; hashtable-remove(|key)
  )

 /**
  * Produce a list of keys of a table.
  *
  * E.g. <table-keys>t1 produces the list of keys of table t1.
  */
  table-keys = 
    ?name
  ; lookup-table(|name)
  ; hashtable-keys

 /**
  * Renames a table, i.e. only the entry in the table-table is renamed,
  * the table contents remain untouched.
  */
  table-rename =
    ?(from-name, to-name)
  ; where(lookup-table(|from-name) => htbl)
  ; table-hashtable
  ; hashtable-put(|to-name, htbl)
  ; hashtable-remove(|from-name)
  ; !to-name


strategies

 /**
  * Get a list of key-value pairs.
  *
  * E.g. <table-getlist>t1 produces the list of (key,value) pairs in the table t1. 
  */
  table-getlist = ?name; 
    table-keys; map(\ x -> (x, <table-get> (name, x))\ )

 /**
  * Put a list of key-value pairs in a table.
  *
  * E.g. <table-putlist>(name, list) puts the (key,value) pairs in list into table t1.
  */
  table-putlist = ?(name, list); 
    <map({x,y: ?(x, y); <table-put> (name, x, y)})> list

  table-putlist(s) = ?(name, list); 
    <map({x,y: ?(x, y); <s> (name, x, y)})> list

  table-copy = ?(name1, name2);
    where(<table-putlist>(name2, <table-getlist> name1)) 


/*
	Symbol tables that deal with scoped bindings need to be able
	to store multiple bindings for the same symbol. The following
	table operations can be used to maintain a stack (list)
	of values for each key.
*/

strategies

  table-push = ?(dis, key, val);
    where(<table-put>(dis, key, [val | <table-get <+ ![]>(dis, key)]))

  table-pop = ?(dis, key);
    where(<table-put>(dis, key, <table-get; Tl <+ ![]>(dis, key)))

  table-pop-rm = ?(dis, key);
    where(
      <table-get>(dis, key) => [_|xs]
      < <table-put>(dis, key, xs)
      + <table-remove>(dis, key)
    )

  table-pop-get = ?(dis, key);
    where( <table-get>(dis, key) => [val | vals]
         ; <table-put>(dis, key, vals)
         ); !val

  table-lookup = ?(dis, key);
    <table-get>(dis, key); Hd

  table-replace = ?(dis, key, value);
    where(<table-get>(dis, key) => [_|values]
         ; <table-put>(dis, key, [value|values])
         )

  table-union = ?(table, key, val);
    where(<set> (table, key, <union> (val, <get <+ ![]> (table, key))))

  table-diff = ?(table, key, val);
    where(<set> (table, key, <diff> (<get <+ ![]> (table, key), val)))

  table-append = ?(table, key, val);
    where(<set> (table, key, <union> (<get <+ ![]> (table, key), val)))

  set = table-put
  get = table-get


/*

Concrete syntax:

  |[ tbl . key := val  ]|	-> |[ <set>(tbl, key, val) ]|
  |[ tbl . key ]|		-> |[ <get>(tbl, key) ]|


  |[ tbl . key |= val  ]|	-> |[ <table-push>(tbl, key, val) ]|
?  |[ tbl . key ]|		-> |[ <table-pop>(tbl, key, val) ]|

  |[ tbl . key ++= val  ]|	-> |[ <table-append>(tbl, key, val) ]|

*/



/**
 * This strategy should no longer be used.
 */
strategies

  destroy-display = obsolete(!"destroy-display; use table-destroy"); 
		    table-destroy  
  create-display  = obsolete(!"create-display; use table-create");  
		    table-create
  display-lookup  = obsolete(!"display-lookup; use table-lookup");  
		    table-lookup
  display-replace = obsolete(!"display-replace; use table-replace"); 
		    table-replace
  display-pop     = obsolete(!"display-pop; use table-pop");     
		    table-pop
  display-push    = obsolete(!"display-push; use table-push");    
		    table-push
  push-set	  = obsolete(!"push-set; use table-push");        
		    table-push
  pop-get	  = obsolete(!"pop-get; use table-pop-get");         
		    table-pop-get
  union-set       = obsolete(!"union-set; use table-union");       
		    table-union
  diff-set        = obsolete(!"diff-set; use table-diff");        
		    table-diff
  create-table 	  = obsolete(!"create-table: use table-create"); 
		    table-create
  destroy-table   = obsolete(!"destroy-table: use table-destroy"); 
		    table-destroy


