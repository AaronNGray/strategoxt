/**
 * Hash tables support constant time storing and retrieving of 
 * values associated with keys. This module provides an interface
 * to the hash-table facility provided by the ATerm library.
 */
module tables
imports list

/**
 * Hashtable representations
 */
signature
  constructors
    Hashtable : ImplDep -> Hashtable

/**
 * Hashtable construction and deconstruction
 */
strategies

  new-hashtable =
    new-hashtable(|117,75)

  new-hashtable(|initial_size, max_load) =
    prim("SSL_hashtable_create", initial_size, max_load); !Hashtable(<id>)

  destroy-hashtable =
    ?Hashtable(tbl); prim("SSL_hashtable_destroy", tbl); !Hashtable(<id>)

/**
 * Hashtable operations
 */
strategies
  hashtable-put(|key, value) =
    ?Hashtable(tbl); prim("SSL_hashtable_put", tbl, key, value); !Hashtable(<id>)

  hashtable-get(|key) =
    ?Hashtable(tbl); prim("SSL_hashtable_get", tbl, key)

  hashtable-remove(|key) =
    ?Hashtable(tbl); prim("SSL_hashtable_remove", tbl, key)
  
  hashtable-keys =
    ?Hashtable(tbl); prim("SSL_hashtable_keys", tbl)

  hashtable-getlist =
    ?htbl
  ; hashtable-keys
  ; map(\ x -> (x, <hashtable-get(|x)> htbl) \)


/**
 * Legacy table strategies
 */
strategies

 /**
  * Creates a table with a given name, which can be any term.
  */
  table-create = 
    ?name; prim("SSL_table_create", name)

 /**
  * Destroy a table with a given name, which can be any term.
  */
  table-destroy = 
    ?name; prim("SSL_table_destroy", name)

 /**
  * Associate a value with a key in a table. 
  *
  * E.g. <table-put> (t1, key, value) associates value with key in the t1 table.
  */
  table-put = 
    where(?(table,key,value); prim("SSL_table_put",table,key,value))

 /**
  * Get the value associated with a key from a table.
  * 
  * E.g. <table-get> (t1, key) yields the value associated to key or fails in the t1 table.
  */
  table-get = 
    ?(table, key); prim("SSL_table_get",table,key)

 /**
  * Remove association of a key in a table.
  *
  * E.g. <table-remove> (t1, key) removes the entry for key from table t1.
  */
  table-remove = 
    where(?(table, key); prim("SSL_table_remove",table,key))

 /**
  * Produce a list of keys of a table.
  *
  * E.g. <table-keys>t1 produces the list of keys of table t1.
  */
  table-keys = 
    ?table; prim("SSL_table_keys",table)

  table-rename = ?(from-name, to-name);
    prim("SSL_table_rename", from-name, to-name)


strategies

 /**
  * Get a list of key-value pairs.
  *
  * E.g. <table-getlist>t1 produces the list of (key,value) pairs in the table t1. 
  */
  table-getlist = ?name; 
    table-keys; map(\ x -> (x, <table-get> (name, x))\ )

 /**
  * Put a list of key-value pairs in a table.
  *
  * E.g. <table-putlist>(name, list) puts the (key,value) pairs in list into table t1.
  */
  table-putlist = ?(name, list); 
    <map({x,y: ?(x, y); <table-put> (name, x, y)})> list

  table-putlist(s) = ?(name, list); 
    <map({x,y: ?(x, y); <s> (name, x, y)})> list

  table-copy = ?(name1, name2);
    where(<table-putlist>(name2, <table-getlist> name1)) 


/*
	Symbol tables that deal with scoped bindings need to be able
	to store multiple bindings for the same symbol. The following
	table operations can be used to maintain a stack (list)
	of values for each key.
*/

strategies

  table-push = ?(dis, key, val);
    where(<table-put>(dis, key, [val | <table-get <+ ![]>(dis, key)]))

  table-pop = ?(dis, key);
    where(<table-put>(dis, key, <table-get; Tl <+ ![]>(dis, key)))

  table-pop-rm = ?(dis, key);
    where(
      <table-get>(dis, key) => [_|xs]
      < <table-put>(dis, key, xs)
      + <table-remove>(dis, key)
    )

  table-pop-get = ?(dis, key);
    where( <table-get>(dis, key) => [val | vals]
         ; <table-put>(dis, key, vals)
         ); !val

  table-lookup = ?(dis, key);
    <table-get>(dis, key); Hd

  table-replace = ?(dis, key, value);
    where(<table-get>(dis, key) => [_|values]
         ; <table-put>(dis, key, [value|values])
         )

  table-union = ?(table, key, val);
    where(<set> (table, key, <union> (val, <get <+ ![]> (table, key))))

  table-diff = ?(table, key, val);
    where(<set> (table, key, <diff> (<get <+ ![]> (table, key), val)))

  table-append = ?(table, key, val);
    where(<set> (table, key, <union> (<get <+ ![]> (table, key), val)))

  set = table-put
  get = table-get


/*

Concrete syntax:

  |[ tbl . key := val  ]|	-> |[ <set>(tbl, key, val) ]|
  |[ tbl . key ]|		-> |[ <get>(tbl, key) ]|


  |[ tbl . key |= val  ]|	-> |[ <table-push>(tbl, key, val) ]|
?  |[ tbl . key ]|		-> |[ <table-pop>(tbl, key, val) ]|

  |[ tbl . key ++= val  ]|	-> |[ <table-append>(tbl, key, val) ]|

*/



/**
 * This strategy should no longer be used.
 */
strategies

  destroy-display = obsolete(!"destroy-display; use table-destroy"); 
		    table-destroy  
  create-display  = obsolete(!"create-display; use table-create");  
		    table-create
  display-lookup  = obsolete(!"display-lookup; use table-lookup");  
		    table-lookup
  display-replace = obsolete(!"display-replace; use table-replace"); 
		    table-replace
  display-pop     = obsolete(!"display-pop; use table-pop");     
		    table-pop
  display-push    = obsolete(!"display-push; use table-push");    
		    table-push
  push-set	  = obsolete(!"push-set; use table-push");        
		    table-push
  pop-get	  = obsolete(!"pop-get; use table-pop-get");         
		    table-pop-get
  union-set       = obsolete(!"union-set; use table-union");       
		    table-union
  diff-set        = obsolete(!"diff-set; use table-diff");        
		    table-diff
  create-table 	  = obsolete(!"create-table: use table-create"); 
		    table-create
  destroy-table   = obsolete(!"destroy-table: use table-destroy"); 
		    table-destroy


