/**
 * Strategies for handling command-line options.
 * 
 * Example:
 * ---------------------------------------------------------------------------
 * module option-demo
 * imports options
 *     
 * strategies
 *     
 *   main =
 *     io-wrap(demo-options, demo-usage, default-system-about, demo-impl)
 * 
 *   demo-impl = id
 * 
 *   demo-options =
 *       Option("--option1"
 *       , <set-config> ("--option1", ())
 *       , !"--option1        This is a an example option"
 *       )
 *     + ArgOption("--arg1"
 *       , <set-config> ("--arg1", <id>)
 *       , !"--arg1           This is an example arg option"
 *       )
 * 
 *   demo-usage =
 *     default-system-usage(
 *       !"Usage: option-demo [options]"
 *     , !
 * "   This is a test program to demonstrate use of
 *    parse-options and  generation of usage info
 *    from option and switch specificatios. These
 *    now contain usage info as additional third 
 *    argument."
 *     )
 * ---------------------------------------------------------------------------
 *
 * option-demo --help now displays:
 * ---------------------------------------------------------------------------
 * Usage: option-demo [options]
 * 
 * Options:
 *    --option1        This is a an example option
 *    --arg1           This is an example arg option
 *    -i f|--input f   Read input from f
 *    -o f|--output f  Write output to f
 *    -b               Write binary output
 *    -S|--silent      Silent execution (same as --verbose 0)
 *    --verbose i      Verbosity level i (default 1)
 *    -s               Turn on statistics
 *    --keep i | -k i  Keep intermediates (default 0)
 *    -h|-?|--help     Display usage information
 *    --about          Display information about this program
 *    --version        Same as --about
 * 
 * Description:
 *    This is a test program to demonstrate use of
 *    parse-options and  generation of usage info
 *    from option and switch specificatios. These
 *    now contain usage info as additional third
 *    argument.
 * ---------------------------------------------------------------------------
 */
module parse-options
imports lib config 
signature
  sorts Option
  constructors
    Program   : String  -> Option
    Undefined : String -> Option

strategies

  /**
   *  Always provide --help switch.
   */
  system-usage-switch = 
      Option("--help" + "-h" + "-?"
      , <set-config> ("--help", ()); !Help()
      , !"-h|-?|--help     Display usage information"
      )

  /**
   * Always provide the --about and --version switch.
   */
  system-about-switch = 
      Option( "--about"
      , <set-config> ("--about", ())
      , !"--about          Display information about this program"
      )
    + Option("--version"
      , where(<set-config> ("--about", ()); <set-config> ("-v",())); !Version()
      , !"--version        Same as --about"
      )

  /**
   * Invokes system-usage and system-about on help and about.
   */
  parse-options(s) =
    parse-options(s, system-usage, system-about)

  /**
   * Parse options. Add system-usage switch and display usage info when user
   * specified '-h' switch.
   */
  parse-options(s, usage, about) =
      where(<table-put>("usage-table", "usage", []))
    ; parse-options'(s <+ system-usage-switch <+ system-about-switch)
    ; try(
          where(<get-config> "--help" <+ option-defined(Help))
        ; usage
        ; <exit> 0
      <+  where(<get-config> "--about")
        ; about
        ; <exit> 0
      <+  option-defined(Undefined(?option))
        ; <printnl> (stderr(), ["Invalid option: ", option])
        ; usage
        ; <exit> 1
      )
    ; where(<table-destroy> "usage-table")

  /**
   * Register all usages of all defined switches; then parse switches as
   * specified by the user.
   */
  parse-options'(s)=
    where(try(<s> "register-usage-info"))
    ; [where(<set-config> ("program", <id>)); !Program(<id>)
      | rec x(([] + s; [id|x]) <+ UndefinedOption)]

  /**
   * Register useage info 's' by storing 's' in the table "usage-table".
   * Use fail, such that program execution continues with the next
   * alternative Option or ArgOption. This way we collect all usage info.
   */
  register-usage(s) = 
      <table-push>("usage-table", "usage", <s>())
    ; fail

  system-usage = 
    override-system-usage
    <+ default-system-usage

  system-about =
    override-system-about
    <+ default-system-about

  /**
   * No default long description. Overrule to include program description in usage info.
   */
  short-description(s) =  fail

  /**
   * No default short description. Overrule to include in usage info.
   */
  long-description(s) =  fail


  /**
   * No override of the default system usage.
   */
  override-system-usage = fail

  /**
   * No override of the default system about.
   */
  override-system-about = fail

  /**
   * Default system usage that invokes the short-description and long-description hook.
   */
  default-system-usage = 
    where(<get-config> "program" => p <+ option-defined(Program(?p)))
    ; default-system-usage(short-description(!p), long-description(!p))

  /**
   * Display usage info containing a short description of the program., if
   * defined, followed by the usages of all switches. Finally, the long
   * description of the program is displayed when it is defined.
   */
  default-system-usage(short, long) = 
    (<get-config> "program" => p <+ option-defined(Program(?p)))
    ; try(short; echo)
    ; <echo> "\nOptions:"
    ; <table-get; reverse> ("usage-table", "usage")
    ; map(<echo> ["   ", <id>])
    ; <echo> "\nDescription:"
    ; try(long; if is-string then ![<id>] end; echo)

  /**
   * Just shows the name of the program.
   */
  default-system-about =
    <get-config; echo> "program"

rules

  Option(is-flag, label, s) :
    [flag|rest] -> [<label>()|rest]
    where
      <is-flag> flag

  Option(is-flag, label) = 
    Option(is-flag, label, !"")

  /**
   * Registere usage info, when Option is applied to the term "register-usage-info"
   */
  Option(is-flag, label, s) =
     "register-usage-info"
     ; register-usage(s)

rules

  ArgOption(is-flag, label, s) :
  	[flag, arg | rest] -> [<label> arg | rest]
	where <is-flag> flag

  ArgOption(is-flag, label) =
    ArgOption(is-flag, label, !"")

  ArgOption(is-flag, label, s) =
    "register-usage-info"
    ; register-usage(s)
     
rules

  Arg2Option(is-flag, label) =
    Arg2Option(is-flag, label, !"")

  Arg2Option(is-flag, label, s) :
    [flag, arg1, arg2 | rest] -> [<label> (arg1, arg2) | rest]
    where
      <is-flag> flag

  Arg2Option(is-flag, label, s) =
    "register-usage-info"
    ; register-usage(s)

rules

  UndefinedOption :
	[x | rest] -> [Undefined(x) | rest]

strategies

  defined-option(s)   = fetch(s)
  option-defined(s)   = fetch(s)
  arg-option-value(s) = fetch(s)
