/**
 * Operations on strings
 */
module string
imports list conditional iteration char file

strategies // primitives

  new = prim("SSL_new")

  is-string	 = ?x; prim("SSL_is_string", x)

  /**
   * Implodes a list of chars to a string.
   *
   * @type [Char] -> String
   */
  implode-string = ?x; prim("SSL_implode_string", x)

  /**
   * Explodes a String to a list of chars.
   *
   * @type String -> [Char]
   */
  explode-string = ?x; prim("SSL_explode_string", x)   

  /**
   * Wraps a strategy on a list of chars in a strategy on a string.
   *
   * @type s [Char] -> [Char]
   * @type   String -> String
   */
  string-as-chars(s) =
      explode-string
    ; s
    ; implode-string

strategies
  
  /**
   * Concats a tuple of two Strings.
   *
   * @warning  doesn't accept tuples with more than two string.
   * @type     String * String -> String
   */
  conc-strings =
    strcat

  /**
   * Concats a tuple of two Strings.
   *
   * @warning  doesn't accept tuples with more than two string.
   * @type     String * String -> String
   * @inc      strcat-1
   * @inc      strcat-2
   * @inc      strcat-3
   * @inc      strcat-4
   */
  strcat =
    ?(str1, str2); prim("SSL_strcat", str1, str2)

  /**
   * Concats a list of Strings
   *
   * @type List(String) -> String
   * @inc      concat-strings-1
   * @inc      concat-strings-2
   * @inc      concat-strings-3
   * @inc      concat-strings-4
   */
  concat-strings =
    ?strings; prim("SSL_concat_strings", strings)

strategies

  /**
   * Returns the number of characters in a string.
   *
   * @type String -> Int
   */
  string-length =
    strlen

  /**
   * Returns the number of characters in a string.
   *
   * @type String -> Int
   * @inc      strlen-1
   * @inc      strlen-2
   * @inc      strlen-3
   */
  strlen =
    ?str; prim("SSL_strlen", str)

strategies

  /**
   * Escapes double quotes, backslash and linefeed to C like escape sequences.
   *
   * @type String -> String
   * @inc  escape-test1
   */
  escape = string-as-chars(escape-chars)

  /**
   * Escapes double quotes, backslash and linefeed to C like escape sequences.
   *
   * @type List(Char) -> List(Char)
   */
  escape-chars =
    escape-chars(Escape)

  escape-chars(s) = 
    rec x(
       (s; [id, id | x])
    <+ [id | x]
    <+ []
    )

  /**
   * Unescapes double quotes, backslash, linefeed and tabs.
   *
   * @type String -> String
   * @inc unescape-test1
   * @inc unescape-test2
   * @inc unescape-test3
   * @inc unescape-test4
   */
  unescape = string-as-chars(unescape-chars)

  /**
   * Unescapes characters using a specified unescape strategy.
   *
   * @param List(Char) -> List(Char)
   * @type  List(Char) -> List(Char)
   */
  unescape-chars(s) = 
    rec x(
      try(s)
    ; ([id | x] <+ [])
    )

  /**
   * Unescapes double quotes, backslash, linefeed and tabs.
   *
   * @type List(Char) -> List(Char)
   */
  unescape-chars = 
    unescape-chars(UnEscape)

  /**
   * @type List(Char) -> List(Char)
   */
  Escape =
      Escape-double-quote
    + Escape-backslash
    + Escape-linefeed
    + Escape-carriage-return

  Escape-double-quote    : ['"'  | cs ] -> ['\', '"'  | cs ]
  Escape-single-quote    : ['\'' | cs ] -> ['\', '\'' | cs ]
  Escape-backslash       : ['\'  | cs ] -> ['\', '\'  | cs ]
  Escape-linefeed        : ['\n' | cs ] -> ['\', 'n'  | cs ]
  Escape-carriage-return : ['\r' | cs ] -> ['\', 'r'  | cs ]

  /**
   * @type List(Char) -> List(Char)
   */
  UnEscape =
      UnEscape-double-quote
    + UnEscape-backslash
    + UnEscape-linefeed
    + UnEscape-tab
    + UnEscape-carriage-return

  UnEscape-double-quote    : ['\', '"'  | cs ] -> ['"'  | cs ]
  UnEscape-single-quote    : ['\', '\'' | cs ] -> ['\'' | cs ]
  UnEscape-backslash       : ['\', '\'  | cs ] -> ['\'  | cs ]
  UnEscape-carriage-return : ['\', 'r'  | cs ] -> ['\r' | cs ]
  UnEscape-linefeed        : ['\', 'n'  | cs ] -> ['\n' | cs ]
  UnEscape-tab             : ['\', 't'  | cs ] -> ['\t' | cs ]

  UnEscape(|c) :
    ['\', c | cs ] -> [c  | cs ]

strategies

  escape(esc : (List(String) -> List(String)) * List(String) -> List(String) ) = 
    explode-string;
    rec x(esc(x) <+ [id | x] <+ []);
    implode-string

 /**
  * @inc escape-test2
  */
  cify = escape(Cify)

  uncify = escape(UnCify)

  UnCify(x) = UnCify1(x) <+ UnCify2(x) <+ UnCify3(x)

rules

  Cify(x) : ['\'' | cs] -> ['_', 'p', '_' | <x>cs]
  Cify(x) : ['-'  | cs] -> ['_'           | <x>cs]
  Cify(x) : ['_'  | cs] -> ['_', '_'      | <x>cs]

  UnCify1(x) : ['_', 'p', '_' | cs] -> ['\'' | <x>cs]
  UnCify2(x) : ['_', '_'      | cs] -> ['_'  | <x>cs]
  UnCify3(x) : ['_'           | cs] -> ['-'  | <x>cs]

strategies // for quoting

  // _ -> Char :: String -> String
  quote(c) = string-as-chars(quote-chars(c))

  // _ -> Char :: List(Char) -> List(Char)
  quote-chars(c) = <quote-chars> (<c> (), <id>)

  // :: Char * List(Char) -> List(Char)
  quote-chars:
    (c, chars) -> <conc> ([c | chars], [c])

  // :: List(Char) -> List(Char)
  single-quote-chars = <quote-chars> ('\'', <id>)
  double-quote-chars = <quote-chars> ('"' , <id>)

 /**
  * @inc single-quote-test
  */
  single-quote = string-as-chars(single-quote-chars)
  double-quote = string-as-chars(double-quote-chars)


strategies // for unquoting

  /**
   * Removes the first and last character of a string.
   * The characters must satisfy s.
   *
   * @param s Char ->? _ 
   * @type String -> String
   */
  unquote(s) =
    string-as-chars(unquote-chars(s))

  /**
   * Removes the first and last character of a string.
   * The first character must satisfy s1.
   * The last character must satisfy s2.
   *
   * @param  Char ->? _ 
   * @param  Char ->? _ 
   * @type   String -> String
   */
  unquote(s1, s2) =
    string-as-chars(unquote-chars(s1, s2))

  /**
   * Removes the first and last character of a list of characters.
   * The characters must satisfy s.
   *
   * @param  Char ->? _ 
   * @type   List(Char) -> List(Char)
   */  
  unquote-chars(s) =
    unquote-chars(s, s)

  /**
   * Removes the first and last character of a list of characters.
   * The first character must satisfy s1.
   * The last character must satisfy s2.
   *
   * @param  Char ->? _ 
   * @param  Char ->? _ 
   * @type   List(Char) -> List(Char)
   */  
  unquote-chars(s1, s2) =
      where(Hd;   s1)
    ; where(last; s2)
    ; Tl
    ; init

  /**
   * @type  List(Char) -> List(Char)
   */
  un-single-quote-chars = unquote-chars(?'\'')
  un-double-quote-chars = unquote-chars(?'"' )

  /**
   * @type  String -> String
   */
  un-single-quote = string-as-chars(un-single-quote-chars)

 /**
  * @inc un-double-quote-test
  */
  un-double-quote = string-as-chars(un-double-quote-chars)

strategies 

 /**
  * @inc is-double-quote 1
  * @inc is-double-quote 2
  * @inc is-double-quote 3
  * @inc is-double-quote 4
  * @inc is-double-quote 5
  * @inc is-double-quote 6
  */
  is-double-quoted =  where(<is-quoted> ('"',  <id>))
  is-single-quoted =  where(<is-quoted> ('\'', <id>))

  // :: [Char] -> [Char]
  is-double-quoted-chars = where(<is-quoted-chars> ('"',  <id>))
  is-single-quoted-chars = where(<is-quoted-chars> ('\'', <id>))

  // :: Char * String -> Char * String
  is-quoted =
      (id, explode-string)
    ; is-quoted-chars

  // :: Char * [Char] -> Char * [Char]
  is-quoted-chars =
      where(
        ?(c, <id>)
      ; ?[c | <last>]; ?c
      )

strategies

  string-to-num =
    explode-string;
    split(!0, id);
    repeat(S2I2);
    ( S2I1
    + S2D0;
      repeat(S2D2);
      S2D1
    )

rules

  S2I1 : (n, [])         -> n

  S2I2 : (n, [m|ms]) -> (<add>(<mul>(10, n), <subt>(m, 48)), ms)
         where <geq>(m, 48); <leq>(m, 57)

  S2D0 : (n, [46|ys])  -> (n, 10, ys)

  S2D1 : (n, f, []) -> n

  S2D2 : (n, f, [m|ms]) -> 
	 (<add>(n, <div>(<subt>(m, 48), f)), <mul>(f, 10), ms)
         where <geq>(m, 48); <leq>(m, 57)

strategies 

 /**
  * @type  String -> String
  */
  lower-case = string-as-chars(lower-case-chars)

 /**
  * @inc upper-case-test
  */
  upper-case = string-as-chars(upper-case-chars)

  /**
   * @type  List(Char) -> List(Char)
   */
  lower-case-chars = map(to-lower)
  upper-case-chars = map(to-upper)

strategies

  /**
   * @obsolete  use to-lower
   */
  lc = obsolete(!"lc/0; use to-lower/0");
    to-lower

  /**
   * @obsolete  use to-upper
   */
  uc = obsolete(!"uc/0; use to-upper/0");
    to-upper

strategies

 /**
  * string-tokenize is like java.util.StringTokenizer. Given a
  * list of possible delimiters (characters that separate tokens)
  * it returns a list of tokens for a given string (the second
  * argument). See string-test for examples.
  *
  * @type  [Char] * String -> [String]
  * @inc   tokenize-test1
  * @inc   tokenize-test2
  * @inc   tokenize-test3
  * @inc   tokenize-test4
  * @inc   tokenize-test5
  */
  string-tokenize =
      (id, explode-string)
    ; ?(ws, <id>)
    ; list-tokenize(<elem> (<id>, ws))
    ; map(implode-string)

  // a -> fail? :: List(a) -> List(List(a))
  list-tokenize(s) =
      (split-fetch(s) <+ !(<id>, []))
    ; ( \ (  []     , [])        -> []   \
      + \ (l@[_ | _], [])        -> [l]  \
      + \ (  []     , l@[_ | _]) -> <list-tokenize(s)> l \
      + \ (t@[_ | _], l@[_ | _]) -> [t | <list-tokenize(s)> l] \
      )

strategies

  // _ -> Char :: String * Int -> String
 /**
  * @inc padd-with-test
  */
  padd-with(s) =
    <align-right> (<s> (), <Fst>, <Snd>)

  // :: Char * String * Int -> String
  align-right :
    (c, s, n) -> <conc-strings> (add, s)
      where <align-helper> (c, s, n) => add

  // :: Char * String * Int -> String
  align-left :
    (c, s, n) -> <conc-strings> (s, add)
      where <align-helper> (c, s, n) => add

  // :: Char * String * Int -> String
  align-center :
    (c, s, n) -> <concat-strings> [add-before, s, add-after]
      where <string-length> s => l
          ; <subt> (n, l) => whitespace
          ; <   even
              < div2; Dupl
              + dec; div2; Dupl; (inc, id)
            > whitespace => (before, after)
          ; <align-helper> (c, s, <add> (l, before)) => add-before
          ; <align-helper> (c, s, <add> (l, after )) => add-after

      // :: Char * String * Int -> String
      align-helper :
        (c, s, n) -> add
          where < string-length
                ; <subt> (n, <id>)
                ; (pos < <copy-char> (<id>, c) + !"")
                > s => add

      div2 = <div> (<id>, 2)

rules

  SplitInit : x -> ([], [], x)

  SplitExit : 
	(xs, cs, []) -> 
	<reverse> [<reverse; implode-string> cs|xs]

  SplitNext : 
	(xs, cs, [32|ys]) -> 
	([<reverse; implode-string> cs | xs], [], ys)

  SplitNext : 
	(xs, cs, [y|ys]) -> (xs, [y|cs], ys)
	where <not(eq)> (y, 32)

strategies

  split-at-space =
    explode-string;
    SplitInit;
    rec x(SplitExit <+ SplitNext; x)  

 /**
  * @inc split-at-dot-test
  */
  split-at-dot =
	  split(![],explode-string)
	; rec r(   \(int,[46|frac]) -> (int,frac)\ 
		<+ \(int,[i|rest])  -> <r>(<at-end(![i])>int,rest)\
		<+ (id,Nil))
	; (implode-string,implode-string)

  // fails if sub isn't in l
 /**
  * @inc split-before-test
  */
  split-before = ?(l,sub);
        <explode-string>sub => sub';
        <explode-string>l;
        \ x -> ([],x) \;
        rec r( \ x@(_,x') -> x where <left-match>(x',sub') \ <+
               \ (x',[x|xs]) -> <r>(<at-end(![x])>x',xs) \ );
	(implode-string,implode-string)

  // results in (l,"") if sub isn't in l
 /**
  * @inc split-after-test
  */
  split-after = ?(l,sub);
        <explode-string>sub => sub';
        <explode-string>l;
        \ x -> ([],x) \;
        rec r( (id,[]) <+
               \ (x,x') -> (<conc>(x,sub'),<left-match>(x',sub')) \ <+
               \ (x',[x|xs]) -> <r>(<at-end(![x])>x',xs) \ );
	(implode-string,implode-string)


  is-substring(s) = 
    explode-string;?long;
    s;explode-string => sub;

    (<eq>(sub,long) 
  <+
    <rec r({a,xs:
      ?a@[_|xs]; (<left-match>(a,sub) <+ <r>xs)
    })>long)

  // <copy-char> (3, 32) -> "   "
 /**
  * @inc copy-char-test
  */
  copy-char = 
    copy; implode-string

 /**
  * @inc string-sort-test-a
  * @inc string-sort-test-b
  * @inc string-sort-test-c
  */
  string-sort = 
      map(explode-string)
    ; sort-list(SortL(string-gt))
    ; map(implode-string)

  string-sort-desc = 
      map(explode-string)
    ; sort-list(SortL(string-lt))
    ; map(implode-string)

strategies

  /**
   * @type  (List(Char), List(Char)) -> 1
   * @type  (String, String)         -> 1
   */
  string-gt = 
    try((explode-string, explode-string));
    strcasecmp; ?1

  /**
   * @type  (List(Char), List(Char)) -> 1
   * @type  (String, String)         -> 1
   */
  string-lt = 
    try((explode-string, explode-string));
    strcasecmp; ?-1

  /**
   * Succeeds if the first String starts with the second String.
   *
   * If the strategy succeeds, the current is left untouched.
   *
   * @type  String -> String
   */
  string-starts-with(|start) =
    where(<left-match> (<explode-string>, <explode-string> start))

  /**
   * Succeeds if the first list of terms starts with the second list of terms.
   *
   * Returns the part that is left of the first list.
   *
   * @type  (List(a), List(a)) -> List(a)
   */
  left-match =
      rec r(
         \ ([l|ls],[l|rs]) -> <r> (ls,rs) \
      <+ (id,[])
      )
    ; Fst

 /**
  * @inc strcmp
  */
  strcmp = rec r(
       \([x|xs],[x|ys]) -> <r>(xs,ys)\
	  <+ \([],[]) -> 0\
	  <+ \([x|_],[y|_]) -> -1 where <lt>(x,y)\
	  <+ \([],[_|_]) -> -1\
      // these last two cases are handled faster by just !1
      //	<+ \([_|_],[]) -> 1\
      //	<+ \([x|_],[y|_]) -> 1\
	  <+ !1
	  )

  strncmp = rec r
	(  \(_,_,0) -> 0\
	<+ \([x|xs],[x|ys],i) -> <r>(xs,ys,<subt>(i,1))\
	<+ \([],[],_) -> 0\
	<+ \([x|_],[y|_],_) -> -1 where <lt>(x,y)\
	<+ \([],[_|_],_) -> -1\
	<+ !1
	)

  strcasecmp = rec r
	(  \([x|xs],[y|ys]) -> <r>(xs,ys) where <case-char(eq)>(x,y)\
	<+ \([],[]) -> 0\
	<+ \([x|_],[y|_]) -> -1 where <case-char(lt)>(x,y)\
	<+ \([],[_|_]) -> -1\
	<+ !1
	)

strategies

  sect(op, arg) = obsolete(!"sect/2; use term wrap patterns");
    <op> (<id>, <arg> ())
