\literate[string]

	\begin{abstract}
	This module defines some operations on strings, including
	conversions to and from numbers.
	\end{abstract}

\begin{code}
module string
imports list conditional iteration char

strategies // primitives

  new = prim("SSL_new")

  is-string	 = ?x; prim("SSL_is_string"     , x)
  implode-string = ?x; prim("SSL_implode_string", x)
  explode-string = ?x; prim("SSL_explode_string", x)   

strategies // concat
  
  // :: String * String -> String
  conc-strings =
      (explode-string, explode-string)
    ; conc
    ; implode-string

  // :: List(String) -> String
  concat-strings =
      map(explode-string)
    ; concat
    ; implode-string

strategies

  // :: String -> Int
  string-length =
      explode-string
    ; length

  // List(Char) -> List(Char) :: String -> String
  string-as-chars(s) =
      explode-string
    ; s
    ; implode-string

strategies // for escaping to C like escape sequences

  // :: String -> String
  escape = string-as-chars(escape-chars)

  // :: List(Char) -> List(Char)
  escape-chars = 
    rec x(
       (Escape; [id, id | x])
    <+ [id | x]
    <+ []
    )

  // :: String -> String
  unescape = string-as-chars(unescape-chars)

  // :: List(Char) -> List(Char)
  unescape-chars = 
    rec x(
      debug; try(UnEscape)
    ; ([id | x] <+ [])
    ; debug
    )

  // :: List(Char) -> List(Char)
  Escape =
      Escape-double-quote
    + Escape-backslash
    + Escape-linefeed

  Escape-double-quote    : ['"'  | cs ] -> ['\', '"'  | cs ]
  Escape-single-quote    : ['\'' | cs ] -> ['\', '\'' | cs ]
  Escape-backslash       : ['\'  | cs ] -> ['\', '\'  | cs ]
  Escape-linefeed        : ['\n' | cs ] -> ['\', 'n'  | cs ]
  Escape-carriage-return : ['\r' | cs ] -> ['\', 'r'  | cs ]

  UnEscape =
      UnEscape-double-quote
    + UnEscape-backslash
    + UnEscape-linefeed
    + UnEscape-tab

  UnEscape-double-quote    : ['\', '"'  | cs ] -> ['"'  | cs ]
  UnEscape-single-quote    : ['\', '\'' | cs ] -> ['\'' | cs ]
  UnEscape-backslash       : ['\', '\'  | cs ] -> ['\'  | cs ]
  UnEscape-carriage-return : ['\', 'r'  | cs ] -> ['\r' | cs ]
  UnEscape-linefeed        : ['\', 'n'  | cs ] -> ['\n' | cs ]
  UnEscape-tab             : ['\', 't'  | cs ] -> ['\t' | cs ]

strategies

  escape(esc : List(String) * (List(String) -> List(String)) -> List(String) ) = 
    explode-string;
    rec x(esc(x) <+ [id | x] <+ []);
    implode-string

  cify = escape(Cify)

rules

  Cify(x) : [39 | cs] -> [95, 112, 95 | <x>cs]
  Cify(x) : [45 | cs] -> [95          | <x>cs]
  Cify(x) : [95 | cs] -> [95, 95      | <x>cs]

strategies // for quoting

  // _ -> Char :: String -> String
  quote(c) = string-as-chars(quote-chars(c))

  // _ -> Char :: List(Char) -> List(Char)
  quote-chars(c) = <quote-chars> (<c> (), <id>)

  // :: Char * List(Char) -> List(Char)
  quote-chars:
    (c, chars) -> <conc> ([c | chars], [c])

  // :: List(Char) -> List(Char)
  single-quote-chars = <quote-chars> ('\'', <id>)
  double-quote-chars = <quote-chars> ('"' , <id>)

  // :: String -> String
  single-quote = string-as-chars(single-quote-chars)
  double-quote = string-as-chars(double-quote-chars)


strategies // for unquoting

  // Char -> fail? :: List(Char) -> List(Char)
  unquote-chars(s) =
      where(Hd;   s)
    ; where(last; s)
    ; Tl
    ; init

  // Char -> fail? :: String -> String
  unquote(s) =
    string-as-chars(unquote-chars(s))

  // :: List(Char) -> List(Char)
  un-single-quote-chars = unquote-chars(?'\'')
  un-double-quote-chars = unquote-chars(?'"' )

  // :: String -> String
  un-single-quote = string-as-chars(un-single-quote-chars)
  un-double-quote = string-as-chars(un-double-quote-chars)

strategies

  string-to-num =
    explode-string;
    split(!0, id);
    repeat(S2I2);
    ( S2I1
    + S2D0;
      repeat(S2D2);
      S2D1
    )

rules

  S2I1 : (n, [])         -> n

  S2I2 : (n, [m|ms]) -> (<add>(<mul>(10, n), <subt>(m, 48)), ms)
         where <geq>(m, 48); <leq>(m, 57)

  S2D0 : (n, [46|ys])  -> (n, 10, ys)

  S2D1 : (n, f, []) -> n

  S2D2 : (n, f, [m|ms]) -> 
	 (<add>(n, <div>(<subt>(m, 48), f)), <mul>(f, 10), ms)
         where <geq>(m, 48); <leq>(m, 57)

strategies 

  // :: String -> String
  lower-case = string-as-chars(lower-case-chars)
  upper-case = string-as-chars(upper-case-chars)

  // :: List(Char) -> List(Char)
  lower-case-chars = map(to-lower)
  upper-case-chars = map(to-upper)

strategies

  lc = obsolete(!"lc/0; use to-lower/0");
    to-lower

  uc = obsolete(!"uc/0; use to-upper/0");
    to-upper

strategies

  basename =
    basename(id)

  basename(ext) =
    explode-string;
    try(rec x([id|x] <+ [47|id] <+ [46 | ext]; ![]));
    implode-string

  guarantee-extension(ext) =
    basename;
    split(id, <ext>());
    add-extension

  // has-extension :: (_ -> String) -> String -> String
  //
  // has-extension(ext) checks whether the argument is a
  // string that ends in <ext>.

  has-extension(ext) =
    where(ext; explode-string => echars);
    where(explode-string; at-suffix(?echars))
  
  // path from program name "/usr/local/bin/prog" -> "/usr/local/bin/"
  get-path = 
    explode-string;
    (rec x([id|x] <+ [47|![]]) <+ ![]);
    implode-string

  add-extension : 
    (name, ext) -> <concat-strings> [name, ".", ext]

strategies

  split-at-space =
    explode-string;
    SplitInit;
    rec x(SplitExit <+ SplitNext; x)  

rules

  SplitInit : x -> ([], [], x)

  SplitExit : 
	(xs, cs, []) -> 
	<reverse> [<reverse; implode-string> cs|xs]

  SplitNext : 
	(xs, cs, [32|ys]) -> 
	([<reverse; implode-string> cs | xs], [], ys)

  SplitNext : 
	(xs, cs, [y|ys]) -> (xs, [y|cs], ys)
	where <not(eq)> (y, 32)

strategies

  split-at-dot =
	  split(![],explode-string)
	; rec r(   \(int,[46|frac]) -> (int,frac)\ 
		<+ \(int,[i|rest])  -> <r>(<at-end(![i])>int,rest)\
		<+ (id,Nil))
	; (implode-string,implode-string)

  padd-with(s) = ?(str,n);
    !str;
    explode-string => str';
    length => l;
    (<geq>(l,n);!str <+
     <subt>(n,l);
     rec r(\0 -> []\ <+ \n -> [<s>()|<subt;r>(n,1)]\);
     \padd -> (padd,str')\;
     conc;
     implode-string
    )

// fails if sub isn't in l
  split-before = ?(l,sub);
        <explode-string>sub => sub';
        <explode-string>l;
        \ x -> ([],x) \;
        rec r( \ x@(_,x') -> x where <left-match>(x',sub') \ <+
               \ (x',[x|xs]) -> <r>(<at-end(![x])>x',xs) \ );
	(implode-string,implode-string)

  // results in (l,"") if sub isn't in l
  split-after = ?(l,sub);
        <explode-string>sub => sub';
        <explode-string>l;
        \ x -> ([],x) \;
        rec r( (id,[]) <+
               \ (x,x') -> (<conc>(x,sub'),<left-match>(x',sub')) \ <+
               \ (x',[x|xs]) -> <r>(<at-end(![x])>x',xs) \ );
	(implode-string,implode-string)

  left-match =
    rec r(
        {l,ls,rs:?([l|ls],[l|rs]); <r>(ls,rs)} <+
        (id,[]) );
    Fst

  is-substring(s) = 
    explode-string;?long;
    s;explode-string => sub;

    (<eq>(sub,long) 
  <+
    <rec r({a,xs:
      ?a@[_|xs]; (<left-match>(a,sub) <+ <r>xs)
    })>long)

  // <copy-char> (3, 32) -> "   "
  copy-char = 
    copy; implode-string

  string-sort = 
      map(explode-string)
    ; sort-list(SortL(string-gt))
    ; map(implode-string)

  string-sort-desc = 
      map(explode-string)
    ; sort-list(SortL(string-lt))
    ; map(implode-string)

  // in: a binary tuple of exploded strings (==list of ASCII numbers)
  // but two strings can also be given.
  string-gt = 
    try((explode-string, explode-string));
    strcasecmp; ?1

  string-lt = 
    try((explode-string, explode-string));
    strcasecmp; ?-1

  strcmp = rec r
	(  \([x|xs],[x|ys]) -> <r>(xs,ys)\
	<+ \([],[]) -> 0\
	<+ \([x|_],[y|_]) -> -1 where <lt>(x,y)\
	<+ \([],[_|_]) -> -1\
// these last two cases are handled faster by just !1
//	<+ \([_|_],[]) -> 1\
//	<+ \([x|_],[y|_]) -> 1\
	<+ !1
	)

  strncmp = rec r
	(  \(_,_,0) -> 0\
	<+ \([x|xs],[x|ys],i) -> <r>(xs,ys,<subt>(i,1))\
	<+ \([],[],_) -> 0\
	<+ \([x|_],[y|_],_) -> -1 where <lt>(x,y)\
	<+ \([],[_|_],_) -> -1\
	<+ !1
	)

  strcasecmp = rec r
	(  \([x|xs],[y|ys]) -> <r>(xs,ys) where <case-char(eq)>(x,y)\
	<+ \([],[]) -> 0\
	<+ \([x|_],[y|_]) -> -1 where <case-char(lt)>(x,y)\
	<+ \([],[_|_]) -> -1\
	<+ !1
	)

strategies

  sect(op, arg) = obsolete(!"sect/2; use term wrap patterns");
    <op> (<id>, <arg> ())

\end{code}

% Copyright (C) 1998-2002 Eelco Visser <visser@acm.org>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
% 02111-1307, USA.
