\literate[options]
\begin{code}
module options
imports io parse-options config time verbose keep

\end{code}

	The operator \verb|io-wrap| defines a default wrapper around a
	strategy that handles processing of options and reading and
	writing of terms from and to files.

\begin{code}
strategies

  io-wrap(s) = 
    io-wrap(fail, s)

  io-wrap(extra-opts, s) =
    option-wrap(extra-opts <+ io-options,  io(s))

  output-wrap(s) =
    output-wrap(fail, s)

  output-wrap(extra-opts, s) =
    option-wrap(extra-opts <+ output-options,  output(s))

  input-wrap(s) =
    input-wrap(fail, s)

  input-wrap(extra-opts, s) =
    option-wrap(extra-opts <+ input-options,  input(s))

\end{code}

	The operator \verb|io| defines a wrapper that handles 
  reading and writing of terms from and to files defined
  by \verb|-i| and \verb|-o| config.

\begin{code}
strategies

  io(s) =
    input(output(s))

  output(s) =
      s
    ; !(<<get-config> "-o" <+ !stdout()>, <id>)
    ; ( where(<get-config> "-b") < WriteToBinaryFile + WriteToTextFile )

  input(s) =
      ( <get-config> "-i" <+ !stdin() )
    ; ReadFromFile
    ; s

strategies

  // OPTION-WRAP
  // read options, display help, report success or failure, call strategy

  option-wrap(opts, usage, announce, s) =
    parse-options(opts)
    ; store-options
    ; announce
    ; (  need-help(usage)
      <+ s; report-success
      <+ report-failure)
  /**
   * TODO: parse-options already does need-help. Remove it from
   * parse-options or remove it here
   */

  option-wrap(opts, s) =
    option-wrap(opts, default-usage, id, s)

\end{code}

	Handling of options

\begin{code}
strategies

  io-options =
      input-option
    + aterm-output-option
    + general-options

  input-options =
      input-option
    + general-options

  output-options =
      aterm-output-option
    + general-options

  general-options =
      verbose-option
    + keep-option
    + version-option

  keep-option =
    ArgOption("-k" + "--keep"
    , where(<set-config> ("--keep", <string-to-int>))
    , !"--keep i | -k i  Keep intermediates (default 0)"
    )

  version-option =
    Option("-v"+"--version"
    , where(<set-config> ("-v",())); !Version()
    , !"-v|--version     Display prgram's version"
    )

  input-option =
    ArgOption("-i" + "--input"
    , where(<set-config> ("-i",<id>)); !Input(<id>)
    , !"-i f|--input f   Read input from f"
    )

  output-option =
    ArgOption("-o" + "--output"
    , where(<set-config> ("-o",<id>)); !Output(<id>)
    , !"-o f|--output f  Write output to f" 
    )

  aterm-output-option =
      output-option
    + Option("-b"
      , where(<set-config> ("-b",())); !Binary()
      , !"-b               Write binary output"
      )

  verbose-option =
      Option("-S"+"--silent"
      , where(<set-config> ("--verbose",0)); !Verbose(0)
      , !"-S|--silent      Silent execution (same as --verbose 0)"
      )
    + ArgOption("--verbose"
      , where(<set-config> ("--verbose",<string-to-int>)); !Verbose(<id>)
      , !"--verbose i      Verbosity level i (default 1)"
      )
    + Option("-s"
      , where(<set-config> ("-s",())); !Statistics()
      , !"-s               Turn on statisctics"
      )

strategies

  default-usage =
    where(
      <printnl> (stderr, 
        ["usage : ", <whoami> (), " [-S] [-i file] [-o file] [-b] [-s] [--help|-h|-?]" ]
      )
    ; <exit> 1
    )

  need-help(u) =
    (  <get-config> "--help"
    <+ option-defined(
         Help()
       + Undefined(id)
       + Version()
       )
    ); u

  need-help =
    need-help(default-usage)

  if-not-silent(s) =
    test(verbosity => 0) <+ s

  report-success =
      report-run-time
    ; <exit> 0

  report-failure =
      report-run-time
    ; <printnl> (stderr, [<whoami> (), ": rewriting failed"])
    ; <exit> 1

  report-run-time = 
    if-verbose1(
      <printnl> (stderr,
        [<whoami> (), " (", <run-time>, " secs)"]
      )
    )

  whoami =
    <get-config> "program"

\end{code}

	WARNING: The following strategies and signatures are all deprecated

\begin{code}

signature
  constructors
    Silent      : Option
    Verbose     : Int -> Option
    Version     : Option
    Input       : String -> Option
    Output      : String -> Option
    Binary      : Option
    Statistics  : Option
    Help        : Option
    Runtime     : Real   -> Option
    DeclVersion : String -> Option

strategies

  // IOWRAP
  // handle options, read term from input file, transform, write result 
  // to output file

  iowrap(strat) = 
    iowrap((id, strat), fail)

  iowrapO(strat, extra-options) =
    obsolete(!"iowrapO/2: use iowrap/2");
    iowrap(strat, extra-options)

  iowrap(strat, extra-options) = 
    iowrap(strat, extra-options, default-usage)

  iowrap(strat, extra-options, usage) = 
    iowrap(strat, extra-options, usage, 
	   if-verbose2(where(<printnl>(stderr, [<get-config> "program"]))))

  iowrapO(strat, extra-options, usage) =
    obsolete(!"iowrapO/3: use iowrap/3");
    iowrap(strat, extra-options, usage)

  iowrap(strat, extra-options, usage, announce) =
    option-wrap(extra-options <+ io-options, usage, announce, 
      input-file;
      apply-strategy(strat);
      output-file
    )

  iowrapNoOutput(strat, extra-options) = 
    iowrapNoOutput(strat, extra-options, default-usage)

  iowrapNoOutput(strat, extra-options, usage) =
    option-wrap(extra-options <+ io-options, usage, id, 
      input-file;
      apply-strategy(strat)
    )

strategies

  // storing and retrieving options in a table
  // obsolete; use config for this purpose

  store-options = ?options;
    where( 
      <table-create>"option-table";
      <table-put>("option-table", "options", options)
    )

  get-options =
    <table-get>("option-table", "options")

  has-option(s) =
    test(<s; check-option>())

  option-value(s,default) =
    get-options; fetch-elem(s) <+ default

  check-option: option -> ()
    where get-options => ops
        ; <is-subterm>(option,ops)

  usage' = 
    obsolete(!"usage': use default-usage")

strategies

  // Input, strategy application and output

  input-file' =
	obsolete(!"input-file'; use input-file");
	input-file

  input-file =
	 where((option-defined(?Input(infile)) <+ !stdin => infile));
  	 split(id, <ReadFromFile> infile)

  apply-strategy(strat) =
   	 where(dtime);
   	 strat;
   	 where(dtime => runtime);
	 \(options, trm) -> ([Runtime(runtime) | options], trm)\

  output-file' =
	obsolete(!"output-file'; use output-file");
	output-file

  output-file =
	 where((option-defined(?Output(outfile)) <+ !stdout => outfile, id)); 
	 (id, split(!outfile, id));
   	 ((option-defined(?Binary()), WriteToBinaryFile)
	  <+ (id, WriteToTextFile))

/*
module option-demo
imports options

strategies

main =
   iowrap(id, 
          Option("--option1",
                 id, 
                 !"--option1        This is a an example option")
         +ArgOption("--arg1", 
                 id, 
                 !"--arg1           This is an example arg option"))

// Optional short description
short-description(p) = !["Usage: ", <p>(), " [options]"]   

// Optional long description
long-description(p) = !["This is a test program to demonstrate use of ",
                        "parse-options and  generation of usage ",
                        "info from option and switch specificatios. ",
                        "These now contain usage info as additional ",
                        "third argument."]
*/

\end{code}
% Copyright (C) 1998-2002 Eelco Visser <visser@acm.org>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
% 02111-1307, USA.