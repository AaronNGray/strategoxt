/**
 * The file module provides abstractions over the basic file system
 * operations in the module posix-file.
 */
module file
imports posix-file io list string

/**
 * Abstractions for streams
 */
strategies

  /**
   * opens a Stream associated to a FileLoc
   *
   * @type FileLoc * String -> Stream
   */
  open-stream = ?(_, _);
    (  Fst; stdio-stream
    <+ (?Path(<id>), id); fopen
    <+ (is-string,   id); fopen
    )

  /**
   * @type FileLoc -> Stream
   */
  stdio-stream = ?stdin() ; stdin-stream
  stdio-stream = ?stdout(); stdout-stream
  stdio-stream = ?stderr(); stderr-stream

/**
 * Old file administration
 */
strategies

  close-file = 
    ?name; prim("SSL_close_file", name)

  open-file =
    ?(name, mode); prim("SSL_open_file", name, mode)

  /**
   * @obsolete use <open-file> (file, mode)
   */
  open-file =
    ?name; not(?(_, _))
    ; obsolete(!"<open-file> file; use <open-file> (file, mode)")
    ; <open-file> (name, "w")

  append-file = 
    <open-file> (<id>, "a")

strategies

  /**
   * @type  String -> String
   */
  file-exists =
    <access> (<id>, [F_OK()])

  /**
   * @type  String -> String
   */
  can-read-file =
    <access> (<id>, [R_OK()])

  is-readable = can-read-file

  /**
   * @type  String -> String
   */
  can-write-file =
    <access> (<id>, [W_OK()])

  is-writable = can-write-file

  /**
   * @type  String -> String
   */
  can-execute-file =
    <access> (<id>, [X_OK()])

  is-executable = can-exutable-file

  /**
   * @type String -> String
   */
  can-create-file =
    where(dirname; can-write-file)

/**
 * Components of a pathname
 */
strategies

  /**
   * Returns directory portion of pathname in a POSIX compatible way.
   *
   * @type String -> String
   */
  dirname =
    string-as-chars(
      /* (1) Strip trailing slashes */
      try(split-init-last; ?(<id>, '/'))
    ; /* (2) If string consists entirely of slash characters, string shall be
             set to a single slash character.  In this case, skip steps (3)
             through (8). */
    ( ?[]
      < !['/']
      + ( /* (3) If there are any trailing slash characters in string, they
                 shall be removed. */
          init
          /* (4) If there are no slash characters remaining in string, string
                 shall be set to a single period character.  In this case, skip
                 steps (5) through (8).

             (5) If there are any trailing nonslash characters in string,
                 they shall be removed. */

        ; repeat(split-init-last; (id, not(?'/')); Fst)
        ; (?[]
          < !['.']
          + ( /* (7) If there are any trailing slash characters in string, they
                   shall be removed. */
              repeat(split-init-last; ?(<id>, '/'))
            ; (?[] < !['/'] + id))))))

strategies

  /**
   * Strip extension from filename.
   *
   * @type  String -> String
   */
  basename =
    basename(id)

  /**
   * Strip directory and extension from filename.
   *
   * @param  checks the extension
   * @type   String -> String
   */
  basename(ext) =
    explode-string;
    try(rec x([id|x] <+ ['/' | id] <+ ['.' | ext]; ![]));
    implode-string

  guarantee-extension(ext) =
    basename;
    split(id, <ext>());
    add-extension

  // has-extension :: (_ -> String) -> String -> String
  //
  // has-extension(ext) checks whether the argument is a
  // string that ends in <ext>.

  has-extension(ext) =
    where(ext; explode-string => echars);
    where(explode-string; at-suffix(?echars))
  
  // path from program name "/usr/local/bin/prog" -> "/usr/local/bin/"
  get-path = 
    explode-string;
    (rec x([id|x] <+ [47|![]]) <+ ![]);
    implode-string

  // file name from path "/usr/local/bin/prog" -> "prog"
  get-filename = 
    explode-string
    ; try(at-suffix-rev(?['/' | name]); !name)
    ; implode-string

  // :: String * String -> String
  add-extension : 
    (name, ext) -> <concat-strings> [name, ".", ext]

  // :: String -> String
  remove-extension =
      <string-tokenize> (['.'], <id>)
    ; init
    ; <separate-by> (".", <id>)
    ; concat-strings

  /**
   * Get extension from filename
   *
   * @type   String -> String
   */
  get-extension =
    <string-tokenize> (['.'], <id>)
    ; last

/**
 * Generate a new, not existing file name.
 */
strategies

  new-file =
    rec x(<conc-strings> (<new>(), ".tmp"); try(file-exists; x))

  // (String, a) -> b :: a -> b
  temp-file(s) =
      where(new-file => f)
    ; <finally(s, try(<remove-file> f))> (f, <id>)

  /**
   * Safe, mkstemp based, creation of temporary file
   * 
   * :: _ -> (String, FileDescr)
   */
  new-temp-file =
      <conc-strings> (<temp-dir>, "/StrategoXT")
    ; mkstemp

/**
 * find files in paths
 */
strategies

  find-in-path =
    ?(file, <id>) 
    ; fetch-elem(<concat-strings; file-exists> [<id>,"/",file])

  find-in-path(mkpath) =
    file-exists 
    <+ split(id, mkpath); find-in-path
    <+ <fatal-error> ["no such file: ", <id>]

  find-file(mkpath, ext) =
    guarantee-extension(ext)
    ; find-in-path(mkpath)

  find-file(ext) =
    (guarantee-extension(ext), id)
    ; find-in-path
