/**
 * Replaces some constructs in a Stratego program by LaTeX macro invocations.
 *
 * Layout is preserved.
 * The result is to be used in an alltt environment.
 *
 * @author  Martin Bravenboer <martin@cs.uu.nl>
 */
module pp-stratego-latex-alltt
imports liblib parse-cs-lib AsFix

strategies

  io-pp-stratego-latex-alltt =
    xtc-io-wrap(
      syntax-option + include-options
    , pp-stratego-latex-alltt
    )

  pp-stratego-latex-alltt =
      pcs-input-file
    ; init-language-binding
    ; pcs-parse-asfix2me
    ; xtc-io-transform(to-latex-alltt)
    ; xtc-asfix2me-yield

  xtc-asfix2me-yield =
    xtc-transform(!"unparsePT")

  to-latex-alltt =
      escape-alltt-special-chars
    ; topdown(try(CheerUp))

  escape-alltt-special-chars =
    alltd(lit(string-as-chars(
      escape-chars(
        latex-escape-backslash
      + latex-escape-curly
      )
    )))

  latex-escape-backslash :
    ['\'  | cs ] -> ['\', 'c', 'h', 'a', 'r', '9', '2' | cs ]

  latex-escape-curly :
    ['{'  | cs ] -> ['\', '{' | cs ]

  latex-escape-curly :
    ['}'  | cs ] -> ['\', '}' | cs ]

strategies

  /**
   * Meta variable
   */
  CheerUp =
    appl(prod([varsym(id)], id, id), map(try(FancyVar)))

  CheerUp =
    appl(prod(id, varsym(id), id), map(try(FancyVar)))

  CheerUp =
    appl(
        check-cons-of-prod(?"Var")
      ; check-sort-of-prod(?"StrategoVar")
    , [ appl(
          check-sort-of-prod(?"StrategoId")
        , [appl(id, FancyVar)]
        )
      ]
    )

  CheerUp =
    appl(
        check-cons-of-prod(?"ListVar")
      ; check-sort-of-prod(?"StrategoLID")
    , [ appl(
          check-sort-of-prod(?"StrategoLId")
        , [appl(id, FancyVar)]
        )
      ]
    )

  /**
   * Term variables of strategies
   */
  CheerUp =
    appl(
      check-cons-of-prod(?"SDefT" + ?"RDefT")
    , [ appl(id, id) // name
      , appl(id, id) // layout
      , lit("(")
      , appl(id, id) // layout
      , appl(id, id) // svars
      , appl(id, id) // layout
      , lit("|")
      , appl(id, id) // layout
      , appl(id, topdown(try(
          appl(
            check-sort-of-prod(?"StrategoId")
          , [ appl(id, FancyVar)]))))
      , appl(id, id)
      , lit(")")
      | id ]
    )

  /**
   * Scope declaration
   */
  CheerUp =
    appl(
      check-cons-of-prod(?"Scope")
    , [ lit("\\{")
      , appl(id, id) // layout
      , appl(id, topdown(try(
          appl(
            check-sort-of-prod(?"StrategoId")
          , [ appl(id, FancyVar)]))))
      , appl(id, id) // layout
      , lit(":")
      | id ]
    )

  /**
   * Quotation to concrete object syntax
   */
  CheerUp =
      check-cons-of-appl(is-Quote)
    ; appl(id, map(try(FancyQuote)))

  /**
   * Dynamic Rule Scope
   */
  CheerUp =
      check-cons-of-appl(?"DynRuleScope")
    ; appl(id, map(try(FancyDynRuleScope)))

  /**
   * Left choice
   */
  CheerUp =
      check-cons-of-appl(?"LChoice")
    ; appl(id, map(try(FancyLChoice)))

rules

  FancyVar :
    lit(s) -> lit(<concat-strings> ["\\metavar{", s, "}"])

  FancyVar :
    chars -> <concat> [<explode-string> "\\metavar{", chars, <explode-string> "}"]
      where <is-list; map(is-int)> chars

  FancyLChoice :
    lit("<+") -> lit("\\lchoice")

  FancyQuote :
    lit("|[") -> lit("\\lquote{|[}")

  FancyQuote :
    lit("]|") -> lit("\\rquote{]|}")

  FancyDynRuleScope :
    lit("\\{|") -> lit("\\ldrscope{}")

  FancyDynRuleScope :
    lit("|\\}") -> lit("\\rdrscope{}")

strategies

  is-Quote =
      "ToTerm"
    + "ToStrategy"
    + "ToBuild"

  is-AntiQuote =
      "FromTerm"
    + "FromApp"
    + "FromStrategy"

  check-cons-of-appl(cons-check) = 
    appl(check-cons-of-prod(cons-check), id)

  check-cons-of-prod(cons-check) =
    where(
      ?prod(_, _, attrs(<id>))
    ; fetch-elem(?term(cons(<id>)))
    ; cons-check
    )

  check-sort-of-prod(sort-check) =
    where(
      ?prod(_, <?cf(sort(<id>)) + ?lex(sort(<id>))>, _)
    ; sort-check
    )


