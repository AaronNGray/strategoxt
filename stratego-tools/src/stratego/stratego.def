%%%
%%% SDF grammar for the language "stratego".
%%%
%%% This grammar is part of the Grammar Base which is located at
%%%      http://www.program-transformation.org/gb/
%%% 
%%%  Grammar: stratego
%%%  Version: 0.6.2
%%% Maturity: Volatile
%%%
%%% Description:
%%%  Programming language for strategic term rewriting.

definition

module Stratego-Lex
exports
  lexical syntax
    [a-zA-Z\'\.\-\_] [a-zA-Z0-9\'\.\-\_]* -> Id

  lexical restrictions
    Id -/- [a-zA-Z0-9\'\.\-\_]

  lexical syntax
    "all" -> Id {reject}
    "constructors" -> Id {reject}
    "fail" -> Id {reject}
    "id" -> Id {reject}
    "in" -> Id {reject}
    "let" -> Id {reject}
    "module" -> Id {reject}
    "not" -> Id {reject}
    "one" -> Id {reject}
    "overlays" -> Id {reject}
    "override" -> Id {reject}
    "prim" -> Id {reject}
    "rules" -> Id {reject}
    "script" -> Id {reject}
    "signature" -> Id {reject}
    "some" -> Id {reject}
    "sorts" -> Id {reject}
    "strategies" -> Id {reject}
    "stratego" -> Id {reject}
    "test" -> Id {reject}
    "thread" -> Id {reject}
    "where" -> Id {reject}

  lexical syntax
    [a-zA-Z\'\.\-\_] [a-zA-Z0-9\'\.\-\_]* -> ModName

  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]

  lexical syntax
    "imports" -> ModName {reject}
    "overlays" -> ModName {reject}
    "rules" -> ModName {reject}
    "signature" -> ModName {reject}
    "strategies" -> ModName {reject}

  lexical syntax
    [\t\ \n] -> Ws
    "//" ~[\n]* [\n] -> ShortCom
    "/*" CommChar* "*/" -> LongCom
    "(*" CommChar* "*)" -> LongCom
    "*" -> Asterisk
    ~[\*] -> CommChar
    Asterisk -> CommChar
    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
    "\\begin{code}" -> VeryLongCom
    "\\end{code}" VLCchar* Eof -> VeryLongCom
     -> Eof
    "\\literate" VLCchar* "\\begin{code}" -> VeryLongCom
    ~[\\] -> VLCchar
    Backslash -> VLCchar
    [\\] -> Backslash

  lexical restrictions
    Asterisk -/- [\/\)]
    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
    Eof -/- ~[]

  lexical syntax
    ShortCom -> LAYOUT
    LongCom -> LAYOUT
    VeryLongCom -> LAYOUT
    Ws -> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n]

  lexical syntax
    [\-]? [0-9]+ -> Int
    [\-]? [0-9]+ [\.] [0-9]+ -> Real

  lexical syntax
    "\"" StrChar* "\"" -> String
    ~[\"\n\\] -> StrChar
    [\\] [\"tn\\] -> StrChar

module Stratego
imports Stratego-Lex

exports
  sorts Module Script

  context-free syntax
    "module" ModName Decl* -> Module {cons("Module")}
    "stratego" "script" Command* -> Script {cons("Script")}

  context-free syntax
    Decl -> Command {cons("Command")}
    ":dump" String -> Command {cons("Dump")}
    ":load" String -> Command {cons("Load")}
    ">" Strategy -> Command {cons("Eval")}

  context-free syntax
    "imports" ModName* -> Decl {cons("Imports")}
    "rules" ( StrategyOrRuleDef )* -> Decl {cons("Rules")}

%% This definition used to use StrategyDef | RuleDef instead of
%% StrategyOrRuleDef. However, due to a bug in pgen, this yielded incorrect
%% asfix.
StrategyDef -> StrategyOrRuleDef
RuleDef -> StrategyOrRuleDef
    "strategies" ( StrategyOrRuleDef )* -> Decl {cons("Strategies")}
    "signature" Sdecl* -> Decl {cons("Signature")}
    "overlays" Overlay* -> Decl {cons("Overlays")}

  context-free syntax
    "sorts" Sort* -> Sdecl {cons("Sorts")}
    "constructors" Opdecl* -> Sdecl {cons("Constructors")}

  context-free syntax
    Id -> Sort {cons("SortNoArgs")}
    Id "(" {Term ","}* ")" -> Sort {cons("Sort")}

  context-free syntax
    "*" -> Kind {cons("Star")}
    "**" -> Kind {cons("StarStar")}

  context-free syntax
    Id ":" Type -> Opdecl {cons("OpDecl")}

  context-free syntax
    Term -> Type {cons("ConstType")}
    {Type "*"}+ "->" Type -> Type {cons("FunType")}
    "(" Type ")" -> Type {bracket}

  context-free syntax
    Id -> Var {cons("Var")}

  context-free syntax
    "_" -> Term {cons("Wld")}
    Int -> Term {cons("Int")}
    Real -> Term {cons("Real")}
    String -> Term {cons("Str")}
    "_" Term -> Term {cons("BuildDefault")}
    Var -> Term {cons("Inj")}
    Var Context -> Term {cons("Con")}
    Id "(" {Term ","}* ")" -> Term {cons("Op")}
    Var "@" Term -> Term {cons("As")}
    "(" {Term ","}* ")" -> Term {cons("Tuple")}
    "<" Strategy ">" Term -> Term {cons("App")}
    "[" {Term ","}* "]" -> Term {cons("List")}
    "[" {Term ","}* "|" Term "]" -> Term {cons("ListTail")}
    Term "#" "(" Term ")" -> Term {cons("Explode")}

  context-free priorities
    Term "#" "(" Term ")" -> Term {cons("Explode")} >
    Var "@" Term -> Term {cons("As")}

  context-free syntax
    "[" Term "]" -> Context {cons("Con1")}
    "[" Term "]" "(" Id ")" -> Context {cons("Con2")}
    "[" Term "where" Strategy "]" -> Context {cons("Con3")}
    "[" Term "where" Strategy "]" "(" Id ")" -> Context {cons("Con4")}

%% This definition used to use Rule | Stratrule instead of
%% RuleOrStratrule. However, due to a bug in pgen, this yielded incorrect
%% asfix.
Rule -> RuleOrStratrule
Stratrule -> RuleOrStratrule
  context-free syntax
    Id ":" ( RuleOrStratrule ) -> RuleDef {cons("RDefNoArgs")}
    Id "(" {Typedid ","}* ")" ":" ( RuleOrStratrule ) -> RuleDef {cons("RDef")}

  context-free syntax
    Term "->" Term -> Rule {cons("RuleNoCond")}
    Term "->" Term "where" Strategy -> Rule {cons("Rule")}

  context-free syntax
    Strategy "-->" Strategy -> Stratrule {cons("StratRuleNoCond")}
    Strategy "-->" Strategy "where" Strategy -> Stratrule {cons("StratRule")}

  context-free syntax
    "fail" -> Strategy {cons("Fail")}
    "id" -> Strategy {cons("Id")}
    Id -> SVar {cons("SVar")}
    "let" ( StrategyOrRuleDef )* "in" Strategy -> Strategy {cons("Let")}
    SVar -> Strategy {cons("CallNoArgs")}
    SVar "(" {Strategy ","}* ")" -> Strategy {cons("Call")}
    "?" Term -> Strategy {cons("Match")}
    "!" Term -> Strategy {cons("Build")}
    "{" Strategy "}" -> Strategy {cons("ScopeDefault")}
    "{" {Id ","}* ":" Strategy "}" -> Strategy {cons("Scope")}
    "<" Strategy ">" Term -> Strategy {cons("BA")}
    Strategy "=>" Term -> Strategy {cons("AM")}
    "<" Strategy ">" -> StrategyAngle {cons("AngleStrat")}
    "(" Strategy ")" -> StrategyParen {cons("ParenStrat")}
    "\\" Rule "\\" -> Strategy {cons("LRule")}
    Strategy ";" Strategy -> Strategy {cons("Seq"), right}
    Strategy "+" Strategy -> Strategy {cons("Choice"), right}
    Strategy "<+" Strategy -> Strategy {cons("LChoice"), right}
    "rec" Id "(" Strategy ")" -> Strategy {cons("Rec")}
    "not" "(" Strategy ")" -> Strategy {cons("Not")}
    "where" "(" Strategy ")" -> Strategy {cons("Where")}
    "test" "(" Strategy ")" -> Strategy {cons("Test")}

  context-free priorities
    Strategy "#" StrategyParen -> Strategy {cons("ExplodeCong")} >
    { "!" Term -> Strategy {cons("Build")}
      "?" Term -> Strategy {cons("Match")} } >
    Strategy "=>" Term -> Strategy {cons("AM")} >
    Strategy ";" Strategy -> Strategy {cons("Seq"), right} >
    { right : Strategy "+" Strategy -> Strategy {cons("Choice"), right} Strategy "<+" Strategy -> Strategy {cons("LChoice"), right} }

  context-free syntax
    "prim" "(" String ")" -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}
    Int Strategy -> Strategy {cons("Path")}
    "some" "(" Strategy ")" -> Strategy {cons("Some")}
    "one" "(" Strategy ")" -> Strategy {cons("One")}
    "all" "(" Strategy ")" -> Strategy {cons("All")}
    "thread" "(" Strategy ")" -> Strategy {cons("Thread")}
    String -> Strategy {cons("StrCong")}
    Int -> Strategy {cons("IntCong")}
    Real -> Strategy {cons("RealCong")}
    "(" {Strategy ","}* ")" -> Strategy {cons("TupleCong")}
    Mod -> Strategy {cons("ModCongNoArgs")}
    Mod "(" {Strategy ","}* ")" -> Strategy {cons("ModCong")}
    Id "^" Id -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]" -> Strategy {cons("ListCong")}
    Strategy "#" StrategyParen -> Strategy {cons("ExplodeCong")}
    "rules" "(" RuleDef* ")" -> Strategy {cons("DynamicRules")}
    "override" "rules" "(" RuleDef* ")" -> Strategy {cons("OverrideDynamicRules")}
    "{|" {Id ","}* ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}

  context-free syntax
    Id "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    Id -> Typedid {cons("DefaultVarDec")}
    Id ":" Type -> Typedid {cons("VarDec")}

  context-free syntax
    Id "=" Term -> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term -> Overlay {cons("Overlay")}

module GB-Main
imports Stratego

exports
  syntax
    <START> -> SURROGATE-START {cons("\"stratego-0.6.2\"")}
    SURROGATE-START [\256] -> <Start> {prefer, cons("SURROGATE-START")}
