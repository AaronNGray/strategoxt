module nbl/tasks

imports 
  
  task/core
  nbl/lookup
  nbl/collect
  nbl/resolve
  nbl/query
  nbl/incremental
  nbl/interface
  nbl/uri
  nbl/utils
  nbl/entries
  
signature
  
  constructors
    
    Resolve        : Scope                    -> Instruction
    Resolve        : Scope * Namespace * Name -> Instruction
    ResolveImport  : Scope * Namespace * Name -> Instruction
    Choice         : List(Result)             -> Instruction
    PropCalc       : Property * Term          -> Instruction
    Match          : ID * List(Term) * Term   -> Instruction
        
rules // Resolve
  
  perform-task(|nr):
  	Resolve(scope, ns, name) -> result
  	with
  		def* := <nabl-lookup(|ns, name)> scope;
  		switch !def*
        case ?[]: !Fail(<nabl-extend-uri(|ns, name, ()); nabl-new-reads(|nr)> scope)
        otherwise: !Done(def*, <mapconcat(nabl-uri; nabl-new-reads(|nr))> def*)
  		end => result

	perform-task(|nr):
		ResolveImport(scope, ns, name) -> result
		with
			<with(uri := <nabl-uri> scope | "Could not extract URI from: ")> scope;
			language          := <nabl-uri-language> uri;
      namedImportURI*   := <nabl-get-import-uris-named(|language, ns, name)> uri;
      unnamedImportURI* := <nabl-get-import-uris-unnamed(|language, ns)> uri;
      if <nabl-has-dependency> namedImportURI* <+ <nabl-has-dependency> unnamedImportURI* then
      	result := Dependency([namedImportURI*, unnamedImportURI*])
      else
	      namedDef*     := <mapconcat(nabl-lookup(|ns, name))> namedImportURI*;
	      unnamedDef*   := <mapconcat(nabl-lookup(|ns, name))> unnamedImportURI*;
	      def*          := [namedDef*, unnamedDef*];
	      def-read*     := <mapconcat(nabl-uri; nabl-new-reads(|nr))> def*;
	      named-read*   := <mapconcat(nabl-new-reads(|nr))> namedImportURI*;
	      unnamed-read* := <mapconcat(nabl-new-reads(|nr))> unnamedImportURI*;
	      result        := Done(def*, [def-read*, named-read*, unnamed-read*])
      end
      
  /*nabl-resolve-constraint(|prop*):
    entry -> entry'
    where
      results := <map(nabl-resolve-constraint-one(|entry))> prop*;
      if d := <nabl-collect-dependency> results then
        entry' := d
      else
        entry' := entry
      end
      
  nabl-resolve-constraint-one(|entry):
    Prop(type, expectedValue) -> entry'
    where
      value := <nabl-get-property(|type)> entry;
      if value' := <nabl-resolve> value then
        expectedValue'  := <nabl-resolve> expectedValue;
        <eq> (expectedValue', value');
        entry' := entry
      else
        entry' := <nabl-create-dependency> value
      end*/
		
	perform-task(|nr):
 		Choice(choices) -> result
		where
			result := Done(<remove-all(?Fail()); concat; ?[_|_]> choices) <+
			result := Fail()

rules // Property calculation
            
  perform-task(|nr): PropCalc(prop, term) -> Done(<calc-property> (prop, term))
  
rules // Match
  
  perform-task(|nr): Match(key, bound, term) -> Done(<nabl-match> (key, term, bound))
    
rules // Utility
  
  nabl-result-number:
    Result(num) -> num

rules // Task dependency utilities
	
  nabl-create-dependency =
  	collect-all(?Result(<id>));
  	!Dependency(<id>)
  	
	nabl-has-dependency =
		fetch(?Dependency(_))
		
	nabl-collect-dependency =
		collect-all(?Dependency(<id>));
		concat;
		where(Hd);
		!Dependency(<id>)

rules // Projections
  
  /** @internal */
  nabl-uri-impl:
    Task(uri, _, _, _) -> uri

  /** @internal */  
  nabl-uri-impl:
    Resolve(uri) -> uri
  
  /** @internal */  
  nabl-uri-impl:
    Resolve(uri, _, _) -> uri
  
  /** @internal */  
  nabl-uri-impl:
    ResolveImport(uri, _, _) -> uri
  
  /** @internal */
  nabl-uri-impl:
    DoneTask(_, uri) -> uri
