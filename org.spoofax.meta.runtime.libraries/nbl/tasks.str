module nbl/tasks

imports 
  
  task/core
  nbl/lookup
  nbl/collect
  nbl/resolve
  nbl/query
  nbl/interface
  nbl/uri
  nbl/utils
  
signature
  
  constructors
    
    Resolve  : Result * Namespace * Name * List(Prop) * Range -> Instruction
    Choice   : List(Int)                                      -> Instruction
    Choice   : List(Int) * List(String)                       -> Instruction
    PropCalc : Property * Term                                -> Instruction
    Match    : ID * List(Term) * Term                         -> Instruction
        
rules // Resolve
  
  perform-task: 
    Resolve(uri*, namespace, name, prop*, range) -> result
    where
      name' := <rm-annotations> name;
      // TODO: Get rid of flatten-list?
      // GW: should this simply be a concat?
      resolved* := <flatten-list; remove-all(?Fail(_)); mapconcat(perform-task-resolve(|namespace, name', prop*, range))> uri*;
      switch !resolved*
        case ?[]: 
          result := Fail(<map(nabl-extend-uri(|namespace, name', ()))> uri*)
        case d := <nabl-collect-dependency>:
          result := d
        otherwise:
          result := Done(<filter(nabl-uri)> resolved*)
      end
      
  perform-task-resolve(|namespace, name, prop*, range): 
    t -> resolved*
    where
      uri := <nabl-uri> t;
      switch !range
        case All(): resolved* := <nabl-lookup-definitions(nabl-resolve-constraint(|prop*)|namespace, name)> uri
        case One(): resolved* := <nabl-lookup-definitions-scoped(nabl-resolve-constraint(|prop*)|namespace, name)> uri
      end
      
  nabl-resolve-constraint(|prop*):
    entry -> entry'
    where
      results := <map(nabl-resolve-constraint-one(|entry))> prop*;
      if d := <nabl-collect-dependency> results then
        entry' := d
      else
        entry' := entry
      end
      
  nabl-resolve-constraint-one(|entry):
    Prop(type, expectedValue) -> entry'
    where
      value := <nabl-get-property(|type)> entry;
      if value' := <nabl-resolve> value then
        expectedValue'  := <nabl-resolve> expectedValue;
        <eq> (expectedValue', value');
        entry' := entry
      else
        entry' := <nabl-create-dependency> value
      end
		
	perform-task:
 		Choice(choices) -> result
		where
			result := Done(<remove-all(?Fail(_)); concat; ?[_|_]> choices) <+
			result := Fail(<mapconcat(?Fail(<id>))> choices) 

  perform-task:
    Choice(choice*, error*) -> result
    where
      result := Done(<remove-all(?Fail(_)); concat; ?[_|_]> choice*) //<+
      //result := Fail(<concat-strings> error*) <+
      //result := Fail(<mapconcat(?Fail(<id>))> choice*) 


rules // Property calculation
            
  perform-task: PropCalc(prop, term) -> Done(<calc-property> (prop, term))
  
rules // Match
  
  perform-task: Match(key, bound, term) -> Done(<nabl-match> (key, term, bound))
    
rules // Utility
  
  nabl-result-number:
    Result(num) -> num

rules // Task dependency utilities
	
  nabl-create-dependency =
  	collect-all(?Result(<id>));
  	!Dependency(<id>)
  	
	nabl-has-dependency =
		fetch(?Dependency(_))
		
	nabl-collect-dependency =
		collect-all(?Dependency(<id>));
		concat;
		where(Hd);
		!Dependency(<id>)

rules // Projections
  
  /** @internal */
  nabl-uri-impl:
    Task(uri, _, _) -> uri
  
  /** @internal */  
  nabl-uri-impl:
    Resolve(uri, _, _, _, _) -> uri
  
  /** @internal */
  nabl-uri-impl:
    DoneTask(_, uri) -> uri
    
  /** @internal */
  nabl-uri-impl:
    FailTask(_, uri) -> uri
