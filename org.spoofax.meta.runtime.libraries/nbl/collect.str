module nbl/collect

imports
	
	task/core
	nbl/tasks
	nbl/entries
	nbl/interface
	nbl/uri
	nbl/utils
	
signature 

	sorts
	
		State DefScope ImplicitDef Use RefScope Range

  constructors // state
  	
  	State : String * Term -> State

	constructors // def

		Current    :            						DefScope
		Subsequent :            						DefScope
		DefScope   : Namespace * Segment -> DefScope

  constructors // implicit def
    
    IDefCandidate : Namespace * Name * Unique * List(Property) -> ImplicitDef
  
  constructors // use
      
		UseCandidate  : Namespace * List(Property) * RefScope * Range        -> Use
		UseCandidate  : Namespace * Name * List(Property) * RefScope * Range -> Use
	
		Current     :                                     							RefScope
		Surrounding :                                  	 							  RefScope
		Context     : String * Namespace * List(Property) * RefScope -> RefScope
		
    All : Range
    One : Range
	
	constructors // import
	  
	  Imported : Namespace                   -> Namespace
	  Import   : Language * Namespace        -> Property
	  Import   : Language * Namespace * Name -> Property
  	Type     : Property
  	
  constructors // property
    
    Prop : Property * Value -> Prop
	
strategies // generic traversal
	
	/**
	 * Main strategy to collect all index elements and task* from an AST.
	 */
	nabl-collect(|partition, lang):
	  ast -> (ast', <iset-elements> elem*, <iset-elements> task*)
	  where
	    new-iset      => elem*;
	    new-iset      => task*;
	    new-hashtable => unique*;
	    ast' := <nabl-collect(id, id|(partition, lang, elem*, task*, unique*), [], [])> ast
	
  partition-in-context = ?(<id>, _, _, _, _)
	lang-in-context      = ?(_, <id>, _, _, _)
  elem-in-context      = ?(_, _, <id>, _, _)
  task-in-context      = ?(_, _, _, <id>, _)
  unique-in-context    = ?(_, _, _, _, <id>)
  
	/**
	 * Performs the collection in a topdown traversal. 
	 * At each node, it tries various calls to generated strategies, which call back to generic strategies.
	 */
	nabl-collect(sibling-uris, deps'|context, uri*, dep*) =
		nabl-state-pop(?state*);
		nabl-scope-site(?uri'*|context, uri*, state*); // scopes of external definitions, e.g. variables in let expressions
		nabl-def-collect(?child-uri*, sibling-uris|context, uri'*, uri*, state*);
		nabl-import-dependency-annotate;
		nabl-import-dependency-collect(deps'|dep*);
		nabl-state-collect;
		
		preserve-annos(force-origins(id#(nabl-siblings(|context, child-uri*, dep*)))); // visit children from left to right
		
		nabl-use-collect(|context, uri'*, dep*, state*);
    nabl-import-collect(|context, child-uri*, state*);
		nabl-prop-collect(|context, state*);
    nabl-implicit-def-collect(|context, child-uri*, state*)
	
	nabl-siblings(|context, uri*, dep*) = 
		[] + [nabl-collect(?sibling-uri*, ?deps'|context, uri*, dep*)|nabl-siblings(|context, sibling-uri*, deps')]

rules // generic analysis of state
  
  nabl-state-collect = try(nabl-state-site)
  
  nabl-state(pattern|state):
    term -> <map(try(nabl-state-annotate(pattern|state)))> term
      
  nabl-state-annotate(pattern|state) =
    ?pattern; add-annotation(|state)
    
  nabl-state-pop(states'):
  	term{anno*} -> term'
  	where
  		state* := <collect-all(?State(_, _))> anno*;
  		term'  := <remove-annotations(?State(_, _))> term;
  		match(states'|state*)
  		
  nabl-get-state(|name) =
  	fetch-elem(?State(name, _))

rules // generic analysis of scopes
	
	nabl-scope-site(adapted-uris|context, uri*, state*):
		name{anno*} -> result
		where
			if (anno1*, anno2*) := <split-fetch(?DefScope(ns, uri) => scope )> anno* then
				segment := <nabl-uri-path; Hd; nabl-external-segment> uri;
				uri'*   := <update-scope-uri(nabl-extend-uri(|segment)|<lang-in-context> context)> (ns, uri*);
				result  := <set-annos; nabl-scope-site(adapted-uris|context, uri'*, state*)> (name, [anno1*, anno2*])
			else
				match(adapted-uris|uri*);
				result := name{anno*}
			end
	
	nabl-def-scope(|context) = !DefScope(<id>, <lang-in-context; nabl-base-uri; nabl-extend-uri-anonymous(|<unique-in-context> context, <partition-in-context> context)> context)
	
	nabl-def-scope(|scope): name{anno*} -> name{scope, anno*}
		
	// call back for generic analysis of anonymous scopes
	nabl-anonymous-scope(child-uris|context, uri*, ns*) =
		match(child-uris|<extend-scope-uri(nabl-extend-uri-anonymous(|<unique-in-context> context, <partition-in-context> context)|<lang-in-context> context)> (ns*, uri*))	
	
rules // generic analysis of defs
	
	nabl-def-collect(child-uris, sibling-uris|context, c-uri*, s-uri*, state*) =
		nabl-def-site(child-uris, sibling-uris|context, c-uri*, state*) <+ 
	  match(sibling-uris|s-uri*);
	  (
      nabl-anonymous-scope-site(child-uris|context, c-uri*, state*) <+
      match(child-uris|c-uri*)
    )
    	
	// call back to generic analysis
	nabl-def(child-uris, sibling-uris|context, uri*, ns, unique, defscope, scoped):
		a@name{anno*} -> name{d,anno*}
		where
			// get URI for namespace of definition site
			current-uri := <lookup-uri(|<lang-in-context> context, ns)> uri*;
			switch !defscope
			// in each case we 
			// 1. build URI of the definition site
			// 2. update URIs for children (vertical scope)
			// 3. update URIs for right siblings (horizontal scope)
			case ?Current():
				// 1. extend current URI with ID segment
				// 2. extend URIs of scoped namespaces
				// 3. preserve
				def-uri := <nabl-extend-uri(|<unique-in-context> context, <partition-in-context> context, ns, name, unique)> current-uri;
				match(child-uris|<replace-scope-uri(|def-uri)> (scoped, uri*));
			  match(sibling-uris|uri*)
			case ?[Subsequent()]:
				// 1. extend current URI with Subsequent and ID segment
				// 2. preserve
				// 3. extend URI for namespace of definition site with Subsequent segment
				subs-uri := <nabl-extend-uri-subsequent(|<unique-in-context> context, <partition-in-context> context)> current-uri;
				def-uri  := <nabl-extend-uri(|<unique-in-context> context, <partition-in-context> context, ns, name, unique)> subs-uri;
	  		match(child-uris|uri*);
				match(sibling-uris|<replace-scope-uri(|subs-uri)> ([ns], uri*))
	  	case ?[DefScope(ns, uri)]:
	  		// 1. extend base URI with External and ID segment
				// 2. preserve
				// 3. preserve
				def-uri := <nabl-extend-uri(|<unique-in-context> context, <partition-in-context> context, ns, name, unique)> uri;
				match(child-uris|uri*);
				match(sibling-uris|uri*)
			case ?[Subsequent(), DefScope(ns, uri)]:
				// 1a. extend base URI with External and ID segment
				// 1b. extend current URI with Subsequent and ID segment
				// 1c. introduce alias from 1b to 1a
				// 2. preserve
				// 3. extend URI for namespace of definition site with Subsequent segment
				def-uri   := <nabl-extend-uri(|<unique-in-context> context, <partition-in-context> context, ns, name, unique)> uri;
				subs-uri  := <nabl-extend-uri-subsequent(|<unique-in-context> context, <partition-in-context> context)> current-uri;
        alias-uri := <nabl-extend-uri(|<unique-in-context> context, <partition-in-context> context, ns, name, unique)> subs-uri;
	  		<new-alias(|context, def-uri, alias-uri)> a;
	  		match(child-uris|uri*);
				match(sibling-uris|<replace-scope-uri(|subs-uri)> ([ns], uri*))
			end;
			// add Def entry to the index
			d := <new-def(|<elem-in-context> context, def-uri)> a
	
rules
  
  nabl-import-dependency-annotate = try(nabl-import-dependency-site)

  nabl-import-dependency:
    name -> <nabl-add-reserved(|reserved)> name
    with
      /* Reserve a task number for use as dependency for the subtree of the import and annotate the name with it. 
      The reserved number is used in nabl-import to create a Noop task that has a dependency on the resolution of the 
      import target. This makes sure that imports are resolved before other resolve tasks. */
      reserved := <reserve-task>
      
  nabl-import-dependency-collect(deps'|dep*):
    name -> name
    with
    	/* Do the actual adding of the dependency here because the reserved annotation may be added to a name that is
      in the subtree of the import name. The dependency should only be active after the annotated term. */
      if Reserved(r) := <nabl-collect-reserved> name then
        match(deps'|[r|dep*])
      else
        match(deps'|dep*)
      end
	
rules // generic analysis of uses
	
	nabl-use-collect(|context, uri*, dep*, state*) = 
		try(nabl-use-site(|context, uri*, dep*, state*))
	
	// single candidate
	nabl-use(|context, uri*, dep*, candidate) =
		where (<not(is-list)> candidate);
		nabl-use(|context, uri*, dep*, [candidate])
	
	// list of candidates
	nabl-use(|context, uri*, dep*, candidates):
		name{anno*} -> name{u, anno*}
		where
			subtask* := <map(nabl-use-candidate(|context, uri*, dep*, <nabl-fix-name> name)); make-set> candidates;
			taskdep* := <dependent-tasks> subtask*;
			result   := <new-task(|<task-in-context> context, taskdep*)> Choice(subtask*);
		  u        := <new-use(|<elem-in-context> context, result)>
		
	// candidate in current scope
	nabl-use-candidate(|context, uri*, dep*, name):
		UseCandidate(ns, prop*, Current(), range) -> result
		where
			uri      := <lookup-uri(|<lang-in-context> context, ns)> uri*;
			propdep* := <dependent-tasks> prop*;
			result   := <new-task(|<task-in-context> context, [dep*, propdep*])> Resolve(uri, ns, name, prop*, range)
      
  // named candidate in current scope
  nabl-use-candidate(|context, uri*, dep*, term):
    UseCandidate(ns, name, prop*, Current(), range)-> result
    where
      uri      := <lookup-uri(|<lang-in-context> context, ns)> uri*;
      propdep* := <dependent-tasks> prop*;
      namedep* := <dependent-tasks> name;
      result   := <new-task(|<task-in-context> context, [dep*, propdep*, namedep*])> Resolve(uri, ns, name, prop*, range)
    
	// candidate in another scope (result of resolution)	  
	nabl-use-candidate(|context, uri*, dep*, name):
		c@UseCandidate(ns, prop*, target-uri*, range) -> result
		where
		  <?Result(_) <+ map(?Result(_))> target-uri*;
		  propdep* := <dependent-tasks> prop*;
		  uridep*  := <dependent-tasks> target-uri*;
			result   := <new-task(|<task-in-context> context, [dep*, propdep*, uridep*])> Resolve(target-uri*, ns, name, prop*, range);
		  u        := <new-use(|<elem-in-context> context, result)>
		  
	// candidate in context
  nabl-use-candidate(|context, uri*, dep*, name):
    UseCandidate(ns, prop*, Context(name', ns', props', refscope'), range) -> result
    where 
     	uri-result := <nabl-use-candidate(|context, uri*, dep*, <nabl-fix-name> name')> UseCandidate(ns', props', refscope', range);
      propdep*   := <dependent-tasks> prop*;
      result     := <new-task(|<task-in-context> context, [dep*, propdep*])> Resolve(uri-result, ns, name, prop*, range)
    
rules // generic analysis of imports
  
  nabl-import-collect(|context, uri*, state*) = 
  	try(nabl-import-site(|context, uri*, state*))
  
  nabl-import(|context, uri*, imports):
    name -> name''
    where
    	Use(use) := <nabl-collect-use> name;
      name'    := <foldl(nabl-import-candidate(|context, uri*, use))> (imports, name);
      if Reserved(r) := <nabl-collect-reserved> name then
      	Result(dep) := use;
      	name''      := <remove-annotations(?Reserved(r))> name';
      	<new-task(|<task-in-context> context, [dep], r)> Noop()
      else
      	name'' := name'
      end
        
  nabl-import-candidate(|context, uri*, use):
    (import, name) -> name
    where
      ns       := <nabl-import-namespace> import;
      uri      := <lookup-uri(|<lang-in-context> context, ns)> uri*;
      new-prop(|<elem-in-context> context, uri, import, use)
      
  nabl-import-namespace:
    Import(_, Imported(namespace)) -> namespace
      
  nabl-import-namespace:
    Import(_, namespace) -> namespace
    where
      not(Imported(_) := namespace)
      
  nabl-import-namespace:
    Import(_, Imported(namespace), _) -> namespace
      
  nabl-import-namespace:
    Import(_, namespace, _) -> namespace
    where
      not(Imported(_) := namespace)

rules // generic analysis of properties
  
  nabl-prop-collect(|context, state*) = 
  	try(nabl-prop-site(|context, state*))
  
	// call back to generic analysis
	nabl-props(|context, prop*):
	  name -> name'
	  where
	    Def(uri) := <nabl-collect-def> name;
		  name'    := <foldl(extend-prop(|<elem-in-context> context, uri))> (prop*, name)
		
	extend-prop(|elem*, uri):
		(Prop(type, result), name) -> name
		where
		  prop := <new-prop(|elem*, uri, type, result)> name

rules // generic analysis of implicit defs

  nabl-implicit-def-collect(|context, uri*, state*) = 
  	try(nabl-implicit-def-site(|context, uri*, state*))
 
  nabl-implicit-def(|context, uri*, candidates):
    name -> name
    where
      <map(nabl-implicit-def-candidate(|context, uri*))> candidates
      
  nabl-implicit-def-candidate(|context, uri*):
    IDefCandidate(ns, name, unique, prop*) -> <id>
    where
      // get path for namespace of definition site
      current-uri := <lookup-uri(|<lang-in-context> context, ns)> uri*;
      // build path for definition site
      def-uri     := <nabl-extend-uri(|<unique-in-context> context, <partition-in-context> context, ns, name, unique)> current-uri;
      // build Def entry for the index
      new-def(|<elem-in-context> context, def-uri);
      // build Prop entries for the index
      <map(\Prop(type, result) -> <new-prop(|<elem-in-context> context, def-uri, type, result)>\)> prop*

rules // name retrieval
  
  nabl-name = is-string
  
  nabl-name-apply(s) = is-string; s
    
  nabl-fix-name = try(fix-completion-name); strip-annos
  
rules // URI retrieval
  
  nabl-collect-def =
    nabl-name;
    get-annos;
    collect-one(?Def(_))
    
  nabl-collect-all-def =
    nabl-name;
    get-annos;
    collect-all(?Def(_))
    
  nabl-collect-use =
    nabl-name;
    get-annos;
    collect-one(?Use(_))
    
  nabl-collect-all-use =
    nabl-name;
    get-annos;
    collect-all(?Use(_))
    
  nabl-add-reserved(|reserved) =
    nabl-name-apply(add-annotation(|reserved))
    
  nabl-collect-reserved =
    nabl-name;
    get-annos;
    collect-one(?Reserved(_))

rules // helpers
	
	replace-scope-uri(|path) = foldl(update-scope-uri(!path|<nabl-uri-language> path))
  extend-scope-uri(s|lang) = foldl(update-scope-uri(s|lang))
  
	update-scope-uri(update|lang):
		(key, uri*) -> result
		where
		  result := <fetch((?key, update))> uri* 
		<+ 
		  result := [(key, <nabl-base-uri; update> lang)|uri*]
			  
	lookup-uri(|lang, ns):
	  uri* -> <<lookup> (ns, uri*) <+ <nabl-base-uri> lang>
	  
