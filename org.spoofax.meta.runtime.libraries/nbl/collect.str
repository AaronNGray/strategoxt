module nbl/collect

imports
	
	task/core
	task/tasks
	nbl/tasks
	nbl/entries
	nbl/interface
	nbl/uri
	nbl/utils
	types/interface
	
signature 

	sorts
	
		State DefScope ImplicitDef Use RefScope Range

  constructors // state
  	
  	State : String * Term -> State

	constructors // def

		Current    :            	DefScope
		Subsequent :            	DefScope
		DefScope   : Term      -> DefScope
    Scope      : Namespace -> Scope
    
  constructors // use
      
		UseCandidate  : Namespace * List(Property) * RefScope * List(Dependency) -> Use
	
		Current     :                                     							RefScope
		Surrounding :                                  	 							  RefScope
		Context     : String * Namespace * List(Property) * RefScope -> RefScope
		
    All : Range
    One : Range
	
	constructors // import
	  
	  Wildcard : List(Import) * RefScope * DefScope * List(Dependency) -> ImportDesc
	  Single   : Term * DefScope * List(Dependency) -> ImportDesc
	  Imported : Namespace                   -> Namespace
	  Import   : Language * Namespace        -> Property
	  Import   : Language * Namespace * Name -> Property
  	Type     : Property
  	
  constructors // property
    
    Prop : Property * Value * List(Dependency) -> Prop
    
  constructors // partition
  
  	CollectPartition : Partition
	
strategies // generic traversal
	
	/**
	 * Main strategy to collect all index elements and task* from an AST.
	 */
	nabl-collect(|partition, lang):
	  ast -> ast'''
	  where
	    new-hashtable => unique*;
	    ast'   := <nabl-collect(id|lang, partition, unique*, [])> ast ;
	    ast''  := <bottomup(try(type-task(|partition)))> ast';
	    ast''' := <alltd(message-task(|partition))> ast''
	  
	/**
	 * Performs the collection in a topdown traversal. 
	 * At each node, it tries various calls to generated strategies, which call back to generic strategies.
	 */
	nabl-collect(sibling-uris|lang, partition, unique*, uri*) =
		nabl-state-pop(?state*);
    try(nabl-scoping-site);
    (
		   nabl-scope-site(?uri'*|lang, partition, unique*, uri*)
		<+ match(?uri'*|uri*) 
		); // scopes of external definitions, e.g. variables in let expressions
   	(
			 nabl-def-site(?child-uri*, sibling-uris, ?implicit*|lang, partition, unique*, uri'*, state*)
    <+ match(sibling-uris|uri*)
     ; match(?child-uri*|uri'*)
    );
    
		try(nabl-state-site);
   
    preserve-annos(force-origins(id#(nabl-siblings(|lang, partition, unique*, child-uri*)))); // visit children from left to right
    
		try(nabl-use-site(|lang, partition, uri'*, state*));
    try(nabl-import-site(|lang, partition, child-uri*, state*));
    try(nabl-prop-site(|lang, partition, state*, implicit*))
    
	nabl-siblings(|lang, partition, unique*, uri*) = 
		[] + 
		[ nabl-collect(?sibling-uri*|lang, partition, unique*, uri*)
		| nabl-siblings(|lang, partition, unique*, sibling-uri*) ]

rules // generic analysis of state
  
  nabl-state(pattern|state) =
    map(try(nabl-state-annotate(pattern|state)))
      
  nabl-state-annotate(pattern|state) =
    ?pattern; add-annotation(|state)
    
  nabl-state-pop(states'):
  	term{anno*} -> term'
  	where
  		state* := <collect-all(?State(_, _))> anno*;
  		term'  := <remove-annotations(?State(_, _))> term;
  		match(states'|state*)
  		
  nabl-get-state(|name) =
  	fetch-elem(?State(name, _))

rules // generic analysis of scopes
	
	nabl-scope-site(adapted-uris|lang, partition, unique*, uri*) =
	  remove-annotations(?Scope(ns*))
	; where (
	  	uri'* := <extend-scope-uri(nabl-extend-uri-anonymous(|unique*, partition)|lang)> (ns*, uri*)
	  ; match(adapted-uris| uri'*)
	  ; scope-uri* := <map(!(<id>, <lookup-uri(|uri'*)>))> ns*
	  )
	; add-annotation(|Scope(scope-uri*))
	  
	nabl-scope(|ns1*) = 
	   remove-annotations(?Scope(ns2*))
	 ; add-annotation(|Scope(<union> (ns1*, ns2*)))
	<+ add-annotation(|Scope(ns1*))
	 
rules // generic analysis of defs
    	
	// call back to generic analysis
	nabl-def(child-uris, sibling-uris|lang, partition, unique*, child-uri*, sibl-uri*, ns, unique, defscope, scoped):
		a@name{anno*} -> name{d,anno*}
		where
			// get URI for namespace of definition site
			current-uri := <lookup-uri(|lang, ns)> child-uri*
		where
			switch !defscope
			  // in each case we 
			  // 1. build URI of the definition site
			  // 2. update URIs for children (vertical scope)
			  // 3. update URIs for right siblings (horizontal scope)
			 
			  // 1st case: definition in current scope
			  case Current(): 
		
			  // 1. extend current URI with ID segment
			  // 2. extend URIs of scoped namespaces
		 	  // 3. preserve
			    def-uri := <nabl-extend-uri(|unique*, partition, ns, name, unique)> current-uri
			  ; match(child-uris|<replace-scope-uri(|def-uri)> (scoped, child-uri*))
			  ; match(sibling-uris|sibl-uri*)
		   
		    // 2nd case: definition in subsequent scope and maybe in external scopes
		    case fetch-elem(?Subsequent()) => def-scope*:
		       
			  // 1. extend current URI with subsequent and ID segment
			  // 2. preserve
			  // 3. extend URI for namespace of definition site with Subsequent segment
			    subs-uri := <nabl-extend-uri-subsequent(|unique*, partition)> current-uri
			  ; def-uri  := <nabl-extend-uri(|unique*, partition, ns, name, unique)> subs-uri
		    ; match(child-uris|child-uri*)
			  ; match(sibling-uris|<replace-scope-uri(|subs-uri)> ([ns], sibl-uri*))
		
		    // 3rd case: definition only in external scopes
		    case is-list => def-scope*:
			  
		    // 1. extend base URI with anonymous and ID segment
		    // 2. preserve
		    // 3. preserve
		      ano-uri := <nabl-base-uri; nabl-extend-uri-anonymous(|unique*, partition)> lang 
		    ; def-uri := <nabl-extend-uri(|unique*, partition, ns, name, unique)> ano-uri
			  ; match(child-uris|child-uri*)
			  ; match(sibling-uris|sibl-uri*)
		  end
    where
      //introduce aliases
	    try(<filter(nabl-def-alias(|partition, def-uri))> def-scope*)
    with
			// add Def entry to the index
			d := <new-def(|partition, def-uri)> a
	
	nabl-def-alias(|partition, def-uri):
	  DefScope(term{anno*}) -> <new-alias(|partition, def-uri, alias-uri)>
	  where
	    <fetch-elem(?Scope(scope*))> anno*
	  ; ns        := <nabl-uri-namespace> def-uri
	  ; base-uri  := <lookup> (ns, scope*)
	  ; segment   := <nabl-uri-path; Hd> base-uri
	  ; alias-uri := <nabl-extend-uri(|segment)> base-uri
      
rules // generic analysis of uses
	
	// single candidate
	nabl-use(|lang, partition, uri*, candidate) =
		where (<not(is-list)> candidate);
		nabl-use(|lang, partition, uri*, [candidate])
	
	// list of candidates
	nabl-use(|lang, partition, uri*, candidate*):
		name{anno*} -> name{u, anno*}
		where
      subtask* := <map(nabl-use-candidate(|lang, partition, uri*, <nabl-fix-name> name))> candidate*;
      result   := <new-task(|partition)> Choice(subtask*);
      u        := <new-use(|partition, result)>

	nabl-use-subtasks(disambiguate|partition, ns, name, prop*, range): 
		uri  -> [task|subtasks]
		with
			task := <nabl-use-subtasks-one(disambiguate|partition, ns, name, prop*, range)> uri;
      switch !range
      	case One(): ![]
      	case All(): <nabl-uri-parent < nabl-use-subtasks(disambiguate|partition, ns, name, prop*, range) + ![]> uri
    	end => subtasks
    	
  nabl-use-subtasks-one(disambiguate|partition, ns, name, prop*, range):
		uri  -> disambiguated
		with
			defsTask            := <new-task(|partition)> ResolveDefs(<nabl-use-subtask-uri(|partition)> uri, ns, name);
			namedImportsTask    := <new-task(|partition)> ResolveNamedImports(<nabl-use-subtask-uri(|partition)> uri, ns, name);
			namedDefsTask       := <new-task(|partition)> ResolveDefs(namedImportsTask, ns, name);
			wildcardImportsTask := <new-task(|partition)> ResolveWildcardImports(<nabl-use-subtask-uri(|partition)> uri, ns);
			wildcardDefsTask    := <new-task(|partition)> ResolveDefs(wildcardImportsTask, ns, name);
			
			if ExternalDef(x) := <nabl-uri-path; Hd> uri then
        ext-uri  := <nabl-uri-language; nabl-base-uri; nabl-extend-uri(|Anonymous(x))> uri;
        subtasks := [<new-task(|partition)> ResolveDefs(<nabl-use-subtask-uri(|partition)> ext-uri, ns, name)]
      else
      	subtasks := []
      end;
      
      concatted     := <new-task(|partition)> Concat([defsTask, namedDefsTask, wildcardDefsTask|subtasks]);
      filtered      := <nabl-use-propconstraint(|partition, prop*)> concatted;
      disambiguated := <nabl-use-disambiguate(disambiguate|partition, prop*, ns, name)> filtered
          	
	nabl-use-subtask-uri(|partition) =
		switch id
			case ?URI(_, _) => uri : ![uri]
			case is-list           : <new-task(|partition)> Choice(<id>)
			otherwise              : id
		end 
		  	
	// candidate in current scope
	nabl-use-candidate(|lang, partition, uri*, name):
		UseCandidate(ns, prop*, Current(), _) -> result
		where
			uri       := <lookup-uri(|lang, ns)> uri*;
			subtask*  := <nabl-use-subtasks(id|partition, ns, name, prop*, All())> uri; // TODO: only disambiguate if required.
			result    := <new-task(|partition)> Choice(subtask*)

	// candidate in another scope (result of resolution)	  
	nabl-use-candidate(|lang, partition, uri*, name):
		UseCandidate(ns, prop*, c@Context(ctx-ns, ctx-name, ctx-prop*, ctx-context), dep*) -> result
		where
			ctx-result := <nabl-use-candidate(|lang, partition, uri*, ctx-name)> UseCandidate(ctx-ns, ctx-prop*, ctx-context, dep*);
			subtask*   := <nabl-use-subtasks(id|partition, ns, <nabl-fix-name> name, prop*, One())> ctx-result; // TODO: only disambiguate if required.
			result     := <new-task(|partition)> Choice(subtask*)
			
	nabl-use-propconstraint(|partition, prop*):
		task -> result
		where
			if not([] := prop*) then
				result := <new-task(|partition)> PropConstraint(prop*, task)
			else
				result := task
			end	

	nabl-use-disambiguate(disambiguate|partition, prop*, namespace, name):
		task -> result
		where
			disambiguate;
			result := <new-task(|partition)> DisambiguateDefs(task, prop*, namespace, name)
    
rules // generic analysis of imports
  
  nabl-import(|lang, partition, uri*, imports) =
    where(<map(nabl-import-candidate(|lang, partition, uri*))> imports)
  
  nabl-import-candidate(|lang, partition, uri*) =
    ?Single(term, scope*, dep)
  ; Def(uri) := <nabl-collect-def> term
  ; ns       := <nabl-uri-namespace> uri
  ; segment  := <nabl-uri-path; Hd> uri
  ; <map(nabl-import-alias(|lang, partition, uri*, uri, ns, segment))> scope*
       
  nabl-import-candidate(|lang, partition, uri*) =
    ?Wildcard(import*, from, into, dep)
  ; <map(nabl-import-prop(|lang, partition, uri*, from, into))> import*
  
  nabl-import-alias(|lang, partition, uri*, uri, ns, segment):
    scope -> <new-alias(|partition, uri, alias-uri)>
  where
    base-uri  := <nabl-scope-uri(|lang, uri*, ns)> 
  ; alias-uri := <nabl-extend-uri(|segment)> base-uri
    
  nabl-import-prop(|lang, partition, uri*, from, into):
    Import(lang, ins) -> <new-prop(|partition, into-uri, <id>, from-uri)>
  where
     Imported(ns) := ins
  <+ ns           := ins
  where
    from-uri := <nabl-scope-uri(|lang, uri*, ns)> from 
  ; into-uri := <nabl-scope-uri(|lang, uri*, ns)> into 
  
  nabl-scope-uri(|lang, uri*, ns):
    Current() -> <lookup-uri(|lang, ns)> uri*
  
  nabl-scope-uri(|lang, uri*, ns):
    DefScope(term{anno*}) -> <lookup> (ns, scope*)
    where
      <fetch-elem(?Scope(scope*))> anno*
      
  nabl-scope-uri(|lang, uri*, ns):
    Context(_, name, _, _) -> uri
    where
      Use(uri) := <nabl-collect-use> name
      
  nabl-import-namespace =
       ?Import(_, Imported(<id>)) 
    <+ ?Import(_, <id>)
    <+ ?Import(_, Imported(<id>), _)
    <+ ?Import(_, <id>, _) 

rules // generic analysis of properties
  
  // call back to generic analysis
	nabl-props(|partition, prop*):
	  name -> name'
	  where
	    Def(uri) := <nabl-collect-def> name;
		  name'    := <foldl(extend-prop(|partition, uri))> (prop*, name)
		
	extend-prop(|partition, uri):
		(Prop(type, result, dep*), name) -> name
		where
		  prop := <new-prop(|partition, uri, type, result)> name
        
rules // name retrieval
  
  nabl-name = is-string
  
  nabl-name-apply(s) = is-string; s
    
  nabl-fix-name = try(fix-completion-name); strip-annos
  
rules // URI retrieval
  
  nabl-collect-def =
    nabl-name;
    get-annos;
    collect-one(?Def(_))
    
  nabl-collect-all-def =
    nabl-name;
    get-annos;
    collect-all(?Def(_))
    
  nabl-collect-use =
    nabl-name;
    get-annos;
    collect-one(?Use(_))
    
  nabl-collect-all-use =
    nabl-name;
    get-annos;
    collect-all(?Use(_))

rules // helpers
	
	replace-scope-uri(|path) = foldl(update-scope-uri(!path|<nabl-uri-language> path))
  extend-scope-uri(s|lang) = foldl(update-scope-uri(s|lang))
  
	update-scope-uri(update|lang):
		(key, uri*) -> result
		where
		  result := <fetch((?key, update))> uri* 
		<+ 
		  result := [(key, <nabl-base-uri; update> lang)|uri*]
			  
	lookup-uri(|lang, ns) =
	  <lookup> (ns, <id>) <+ <nabl-base-uri> lang
 
  lookup-uri(|uri*) =
    <lookup> (<id>, uri*)
