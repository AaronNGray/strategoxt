module nbl/analysis

imports
  
  task/core
  index/core
  index/query
  nbl/collect
  nbl/tasks
  nbl/incremental
  nbl/uri
  
signature

  constructors
  
    File   : Path * AST                                                                                    -> File
    Result : Partition * AST * AST * List(Entry) * List(Entry) * List(Task) * List(Task) * List(Partition) * List(Term) * List(Term) * List(Term) * Metric -> Result
    // Result(partition, initial-ast, analyzed-ast, old-entry*, new-entry*, evaluated-task*, error-task*, dependent-partition*, error*, warning*, note*)
    
    Metric : Int * Int * Int -> Metric
  	// Metric(readsTime, performTime, dependTime)
  	  
rules // Single file analysis
  
  nabl-analyze(|language, path, project-path):
    ast -> (ast', entries, errors, dependent)
    with // Setup index
      partition := $[[project-path]/[path]];
      index-setup(|language, [project-path], partition);
      oldEntries := <filter(nabl-diff-entry)> <index-get-all-in-partition> partition;
      <index-clear-partition> partition
    with // Collect tasks
      (ast', entries, tasks) := <nabl-collect(|path, Language(language))> ast;
       
      <index-add-all(|partition)> entries
    with // Perform tasks
      nabl-collect-reads(
        errors := <perform-tasks(|partition)> tasks
      ) => reads;
          
      <index-add-all(|partition)> reads
    with // Dependent partitions
      newEntries       := <filter(nabl-diff-entry)> entries;
      (added, removed) := <nabl-diff> (oldEntries, newEntries);
      changed          := <conc> (added, removed);
      dependent        := <nabl-get-dependent-partitions; nabl-remove-own-partition(|partition)> changed

rules // Multi file analysis
  
  nabl-analyze-multiple(parse-file, parallel, complete-work-unit|language, project-path):
    path* -> result*
    with
      file*   := <map(nabl-analyze-parse-file(parse-file); where(complete-work-unit))> path*;
      result* := <nabl-analyze-multiple-files(parallel, complete-work-unit|language, project-path)> file*

  nabl-analyze-parse-file(parse-file):
    path -> File(path, ast)
    with
      if not(ast := <file-exists; parse-file> path) then
        ast := ()
      end

  nabl-analyze-multiple-files(parallel, complete-work-unit|language, project-path):
    file* -> result3*
    with 
      result1* := <parallel(all(
        nabl-analyze-multiple-setup(|language, project-path); 
        nabl-analyze-multiple-collect(|language); 
        where(complete-work-unit)
      ))> file*;
      // TODO: Can be performed in parallel optimistically with re-analysis on inconsistent or outdated data.
      result2* := <all(
        nabl-analyze-multiple-setup(|language, project-path); 
        nabl-analyze-multiple-perform; 
        where(complete-work-unit)
      )> result1*;
      result3* := <parallel(all(
        nabl-analyze-multiple-setup(|language, project-path); 
        nabl-analyze-multiple-dependent; 
        where(complete-work-unit)
      ))> result2*
      
  nabl-analyze-multiple-collect(|language):
    File(partition, ast) -> Result(partition, ast, ast', oldEntry*, entry*, task*, [], [], [], [], [])
    with
      (ast', entry*, task*) := <nabl-collect(|partition, Language(language))> ast;
      index-transaction(
        oldEntry*           := <filter(nabl-diff-entry)> <index-get-all-in-partition> partition;
        <index-clear-partition> partition;
        <index-add-all(|partition)> entry*
      )
  
  nabl-analyze-multiple-perform:
    Result(partition, ast, ast', oldEntry*, entry*, task*, _, _, _, _, _) -> 
      Result(partition, ast, ast', oldEntry*, entry*, task*, error*, [], [], [], [])
    with
      nabl-collect-reads(
        error* := <perform-tasks(|partition)> task*
      ) => reads;
      <index-add-all(|partition)> reads
      
  nabl-analyze-multiple-dependent:
    Result(partition, ast, ast', oldEntry*, entry*, task*, error*, _, _, _, _) -> 
      Result(partition, ast, ast', oldEntry*, entry*, task*, error*, dependent*, [], [], [])
      with
        newEntry*          := <filter(nabl-diff-entry)> entry*;
        (added*, removed*) := <nabl-diff> (oldEntry*, newEntry*);
        changed            := [added*, removed*];
        index-transaction(
          dependent*       := <nabl-get-dependent-partitions; nabl-remove-own-partition(|partition)> changed
        )

  nabl-analyze-multiple-setup(|language, project-path) =
    (?File(partition, _) <+ ?Result(partition, _, _, _, _, _, _, _, _, _, _));
    index-setup(|language, [project-path], partition)
    
  nabl-analyze-multiple-work-units = 
    length; !(<id>, 4); mul

rules // Projections
  
  nabl-result-dependent:
    Result(_, _, _, _, _, _, _, dependent*, _, _, _) -> dependent*
