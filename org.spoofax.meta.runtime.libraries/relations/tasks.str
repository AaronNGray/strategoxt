module relations/tasks

imports
	
	relations/entries
  relations/query
  relations/incremental
  relations/interface
  task/create
  task/tasks
  nabl/uri
  nabl/incremental
  nabl/utils
	
signature
  
  constructors

    RelationLookup   : Relation * Term -> Instruction
    RelationMatch    : Relation * Term * Term -> Instruction
    RelationDistance : Relation * Term * Term -> Instruction
    
rules // Lookup

	relation-create-lookup(|ctx, rel):
		t -> <task-create-insert(|ctx); task-create-combine(|ctx)> lookup
		with
			lookup := <new-task(|ctx)> RelationLookup(rel, t)

  perform-task(|task-id):
    RelationLookup(rel, t) -> <map(relation-try-term-to-uri)> [refl-val*, stat-val*, val*, trans-val*]
    where
      t' := <relation-try-term-to-uri> t
		; <relation-add-read(|task-id)> t'
		; stat-val* := <relation-get-static(|rel)> t'
    ; val* := <get-index-relations(|rel)> t'
    ; if <relation-is-reflexive> rel then
        refl-val* := [t']
      else
        refl-val* := []
      end
    ; if <relation-is-transitive> rel then
        trans-val* := <get-index-transitive-relations(|rel)> t'
      else
        trans-val* := []
      end
      
  relation-get-static(|rel):
  	t -> val*
  	with
      stat-set := <new-iset>
    ; <try(relation-store-value(store-tuple(|stat-set)))> (rel, t)
    ; val* := <iset-elements> stat-set
      
  store-tuple(|set): elem -> <fail> with <iset-add(|elem)> set
  
rules // Match

  relation-create-match(|ctx, rel, expected):
  	actual -> <new-task(|ctx)> RelationMatch(rel, actual, expected)
  	
  relation-create-match(|ctx):
  	(rel, actual, expected) -> <new-task(|ctx)> RelationMatch(rel, actual, expected)

	perform-task(|task-id):
		RelationMatch(rel, actual, expected) -> expected
		where
	    <zip(do-relation-match(|task-id, rel))> (actual, expected) <+
		  <do-relation-match(|task-id, rel)> (actual, expected)
	
	do-relation-match(|task-id, rel):
	  (actual, expected) -> expected
	  where
      actual'   := <relation-try-term-to-uri> actual
    ; <relation-add-read(|task-id)> actual'
    ; expected' := <relation-try-term-to-uri> expected
    ; <relation-add-read(|task-id)> expected'
    ; (<relation-perform-match(|rel)> (actual, expected) <+
      <relation-perform-match(|rel)> (actual', expected') <+
      <where(<relation-is-symmetric> rel); relation-perform-match(|rel)> (expected', actual'))

  relation-perform-match(|rel):
  	(actual, expected) -> <relation-match-tuple> (rel, actual, expected)
  	// TODO: can this be transtive?
  	
	relation-perform-match(|rel):
  	(actual, expected) -> <id>
  	where
  	  <get-index-relations(|rel); fetch(relation-try-term-to-uri; ?expected)> actual <+ 
		  <where(<relation-is-transitive> rel); get-index-transitive-relations(|rel); fetch(relation-try-term-to-uri; ?expected)> actual
		  
rules // Distance
	
  relation-create-distance(|ctx, rel, values):
  	actual -> <new-task(|ctx)> RelationDistance(rel, actual, values)
	
	// Task needs to be a combinator because `expected*` needs to be queried like a list to find the distance.
	task-is-combinator = ?RelationDistance(_, _, _)
	
  perform-task(|task-id): 
  	RelationDistance(rel, actual, value*) -> [<get-index> (<try-remove-list; relation-try-term-to-uri> actual, <map(relation-try-term-to-uri)> value*)]
		// Remove list on `actual` because this task is a combinator and `actual` may only contain one element.
