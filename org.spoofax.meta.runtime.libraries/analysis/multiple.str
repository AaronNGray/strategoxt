module analysis/multiple

imports
	
  task/core
  task/store
  task/incremental
  index/core
  index/query
  nbl/collect
  nbl/tasks
  nbl/incremental
  nbl/uri
  nbl/utils
  analysis/core

rules // Multi file analysis
  
  nabl-analyze-multiple(parse-file, parallel, complete-work-unit|language, project-path):
    path* -> result*
    with
      file*   := <map(nabl-analyze-parse-file(parse-file); where(complete-work-unit))> path*;
      result* := <nabl-analyze-multiple-files(parallel, complete-work-unit|language, project-path)> file*

  nabl-analyze-parse-file(parse-file):
    path -> File(path, ast)
    with
      if not(ast := <file-exists; parse-file> path) then
        ast := ()
      end

  nabl-analyze-multiple-files(parallel, complete-work-unit|language, project-path):
    file* -> (task*, result1*)
    with
    	<vdebug(!"Analyzing files: ")> file*;
    	create-execqueue => execqueue;
      result1* := <parallel(all(
        nabl-analyze-multiple-setup(|language, project-path); 
        analyze-collect(|language); 
        where(complete-work-unit)
      ))> file*;
      task* := <all(
        nabl-analyze-multiple-setup(|language, project-path); 
        analyze-incremental(|execqueue);
        where(complete-work-unit)
      )> result1*;
      <analyze-perform-all(|execqueue)> task*
      
rules // Utility

  nabl-analyze-multiple-setup(|language, project-path) =
    (?File(partition, _) <+ ?Result(partition, _, _, _, _, _, _, _, _, _));
    where(index-setup(|language, [project-path], partition))
    
  nabl-analyze-multiple-work-units = 
    length; !(<id>, 3); mul

  //nabl-result-dependent:
  //  Result(_, _, _, _, _, _, _, _, _, dependent*, _, _, _) -> dependent*
