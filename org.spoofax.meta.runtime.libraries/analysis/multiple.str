module analysis/multiple

imports
	
  task/core
  task/store
  task/incremental
  index/core
  index/query
  nbl/collect
  nbl/tasks
  nbl/incremental
  nbl/uri

signature

  constructors
  
    File   : Path * AST                                                                                    -> File
    Result : Partition * AST * AST * List(Entry) * List(Entry) * List(Task) * List(Task) * List(Task) * List(Task) * List(Partition) * List(Term) * List(Term) * List(Term) -> Result
    // Result(partition, initial-ast, analyzed-ast, old-entry*, new-entry*, old-task*, new-task*, evaluated-task*, error-task*, dependent-partition*, error*, warning*, note*)

rules // Multi file analysis
  
  nabl-analyze-multiple(parse-file, parallel, complete-work-unit|language, project-path):
    path* -> result*
    with
      file*   := <map(nabl-analyze-parse-file(parse-file); where(complete-work-unit))> path*;
      result* := <nabl-analyze-multiple-files(parallel, complete-work-unit|language, project-path)> file*

  nabl-analyze-parse-file(parse-file):
    path -> File(path, ast)
    with
      if not(ast := <file-exists; parse-file> path) then
        ast := ()
      end

  nabl-analyze-multiple-files(parallel, complete-work-unit|language, project-path):
    file* -> result2*
    with 
      result1* := <parallel(all(
        nabl-analyze-multiple-setup(|language, project-path); 
        nabl-analyze-multiple-collect(|language); 
        where(complete-work-unit)
      ))> file*;
      result2* := <all(
        nabl-analyze-multiple-setup(|language, project-path); 
        nabl-analyze-multiple-perform; 
        where(complete-work-unit)
      )> result1*
      
  nabl-analyze-multiple-collect(|language):
    File(partition, ast) -> Result(partition, ast, analyzed-ast, old-entry*, new-entry*, old-task*, new-task*, [], [], [], [], [], [])
    with
      (analyzed-ast, new-entry*, new-task*) := <nabl-collect(|partition, Language(language))> ast;
      index-transaction(
	      old-task*  := <task-olds> partition;
	      old-entry* := <nabl-entry-olds> partition;
	      <task-partition; index-get-all-in-partition> partition;
	      <task-clear> partition;
	      <nabl-entry-clear> partition;
	      <index-add-all(|<collect-partition> partition)> new-entry*;
	      <map(store-task)> new-task*
      )
  
  nabl-analyze-multiple-perform:
    Result(partition, ast, analyzed-ast, old-entry*, new-entry*, old-task*, new-task*, _, _, _, _, _, _) -> 
      Result(partition, ast, analyzed-ast, old-entry*, new-entry*, old-task*, new-task*, [], [], [], [], [], [])
    with
      //nabl-collect-reads(
        error* := <perform-tasks> task*
      //) => reads;
      //<index-add-all(|partition)> reads
      
rules // Utility

  nabl-analyze-multiple-setup(|language, project-path) =
    (?File(partition, _) <+ ?Result(partition, _, _, _, _, _, _, _, _, _, _));
    index-setup(|language, [project-path], partition)
    
  nabl-analyze-multiple-work-units = 
    length; !(<id>, 4); mul

  nabl-result-dependent:
    Result(_, _, _, _, _, _, _, dependent*, _, _, _) -> dependent*
