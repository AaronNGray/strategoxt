module task/core

imports 
  
  task/interface
  index/core
  
signature

  sorts
  
    Task Result Instruction
  
  constructors
    
    Task     : Int * List(Int) * Instruction -> Task
    Result   : Int                           -> Result
    DoneTask : Int * Term                    -> DoneTask
    FailTask : Int * Term                    -> FailTask
    
    Done       : Term                        -> Result
    Fail       : Term                        -> Result
    Error      : Term                        -> Result
    Warning    : Term                        -> Result
    Note       : Term                        -> Result
    Dependency : List(Int)                   -> Result

		Task : Int * Instruction -> StoreTask
		TaskDep : Int * Int -> StoreTaskDep
rules // Creation
  
  new-task(|task*) = new-task(|task*, <dependent-tasks>)
  new-task(|task*, deps) = new-task(|task*, deps, <address>) 
  new-task(|task*, deps, name):
    instruction -> Result(name)
    with
      task := Task(name, deps, instruction);
      <iset-add(|task)> task*
      
  dependent-tasks = collect-all(dependent-task, union); flatten-list; make-set
  dependent-task = ?Result(<id>) 
  dependent-task =
    has-annos; get-annos; dependent-tasks
  
rules // Execution
  
  perform-tasks(|partition) = where(map(store-task(|partition))); repeat(perform-task(|partition))
    
  perform-task(|partition) =
    split-fetch-keep(perform-single-task) => (t1*, (n, res, i), t2*);
    switch !res
      case ?Done(tr):
        <index-add(|partition)> DoneTask(n, tr);
        <map(try(Task(id, effectively(remove-all(?n)), try(alltd(insert-result(|n, tr))))))> [t1*, t2*]
      case ?Fail(fr) => tr:
        <index-add(|partition)> FailTask(n, fr);
        <map(try(Task(id, effectively(remove-all(?n)), try(alltd(insert-result(|n, tr))))))> [t1*, t2*]
      case ?Dependency(d*):
      	<store-task-deps(|partition, n)> d*;
      	![t1*, t2*, Task(n, d*, i)]
      end

  perform-single-task:
    Task(n, [], i) -> (n, <perform-task> i, i)

rules // Store
	
	store-task(|partition):
		Task(nr, d*, i) -> <id>
		where
			<index-add(|partition)> Task(nr, i);
			<store-task-deps(|partition, nr)> d*
			
	store-task-deps(|partition, nr) =
		map(create-task-dep(|nr)); index-add-all(|partition)
	
	create-task-dep(|nr) =
		!TaskDep(nr, <id>)
    
rules // Utility
  
  effectively(s) = ?t; s; not(?t)  
     
  insert-result(|n, r): Result(n) -> r 
    
  insert-result(|n, r) = 
    has-annos; 
    !(<id>, <get-annos; map(try(insert-result(|n, r)))>); 
    set-annos
