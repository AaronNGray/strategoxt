module task/core

imports 
  
  task/interface
  task/store
  index/core
  index/query
  nbl/utils // TODO: should not depend on NaBl.
  
signature

  sorts
  
    Task Result Instruction
  
  constructors
    
    Task     : Int * List(Int) * Instruction * Partition -> Task
    Result   : Int                                       -> Result
    DoneTask : Int * Term                                -> DoneTask
    FailTask : Int * Term                                -> FailTask
    
    Done       : Term               -> Result
    Done       : Term * List(Entry) -> Result
    Fail       : Term               -> Result
    Fail       : Term * List(Entry) -> Result
    Error      : Term               -> Result
    Warning    : Term               -> Result
    Note       : Term               -> Result
    Dependency : List(Int)          -> Result
		
rules // Creation
  
  new-task(|task*) = new-task(|task*, <dependent-tasks>)
  new-task(|task*, deps) = desugar-task(|task*) <+new-task(|task*, deps, <address>) 
  new-task(|task*, deps, name):
    instruction -> Result(name)
    with
    	partition := <index-get-current-partition>;      // TODO: Partition should be a term argument.
    	nr        := <address> instruction;
      task      := Task(nr, deps, instruction, partition);
      <iset-add(|task)> task*
      
  dependent-tasks = collect-all(dependent-task, union); flatten-list; make-set
  dependent-task = ?Result(<id>) 
  dependent-task =
    has-annos; get-annos; dependent-tasks
  
rules // Execution
  
  perform-tasks:
  	task* -> (<iset-elements> elem*, error*)
  	with
  		new-iset      => elem*;
  		new-hashtable => results;
  		error*        := <perform-tasks-internal(|elem*, results)> task*
  
  perform-tasks-internal(|elem*, results):
  	task* -> result
  	with
  		(eval-task*, other-task*) := <partition(task-satisfies-dependencies(|results), not(task-satisfies-dependencies(|results)))> task*;
  		if [] := eval-task* then
  			result := other-task*
  		else
	  		dep-task* := <mapconcat(perform-one-task-internal(|elem*, results))> eval-task*;
	  		rec-task* := [other-task*, dep-task*];
	  		result    := <perform-tasks-internal(|elem*, results)> rec-task*  			
			end
  		
  		//if not([] := rec-task*) then
  		//	
			//else
			//	
			//end
    
  perform-one-task-internal(|elem*, results):
  	Task(n, d*, i, p) -> [new-task]
  	with
  		res := <perform-instruction(|n, results)> i; 
	    //split-fetch-keep(perform-single-task(|results)) => (t1*, (n, res, i, p), t2*);
	    <debug(!"Performing task: ")> n;
	    switch !res
	      case ?Done(tr, e*):
	      	<iset-addlist(|e*)> elem*;
	        <index-add(|p)> DoneTask(n, tr);
	        completed-task(|n, tr, results);
	        new-task := []
	      case ?Done(tr):
	        <index-add(|p)> DoneTask(n, tr);
	        completed-task(|n, tr, results);
	        new-task := []
	      case ?Fail(fr, e*):
	      	<iset-addlist(|e*)> elem*;
	        <index-add(|p)> FailTask(n, fr);
	        completed-task(|n, Fail(fr), results);
	        new-task := []
	      case ?Fail(fr):
	        <index-add(|p)> FailTask(n, fr);
	        completed-task(|n, Fail(fr), results);
	        new-task := []
	      case ?Dependency(new-dep*):
	      	<vdebug(!"Found dynamic dependencies: ")> d*;
	      	new-task := Task(n, new-dep*, i, p)
	    	otherwise:
	    		<with(fail|"Unexpected result from perform-task: ")> res
	      end

	task-satisfies-dependencies(|results):
		Task(_, d*, _, _) -> <id>
		where
			<satisfies-dependencies(|results)> d*

  perform-instruction(|n, results):
    i -> <perform-task(|n)> i'
    where
    	i' := <task-insert-results(|results)> i
    
  completed-task(|n, res, results) =
  		<gohla-hashtable-put(|results)> (n, res)
  		
	task-insert-results(|results):
		i -> i'
		with
			i' := <alltd(insert-result(|results))> i
			
  insert-result(|results) = 
		has-annos; 
		!(<id>, <get-annos; map(task-insert-results(|results))>); 
		set-annos
			
	insert-result(|results): Result(n) -> <gohla-hashtable-get(|results)>  n
		
	satisfies-dependencies(|results):
		dependency* -> <?[]> res*
		where
			res* := <remove-all(gohla-hashtable-get(|results))> dependency*
			
	gohla-hashtable-get(|results):
		n -> <hashtable-get(|n)> results

	gohla-hashtable-put(|results): 
		(t1, t2) -> <hashtable-put(|t1, t2)> results
		
rules // Projections
	
	task-nr:
		Task(nr, _, _, _) -> nr
		
	task-partition:
		Task(_, _, _, p) -> p
		
	task-result-nr:
		Result(nr) -> nr

rules // Utility
  
  effectively(s) = ?t; s; not(?t)  
