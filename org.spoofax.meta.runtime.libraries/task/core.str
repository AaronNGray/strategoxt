module task/core

imports 
  
  task/interface
  index/core
  index/query
  
signature

  sorts
  
    Result Instruction
  
  constructors
    
    Result : Int -> Result
    Fail : Result
    
    Dependency : List(Int) -> Result
    
    Error   : Term -> Result
    Warning : Term -> Result
    Note    : Term -> Result
		
rules // Creation
  
  new-task(|partition) = new-task(|partition, <dependent-tasks>)
  new-task(|partition, dependencies) = desugar-task(|partition) <+ task-add-task(|partition, dependencies, <id>)
      
  dependent-tasks = collect-all(dependent-task, union); flatten-list; make-set
  dependent-task = ?Result(<id>) 
  dependent-task =
    has-annos; get-annos; dependent-tasks

rules // Dependencies
	
  task-create-dependencies =
  	collect-all(?Result(<id>));
  	!Dependency(<id>)
  	
	task-has-dependencies =
		fetch(?Dependency(_))
		
	task-collect-dependencies =
		collect-all(?Dependency(<id>));
		concat;
		where(Hd);
		!Dependency(<id>)

rules // Results
	
	insert-result =
		switch id
			case has-annos  : !(<id>, <get-annos; insert-result>); set-annos
			case is-list    : filter(insert-result; not(?[]))
			case ?Result(n) : (task-get-result(|n) <+ (task-has-failed(|n); ![]) <+ with(fail|"Cannot insert result."))
			otherwise       : all(insert-result)
		end
	
rules // Projections
	
	task-result-id:
    Result(taskID) -> taskID

rules // API
	
	external task-api-setup(|project-path)
	external task-api-start-collection(|partition)
	external task-api-stop-collection(|partition)
	external task-api-add-task(|partition, dependencies, instruction)
	external task-api-get-result(|taskID)
	external task-api-has-failed(|taskID)
	external task-api-evaluate(perform-task, insert-result|)
	external task-api-reset(|)
	
	task-setup(|project-path)                            = task-api-setup(|project-path)
	task-start-collection(|partition)                    = task-api-start-collection(|partition)
	task-stop-collection(|partition)                     = task-api-stop-collection(|partition)
	task-add-task(|partition, dependencies, instruction) = task-api-add-task(|partition, dependencies, instruction)
	task-get-result(|taskID)                             = task-api-get-result(|taskID)
	task-has-failed(|taskID)                             = task-api-has-failed(|taskID)
	task-evaluate                                        = task-api-evaluate(perform-task, insert-result)
	task-reset                                           = task-api-reset
	  
rules // Execution
  
  /*perform-tasks(|execqueue, runtimedeps, invruntimedep):
  	_ -> (<iset-elements> elem*, <iset-elements> error*)
  	with
  		new-iset => elem*;
  		new-iset => error*;
  		while-imperative(nabl-dequeue-task(|execqueue); measure-time(perform-one-task(|execqueue, runtimedeps, invruntimedep, elem*, error*), id | "perform-tasks-one"))
    
  perform-one-task(|execqueue, runtimedeps, invruntimedep, elem*, error*):
  	Task(n, d*, i, p) -> <id>
  	with
  		vdebug(!"Performing task: ");
  		if res := <perform-instruction(|n)> i then
		    switch !res
		      case ?Done(tr, e*):
		      	<iset-addlist(|e*)> elem*;
		        <index-add(|p); vdebug(!"Done: ")> DoneTask(n, tr);
		        <task-try-schedule-task(|runtimedeps, invruntimedep, execqueue)> n
		      case ?Done(tr):
		        <index-add(|p); vdebug(!"Done: ")> DoneTask(n, tr);
		        <task-try-schedule-task(|runtimedeps, invruntimedep, execqueue)> n
		      case ?Fail(fr, e*):
		      	<iset-addlist(|e*)> elem*;
		        <index-add(|p); vdebug(!"Fail: ")> FailTask(n, fr);
		        <task-try-schedule-task(|runtimedeps, invruntimedep, execqueue)> n
		      case ?Fail(fr):
		        <index-add(|p); debug(!"Fail: ")> FailTask(n, fr);
		        <task-try-schedule-task(|runtimedeps, invruntimedep, execqueue)> n
		      case ?Dependency(new-dep*):
		      	<vdebug(!"Found dynamic dependencies: ")> new-dep*;
		      	<task-add-runtime-dependency(|runtimedeps, invruntimedep, n)> new-dep*
		      case ?e@Error(_):
		      	<iset-add(|e)> error*
		    	otherwise:
		    		<with(fail|"Unexpected result from perform-task: ")> res
		      end
			else
        //<index-add(|p)> FailTask(n, []);
        //<task-try-schedule-task(|runtimedeps, execqueue)> n
        vdebug(!"FAILED TASK: ")
			end

  perform-instruction(|n):
    i -> <perform-task(|n)> i'
    where
    	i' := <alltd(insert-result)>  i
	
  insert-result = 
		has-annos; 
		!(<id>, <get-annos; alltd(insert-result)>); 
		set-annos
			
	insert-result: Result(n) -> <task-get-result> n
		
rules // Projections
	
	task-nr:
		Task(nr, _, _, _) -> nr
		
	task-partition:
		Task(_, _, _, p) -> p
		
	task-result-nr:
		Result(nr) -> nr

rules // Utility
  
  external while-imperative(s|)
  
  external gohla-iset-get-one(|)
  
  effectively(s) = ?t; s; not(?t)  */

