module task/core

imports 
  
  task/interface
  task/store
  index/core
  index/query
  
signature

  sorts
  
    Task Result Instruction
  
  constructors
    
    Task     : Int * List(Int) * Instruction * Partition -> Task
    Result   : Int                                       -> Result
    DoneTask : Int * Term                                -> DoneTask
    FailTask : Int                                       -> FailTask
    
    Done       : Term               -> Result
    Done       : Term * List(Entry) -> Result
    Fail       :                       Result
    Fail       : List(Entry)        -> Result
    Dependency : List(Int)          -> Result
		
rules // Creation
  
  new-task(|task*) = new-task(|task*, <dependent-tasks>)
  new-task(|task*, deps):
    instruction -> Result(nr)
    with
    	partition := <index-get-current-partition>;      // TODO: Partition should be a term argument.
    	nr        := <address> instruction;
      task      := Task(nr, deps, instruction, partition);
      <iset-add(|task)> task*
      
  dependent-tasks = collect-all(dependent-task, union); flatten-list; make-set
  dependent-task = ?Result(<id>) 
  dependent-task =
    has-annos; get-annos; dependent-tasks
  
rules // Execution
  
  perform-tasks:
  	task* -> (<iset-elements> elem*, error*)
  	with
  		new-iset => elem*;
  		error*   := <repeat(perform-task-internal(|elem*)); map(debug(!"ERROR: "))> task*
    
  perform-task-internal(|elem*) =
    split-fetch-keep(perform-single-task) => (t1*, (n, res, i, p), t2*);
    switch !res
      case ?Done(tr, e*):
      	<iset-addlist(|e*)> elem*;
        <index-add(|p)> DoneTask(n, tr);
        <completed-task(|n, tr)> [t1*, t2*]
      case ?Done(tr):
        <index-add(|p)> DoneTask(n, tr);
        <completed-task(|n, tr)> [t1*, t2*]
      case ?Fail(e*):
      	<iset-addlist(|e*)> elem*;
        <index-add(|p)> FailTask(n);
        <completed-task(|n, Fail())> [t1*, t2*]
      case ?Fail():
        <index-add(|p)> FailTask(n);
        <completed-task(|n, Fail())> [t1*, t2*]
      case ?Dependency(d*):
      	<store-task-deps(|p, n)> d*;
      	![t1*, t2*, Task(n, d*, i, p)]
    	otherwise:
    		<with(fail|"Unexpected result from perform-task: ")> res
      end

  perform-single-task:
    Task(n, [], i, p) -> (n, <perform-task(|n)> i, i, p)
    
  completed-task(|n, res) =
  	map(try(task-insert-results(|n, res)))
  	
	task-insert-results(|n, res) = 
		Task(id, effectively(remove-all(?n)), try(alltd(insert-result(|n, res))), id)
		
rules // Projections
	
	task-nr:
		Task(nr, _, _, _) -> nr
		
	task-result-nr:
		Result(nr) -> nr

rules // Utility
  
  effectively(s) = ?t; s; not(?t)  
     
  insert-result(|n, r): Result(n) -> r 
    
  insert-result(|n, r) = 
		has-annos; 
		!(<id>, <get-annos; map(try(insert-result(|n, r)))>); 
		set-annos
