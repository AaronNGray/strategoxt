module task/incremental

imports 
  
  task/core
  task/store
  index/core
  index/query

rules // Construction
		
	// HACK: Remove artificial TaskPartition()
	task-remove-partition:
		(file, _) -> (file, [])
		
	task-reconstruct:
		nr -> <map(task-reconstruct-create(|nr, d*, i))> p*
		with
			t@Task(_, i) := <task-get> nr;
			p*           := <index-get-partitions-of> t; 
			d*           := <task-get-dependencies> nr
			
	task-reconstruct-create(|nr, d*, i):
		p -> Task(nr, d*, i, <task-remove-partition> p)

rules // Index
	
	task-olds:
		partition -> <task-partition; index-get-all-in-partition; filter(task-diff-entry)> partition
			
	task-clear:
		partition -> <task-partition; index-clear-partition> partition
  
rules // Task diff
	
	task-diff:
		(old, new) -> (added, removed)
		where
      added   := <diff(task-eq)> (new, old);
      removed := <diff(task-eq)> (old, new)
      
  task-diff-entry =
  	?Task(_, _)
  	
	task-eq:
		(t1, t2) -> <id>
		where
			<eq> (<task-nr> t1, <task-nr> t2)

rules // Incremental
	
  task-incremental:
  	(old, new) -> (added'*, removed'*)
  	with
  		(added*, removed*) := <task-diff> (old, new);
  		removed'*          := <filter(task-confirm-removed)> removed*;
  		added'*            := <filter(task-confirm-added)> added*
  		
  task-incremental-no-confirm-added:
  	(old, new) -> (added*, removed'*)
  	with
  		(added*, removed*) := <task-diff> (old, new);
  		removed'*          := <filter(task-confirm-removed)> removed*
  		
	task-confirm-removed =
		where(task-nr; task-get-all; not(Hd))
		
	task-confirm-added =
		where(task-nr; task-get-all; Tl; not(Hd))
		
	task-dependent:
		nr -> [task*, task-rec*]
		where
			<is-int> nr
		with
			d*        := <task-get-dependent> nr;
			task*     := <mapconcat(task-reconstruct)> d*;
			task-rec* := <task-dependent-rec> task*
			
	task-dependent:
		Task(nr, _, _, _) -> [task*, task-rec*]
		with
			d*        := <task-get-dependent> nr;
			task*     := <mapconcat(task-reconstruct)> d*;
			task-rec* := <task-dependent-rec> task*

	task-dependent-rec:
		task* -> task-rec* 			
		with
			if not([] := task*) then
				task-rec* := <mapconcat(task-dependent)> task*
			else
				task-rec* := []
			end

rules // Inserting results
	
	task-insert-own-existing-results:
		t@Task(_, d*, _, _) -> <task-insert-existing-results(|d*)> t 

	task-insert-existing-results(|nr*):
		task -> <foldl(task-insert-existing-result <+ Snd)> (nr*, task)
		
	task-insert-existing-result:
		(nr, task) -> <task-insert-results(|nr, res)> task
		where
			res := <task-get-result> nr
			
	task-insert-results(|n, res) = 
		Task(id, effectively(remove-all(?n)), try(alltd(insert-result(|n, res))), id)
		
	insert-result(|n, r): Result(n) -> r 
    
  insert-result(|n, r) = 
		has-annos; 
		!(<id>, <get-annos; map(try(insert-result(|n, r)))>); 
		set-annos
	