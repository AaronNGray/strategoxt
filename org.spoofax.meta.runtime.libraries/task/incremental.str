module task/incremental

imports 
  
  task/core
  task/store
  index/core
  index/query
  
rules // Diff
	
	task-diff:
		(old, new) -> (added, removed)
		where
      added   := <diff(task-eq)> (new, old);
      removed := <diff(task-eq)> (old, new)
      
  task-diff-entry =
  	?Task(_, _)
      
rules // Incremental
	
	task-olds:
		partition -> <task-partition; index-get-all-in-partition; filter(task-diff-entry)> partition
			
	task-clear:
		partition -> <task-partition; index-clear-partition> partition
	
  task-incremental:
  	(old, new) -> [added*, depTask*]
  	with
  		(added*, removed*) := <task-diff> (old, new);
  		<map(debug(!"Added task: "))> added*;
  		<map(debug(!"Removed task: "))> removed*;
  		<map(task-nr; debug(!"Removing results for: "); task-remove-result)> removed*;
  		depTask* := <mapconcat(task-nr; task-dependent); map(debug(!"Dependent task: "))> [removed*]
  		
	task-remove-result:
		nr -> <id>
		with
			<index-remove-all> DoneTask(nr, ());
			<index-remove-all> FailTask(nr, ())
		
	task-dependent:
		nr -> task*
		with
			nr*   := <task-get-dependent> nr; // TODO: Should be dependent?
			task* := <map(task-reconstruct)> nr*

rules // Equality
	
	task-eq:
		(t1, t2) -> <id>
		where
			<eq> (<task-nr> t1, <task-nr> t2)
		
rules // Construction
		
	// HACK: Remove artificial TaskPartition()
	task-remove-partition:
		(file, TaskPartition()) -> (file, [])
		
	task-reconstruct:
		nr -> Task(nr, d*, i, <task-remove-partition> p)
		with
			(p, Task(_, i)) := <task-get-with-partition> nr;
			d*              := <task-get-dependencies> nr

	task-insert-own-existing-results:
		t@Task(_, d*, _, _) -> <task-insert-existing-results(|d*)> t 

	task-insert-existing-results(|nr*):
		task -> <foldl(task-insert-existing-result <+ Snd)> (nr*, task)
		
	task-insert-existing-result:
		(nr, task) -> <task-insert-results(|nr, res)> task
		where
			res := <task-get-result> nr
	