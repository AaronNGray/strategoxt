module task/tasks

imports
	
	task/core
  task/messages
	task/interface
  
signature

	constructors
		
    Id       : Term              -> Instruction
    Choice   : List(List(Term))  -> Instruction
    Sequence : List(Term)        -> Instruction
    Combine  : List(Term)        -> Instruction
    Collect  : List(Term)        -> Instruction
    Not      : Result            -> Instruction
    Index    : Int * List(Term)  -> Instruction
    Length   : List(Term)        -> Instruction
    Insert   : Term              -> Instruction
    Rewrite  : ID * Term         -> Instruction

rules // Identity
  
  /**
  * Create an identity task
  * @type term -> Result(Int)
  */
	task-create-id(|ctx) = <new-task(|ctx)> Id(<id>)
  
  task-create-id(|ctx, dep*) =
    ?term;
    all-dep* := <union> (<dependent-tasks> dep*, <dependent-tasks>);
    <new-task(|ctx, all-dep*)> Id(term)
  
  perform-task(|nr) = ?Id(<MkSingleton>)

rules // Choice
	
  /**
  * Create a choice task
  * @type List(task) -> Result(Int)
  */
  task-create-choice(|ctx) = <new-task(|ctx)> Choice(<id>)
  
  /**
  * Create a choice task between two tasks, where t1 and t2 take a ctx and produce a task.
  * @type term -> Result(Int)
  */
  task-create-choice(t1, t2|ctx):
    term -> <task-create-choice(|ctx)> [<t1(|ctx)> term, <t2(|ctx)> term]
	
	task-is-combinator = ?Choice(_)
  perform-task(|nr)  = ?Choice(<fetch-elem(not(?[]))>)
  
rules // Sequence
	
  /**
  * Create a sequence task
  * @type List(task) -> Result(Int)
  */
  task-create-sequence(|ctx) = <new-task(|ctx)> Sequence(<id>)

  /**
  * Create a sequence task between two tasks, where t1 and t2 take a ctx and produce a task.
  * @type term -> Result(Int)
  */
  task-create-sequence(t1, t2|ctx):
    term -> <task-create-sequence(|ctx)> [<t1(|ctx)> term, <t2(|ctx)> term]
	
	task-is-combinator = ?Sequence(_)
  perform-task(|nr)  = ?Sequence(<not(fetch-elem(?[])); last>)

rules // Combine
       
  /**
  * Create a combine task
  * @type List(task) -> Result(Int)
  */
	task-create-combine(|ctx)= <new-task(|ctx)> Combine(<id>)
       
  task-is-combinator = ?Combine(_)
  perform-task(|nr)  = ?Combine(<map(is-list <+ MkSingleton)>); concat

rules // Collect
       
  /**
  * Create a collect task
  * @type List(task) -> Result(Int)
  */
	task-create-collect(|ctx) = <new-task(|ctx)> Collect(<id>)
       
  task-is-combinator = ?Collect(_)
  perform-task(|nr)  = ?Collect(<map(is-list <+ MkSingleton)>); concat; MkSingleton

rules // Where
  
  task-create-where(s|ctx):
    term -> <task-create-sequence(|ctx)> <try(flatten-list)> [<s> term, term]

rules // Negation
  
  /**
  * Create negation task
  * @type task -> Result(Int)
  */
  task-create-not(|ctx) = <new-task(|ctx)> Not(<id>)
  
  /**
  * Create negation task, where t takes a ctx argument and produces the task to be negated 
  */
  task-create-not(t|ctx) = t(|ctx); task-create-not(|ctx)
  
  /**
  * Negation on the success of a task
  * @type: Not(result) -> !Success(result)
  */
  perform-task(|nr):
    Not(result) -> ()
    where
      <?[]> result
      
  task-is-combinator = ?Not(_)
  
rules // Index
  
  perform-task(|nr) = ?Index(i, <index(|i)>);  MkSingleton
  
rules // Length
	
  perform-task(|nr) = ?Length(<length>);  MkSingleton

rules // Result insertion
	
	task-create-insert(|ctx):
		term -> <new-task(|ctx)> Insert(term)
	
	perform-task(|nr):
		Insert(term) -> result
		where
		  inserted := <insert-results-or-create-dependency> term
		; result   := <try(task-has-dependencies; task-collect-dependencies)> inserted
		  
	task-is-combinator = ?Insert(_)
  
rules // General purpose rewrite
      	
  /**
  * Create a rewrite task
  * @type term -> Result(Int)
  */
  task-create-rewrite(|ctx, key):
  	term -> <new-task(|ctx)> Rewrite(key, term)
      	
  perform-task(|nr) = ?Rewrite(key, term); <task-rewrite; MkSingleton> (key, term)
  
rules // Cyclic task execution
	
	perform-cyclic-task(|nr) = fail
	
	perform-task(|nr):
		(instruction, "cyclic") -> <perform-cyclic-task(|nr) <+ perform-task(|nr)> instruction
