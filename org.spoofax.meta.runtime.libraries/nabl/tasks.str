module nabl/tasks

imports 
  
  task/core
  task/tasks
  task/utils
  nabl/lookup
  nabl/collect
  nabl/query
  nabl/incremental
  nabl/interface
  nabl/uri
  nabl/utils
  nabl/entries
  properties/entries
  properties/eq
  properties/query
  
signature
  
  constructors
    
    CollectDefs            : Term                                      -> Instruction
    ResolveDefs            : Scope * Namespace * Name * Prop           -> Instruction
    ResolveAllDefs         : Scope * Namespace                         -> Instruction
    ResolveAllDefs         : Scope * Namespace * Name * Prop           -> Instruction
    CheckDefs              : Namespace * URI                           -> Instruction
    PropConstraint         : Kind * Expected * Result                  -> Instruction
        
rules // Collects all definitions in a term
  
  nabl-create-collectdefs(|ctx):
  	term -> <new-task(|ctx)> CollectDefs(term)

  nabl-create-collectdefs(|ctx, dep*):
  	term -> <new-task(|ctx, all-dep*)> CollectDefs(term)
  	with 
    	all-dep* := <merge-dependencies(|dep*)> term
  	
  perform-task(|nr): 
    CollectDefs(term) -> <(?Def(_) <+ try(nabl-get-name); get-annos; mapconcat(?Def(_); MkSingleton + ?Use(<is-list <+ MkSingleton>)))> term 

rules // Resolve definitions in a scope of a certain namespace and name (stops when definitions are found in a scope)
  
  nabl-create-resolvedefs(|ctx, ns, name, prop*):
  	scope -> <new-task(|ctx)> ResolveDefs(scope, ns, name, prop*)

  
  perform-task(|task-id):
  	ResolveDefs(scope, ns, name, prop*) -> result
  	where
  		uri    := <nabl-uri> scope;
  		name'  := <try-remove-list; strip-annos> name;
  		<nabl-add-name-read(|task-id, ns, name')> uri;
  		def*   := <nabl-lookup(|ns, name')> uri;
  		result := <filter(filter-defs-props(|prop*)); not(?[])> def*
  		
	task-short-circuit = ?ResolveDefs(_, _, _, _)

rules // Resolve all definitions in a scope of a certain namespace and name
	
	// TODO: replace all ResolveAllDefs/4 with factory
  nabl-create-resolvealldefs(|ctx, ns, name, prop*):
  	scope -> <new-task(|ctx)> ResolveAllDefs(scope, ns, name, prop*)
  
  
  perform-task(|nr):
    ResolveAllDefs(scope, ns, name, prop*) -> <perform-task(|nr)> ResolveDefs(scope, ns, name, prop*)

rules // Resolve all definitions in a scope of a certain namespace

	// TODO: replace all ResolveAllDefs/2 with factory
  nabl-create-resolvealldefs(|ctx, ns):
  	scope -> <new-task(|ctx)> ResolveAllDefs(scope, ns)

	
  perform-task(|nr):
  	ResolveAllDefs(scope, ns) -> def*
  	where
  		uri  := <nabl-uri> scope;
  		<nabl-add-ns-read(|nr, ns)> uri;
  		def* := <nabl-lookup-all(|ns)> uri;
  		not(?[])

	nabl-resolve-all-defs-subtasks(|partition, ns, prop*, range):
		uri -> [task|subtasks]
		with
			task := <nabl-resolve-all-defs-subtasks-one(|partition, ns, prop*, range)> uri;
      switch !range
      	case One(): ![]
      	case All(): <nabl-uri-parent < nabl-resolve-all-defs-subtasks(|partition, ns, prop*, range) + ![]> uri
    	end => subtasks
		
	nabl-resolve-all-defs-subtasks-one(|partition, ns, prop*, range):
		uri -> filtered
		with
			def-task := <new-task(|partition)> ResolveAllDefs(uri, ns)
	  ; filtered  := <nabl-use-propconstraint(|partition)> (def-task, prop*)

rules // Check if a definition is in given namespace

	// TODO: replace all CheckDefs with factory
  nabl-create-checkdefs(|ctx, ns):
  	definition -> <new-task(|ctx)> CheckDefs(ns, definition)

		
	perform-task(|nr):
		CheckDefs(ns, d) -> d
		where
			<nabl-uri; nabl-uri-namespace; ?ns> d

rules // Filter definitions by properties
  		
	filter-defs-props(|prop*):
		definition -> <map(filter-defs-prop(|definition)); !definition> prop*
	 	
	filter-defs-prop(|definition):
		Prop(kind, expected, _) -> definition
		where
			uri    := <nabl-uri> definition;
      value  := <get-index-property(|kind)> uri;
      value' := <insert-results-or-delay> value;
      <filter-defs-prop-eq(|expected, value')> kind

	filter-defs-prop-eq(|expected, value):
		kind -> <nabl-property-eq> (kind, Eq(), (expected, value))
		
	filter-defs-prop-eq(|expected, value):
		kind -> <nabl-property-eq> (kind, Eq(), (expected, <try-remove-list> value))
	
	
	// TODO: replace all PropConstraint with factory
  nabl-create-propconstraint(|ctx, kind, definition):
  	expected -> <new-task(|ctx)> PropConstraint(kind, expected, definition)
	

	perform-task(|task-id):
		PropConstraint(kind, expected, definition) -> <filter-defs-prop(|definition)> Prop(kind, expected, [])
