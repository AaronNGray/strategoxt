module types/tasks

imports 
	
	nbl/resolve
	nbl/collect
	nbl/entries
	nbl/query
	nbl/utils
  types/interface
  task/core
  
signature
  
  constructors

    PropLookup : Property * Term -> Instruction    
    PropCalc   : Term * Term     -> Instruction
    PropCalc   : Term            -> Instruction
    PropCheck  : Term * Term     -> Instruction

rules
  
  perform-task(|n): 
  	PropLookup(kind, t) -> result
  	where
  		resolved := <nabl-collect-one-resolved-def> t;
  		switch !resolved
  			case ?Def(_) : nabl-get-property(|kind); insert-results-or-create-dependency; try-make-list
  			otherwise    : id
  		end => result
  
  avoid-task(|dep*):
    PropCalc(_) -> <perform-task(|0)> 
    where
      [] := dep*
  	
  perform-task(|n): 
  	PropCalc(result) -> <try-make-list> result
  
  // TODO: remove this one	
  perform-task(|n): 
    PropCalc(result, dep*) -> <perform-task(|n)> PropCalc(result)
    with
      fail
    where 
      <if is-list then Hd end> dep*
  
  avoid-task(|dep*):
    PropCheck(actual, expected) -> <perform-task(|0) <+ ![]> 
    where
      [] := dep*
  	
  perform-task(|n): 
  	PropCheck(term, expected) -> <perform-task(|n)> PropCheck(<try-make-list> term, <try-make-list> expected)
  	where
  		not(<is-list> term; <is-list> expected)
			
  perform-task(|n): 
  	PropCheck(term*, expected*) -> <try-make-list> term*
  	where
  		<is-list> term*;
  		<is-list> expected*;
  		<cart(type-prop-eq)> (term*, expected*)

