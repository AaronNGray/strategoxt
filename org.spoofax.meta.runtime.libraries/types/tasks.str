module types/tasks

imports 
	
	nbl/resolve
	nbl/collect
	nbl/entries
	nbl/query
	nbl/utils
  types/interface
  task/core
  
signature
  
  constructors

    PropLookup : Property * Term -> Instruction    
    PropCalc   : Term * Term     -> Instruction
    PropCalc   : Term            -> Instruction
    PropCheck  : Term * Term     -> Instruction

rules
  
  perform-task(|n): 
  	PropLookup(kind, t) -> result
  	where
  		resolved := <nabl-collect-one-resolved-def> t;
  		switch !resolved
  			case ?Def(_) : nabl-get-property(|kind); insert-results-or-create-dependency; try-make-list
  			otherwise    : id
  		end => result
  
  avoid-task(|dep*):
    PropCalc(_) -> <perform-task(|0)> 
    where
      [] := dep*
  	
  perform-task(|n): 
  	PropCalc(result) -> <try-make-list> result
  
  // TODO: remove this one	
  perform-task(|n): PropCalc(result, dep*) -> <perform-task(|n)> PropCalc(result)
  
  avoid-task(|dep*):
    PropCheck(actual, expected) -> <perform-task(|0)> 
    where
      [] := dep*
  
  perform-task(|n): 
  	PropCheck(term, expected) ->  term*
  	where
  		term*     := <try-make-list> term;
  		expected* := <try-make-list> expected;
  		<cart(eq)> (term*, expected*)
