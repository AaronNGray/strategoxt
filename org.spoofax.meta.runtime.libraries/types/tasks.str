module types/tasks

imports 
	
	nbl/resolve
	nbl/collect
	nbl/entries
	nbl/query
	nbl/utils
	nbl/uri
	nbl/tasks
  types/interface
  task/core
  
signature
  
  constructors

    PropLookup : Property * Term -> Instruction    
    PropCalc   : Term * Term     -> Instruction
    PropCalc   : Term            -> Instruction
    PropCheck  : Term * Term     -> Instruction

rules
  
  perform-task(|n): 
  	PropLookup(kind, t) -> result
  	where
  		resolved := <nabl-collect-one-resolved-def> t;
  		switch id
  			// HACK: task-result-combinations also creates dependencies if any result has not been solved yet.
  			// Proper way would be to decompose the PropLookup into a ResolveUseToDef, GetProperty and InsertCombinations task.
  			// TODO: is this read needed?
  			case ?Def(_) : where(nabl-uri; nabl-add-read(|n)); nabl-get-property(|kind); task-result-combinations
  			otherwise    : id
  		end => result
  
  avoid-task(|dep*):
    PropCalc(_) -> <perform-task(|0)> 
    where
      [] := dep*
  	
  perform-task(|n): 
  	PropCalc(result) -> result
  
  avoid-task(|dep*):
    PropCheck(actual, expected) -> <perform-task(|0) <+ ![]> 
    where
      [] := dep*
  	
  perform-task(|n): 
  	PropCheck(actual, expected) -> actual
  	where
  		<type-prop-eq> (actual, expected)
