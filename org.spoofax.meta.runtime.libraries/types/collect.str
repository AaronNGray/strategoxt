module types/collect

imports 
  task/-
  types/-
  nbl/-

strategies
  
  annotate-property-tasks(|task*) =
    !([Type()|<custom-properties <+ ![]>], <id>)
  ; foldl(annotate-property-task(|task*) <+ Snd)
  
  annotate-property-task(|task*):
    (kind, term{a*}) -> term{(kind, prop), a*}
    where
      not(<property-task(|kind)> term)
    where
      prop := <new-property-task(|task*)> 
     
  new-property-task(|task*):
    (Type(), term) -> <type-of(|task*)> term

  property-task(|kind) = 
    get-annos
  ; fetch-elem(?(kind, task))
  ; !task
 
  property-task(|kind, task*) = 
     property-task(|kind)
  <+ <new-property-task(|task*)> (kind, <id>)
    
strategies
  
  prop-calc(|task*, dep*) = 
    where(all-dep* := <union> (<dependent-tasks>, dep*));
    <new-task(|task*, all-dep*)> PropCalc(<id>)
    
  prop-check(|kind, task*, dep*):
    (term, expected) -> task
    where
      actual    := <property-task(|kind)> term
    ; expected* := <try-make-list> expected
    ; check*    := <map(<new-task(|task*)> PropCheck(actual, <id>))> expected*
    ; task      := <new-task(|task*, [dep*, check*])> Choice(check*)
     
  prop-lookup(|kind, task*, dep*) = 
    where(all-dep* := <union> (dep*, <dependent-tasks>))
  ; <new-task(|task*, all-dep*)> PropLookup(kind, <id>) 
  
  prop-unify(|task*, relation) = 
    <new-task(|task*)> Match(relation, <Fst>, <Snd>)
  
strategies
  
  type-is(|task*)           = prop-calc(|task*, [])
  type-is(|task*, dep*)     = prop-calc(|task*, dep*)
  
  type-check(|task*)        = prop-check(|Type(), task*, [])
  type-check(|task*, dep*)  = prop-check(|Type(), task*, dep*)

  type-lookup(|task*)       = prop-lookup(|Type(), task*, [])
  type-lookup(|task*, dep*) = prop-lookup(|Type(), task*, dep*)
  
  type-unify(|task*, relation) = prop-unify(|task*, relation)
