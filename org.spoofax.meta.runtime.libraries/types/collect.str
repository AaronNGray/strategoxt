module types/collect

imports 
  task/-
  types/-
  nbl/-
  
strategies
  
  prop-calc(|task*, dep*) = 
    where(all-dep* := <union> (<dependent-tasks>, dep*));
    <new-task(|task*, all-dep*)> PropCalc(<id>)
    
  prop-check(|kind, task*, dep*):
    (term, expected) -> task
    where
      actual    := <property-task(|kind, task*)> term
    ; expected* := <try-make-list> expected
    ; check*    := <map(<new-task(|task*)> PropCheck(actual, <id>))> expected*
    ; task      := <new-task(|task*, [dep*, check*])> Choice(check*)
     
  prop-lookup(|kind, task*, dep*) = 
    where(all-dep* := <union> (dep*, <dependent-tasks>))
  ; <new-task(|task*, all-dep*)> PropLookup(kind, <id>) 
  
  prop-unify(|task*, relation) = 
    <new-task(|task*)> Match(relation, <Fst>, <Snd>)
  
strategies
  
  type-is(|task*)           = prop-calc(|task*, [])
  type-is(|task*, dep*)     = prop-calc(|task*, dep*)
  
  type-check(|task*)        = prop-check(|Type(), task*, [])
  type-check(|task*, dep*)  = prop-check(|Type(), task*, dep*)

  type-lookup(|task*)       = prop-lookup(|Type(), task*, [])
  type-lookup(|task*, dep*) = prop-lookup(|Type(), task*, dep*)
  
  type-unify(|task*, relation) = prop-unify(|task*, relation)
  
  property-task(|task*, kind) = where(Type() := kind); type-of(|task*)
