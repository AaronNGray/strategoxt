module properties/collect

imports 
	
  task/-
  properties/-
  nabl/-
  editor/origins
  types/collect
  
signature
  
  sorts
  
    Property
    
  constructors
    
    Prop : Property * Value * List(Dependency) -> Prop
   
rules // generic analysis of properties
  
  // call back to generic analysis
  nabl-props(|partition, prop*) =
  	where (
	  	nabl-collect-def
	  ; nabl-uri => uri
	  )
	  ; <map(nabl-add-prop(|partition, uri, <id>))> prop*
	
  nabl-add-prop(|partition, uri, name):
    Prop(kind, result, dep*) -> <new-prop(|partition, uri, kind, result)> name

  // generic collection of property tasks
  nabl-annotate-properties(|partition) =
    !([Type()|<nabl-custom-properties <+ ![]>], <id>)
  ; foldl(nabl-annotate-property(|partition) <+ Snd)
  ; where(nabl-constraint(|partition))
  
  nabl-annotate-property(|partition):
    (kind, term{a*}) -> term{(kind, prop), a*}
    where
      not(<nabl-get-property-task(|kind)> term)
    where
      prop := <nabl-new-property(|partition)> 
          
strategies
  
  nabl-prop-calc(|partition, dep*) = 
    where(all-dep* := <union> (<dependent-tasks> dep*, <dependent-tasks>))
  ; <new-task(|partition, all-dep*)> PropCalc(<id>)
    
  nabl-prop-lookup(cont|kind, partition, dep*) = 
    where(all-dep* := <union> (<dependent-tasks> dep*, <dependent-tasks>))
  ; <new-task(|partition, all-dep*)> PropLookup(kind, <id>) 
  ; where(try(cont))
  
  nabl-prop-match(cont|kind, partition, dep*, relation, expected) = 
    ?actual
  ; expected* := <try-make-list> expected
  ; check*    := <map(<new-task(|partition)> PropCheck(kind, relation, actual, <id>))> expected*
  ; <new-task(|partition, <dependent-tasks> [dep*, check*])> Choice(check*)
  ; where(try(cont))
