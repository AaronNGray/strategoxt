module properties/tasks

imports 
	
	nabl/-
	properties/-
  task/core
  
signature
  
  constructors

    PropCalc   : Term                              -> Instruction
    PropList   : List(Term)                        -> Instruction
    PropLookup : Property * URI                    -> Instruction    
    PropCheck  : Property * Relation * Term * Term -> Instruction
    
rules

  perform-task(|n): 
  	PropLookup(kind, contains-uri) -> result
  	where
  		uri := <nabl-uri> contains-uri;
  		<nabl-add-uri-read(|n)> uri;
			// HACK: task-result-combinations also creates dependencies if any result has not been solved yet.
			// Proper way would be to decompose the PropLookup into a ResolveUseToDef, GetProperty and InsertCombinations task.
  		result := <nabl-get-property(|kind); task-result-combinations> uri

  // perform-task(|n) =
  // 	?PropLookup(kind, <id>)
  // 	;	nabl-add-uri-read(|n) 
  //   ; nabl-get-all-properties(|kind)
  //   ; insert-results-or-create-dependency 
  // 	; (task-collect-dependencies <+ try(concat))
  //   ; try(map(Hd); MkSingleton) // HACK
      
  perform-task(|n): 
  	PropCheck(kind, rel, actual, expected) -> <nabl-property-eq> (kind, rel, (actual, expected))
