/**
 * @author Merijn de Jonge <mdjonge@cs.uu.nl>
 */
module Ast-2-abox
imports
  liblib
  lib-pp-table-args
  pp-tables-io2
  instantiate
  misc
  AsFix

strategies

  io-Ast-2-abox =
    option-wrap(ast2abox-options, ast2abox)

  ast2abox-options =
      io-options
    + pp-options
    + verbose-option

  ast2abox =
      where(
        get-config-p
        ; reverse
        ; read-pp-tables
        ; lookup-table(|"pp-table") => tbl
      )
    ; xtc-io(
        xtc-io-transform(
          trm2abox(|tbl)
        ; if is-list then
            !HV([], <id>)
          end
        )
      )

strategies

  trm2abox(|tbl) =
       trm2abox-string(|tbl)
    <+ trm2abox-int(|tbl)
    <+ trm2abox-real(|tbl)
    <+ trm2abox-list(|tbl)
    <+ trm2abox-appl(|tbl)
    <+ log(|Error(),"Cannot rewrite to box: ", <id>) ; <exit>1

  trm2abox-string(|tbl) =
    !S(<is-string>)

  trm2abox-real(|tbl) =
    !S(<real-to-string>)

  trm2abox-int(|tbl) =
    !S(<int-to-string>)

  trm2abox-list(|tbl) =
    map(trm2abox(|tbl))

  trm2abox-appl(|tbl) =
    ?f#(args)
    ; where(<length> args => arity)
    ; <try-pp-table-get(|tbl)> (arity, [f]) => (path, template)
    
    ; let narg2abox(|n) =
            arg2abox(|tbl, n, [f])
       in <nmap(narg2abox | 1)> args => aboxes
      end
    ; <instantiate(|aboxes)> template

  nmap(s : a * b -> c | i) =
    [] + [s(|i) | nmap(s | <inc> i)]

/**
 * Path is a list.
 * First element is the constructor name (string)
 * 
 */
strategies

  /**
   * @param n     Integer: Argument index
   * @param path  Path of the parent node
   * @param arg   Any term
   */
  arg2abox(|tbl, n, path) =
      ?arg
    ; <conc> (path, [n]) => new_path
    ; ( <hashtable-get(|new_path)> tbl => (full_path, template)
        ; <symbol2abox(|tbl, <get-symbol> full_path, new_path, template)> arg
      <+ <trm2abox(|tbl)> arg
      )

strategies

  symbol2abox(|tbl, symbol, path, template) =
       symbol2abox-alt(|tbl, path, template)
       
    <+ symbol2abox-opt(|tbl, path, template)
    
    <+ where(!symbol; (?"iter" + ?"iter-star"))
       ; symbol2abox-iter(|tbl, path, template)
       
    <+ where(!symbol; (?"iter-sep" + ?"iter-star-sep"))
       ; symbol2abox-iter-sep(|tbl, path, template)
    
    <+ where(!symbol => "seq")
       ; symbol2abox-seq(|tbl, path, template)

  /**
   * Rule to format alt(n,[]), with empty list of arguments
   */
  symbol2abox-alt(|tbl, path, template) =
    ?alt(n, [])
    ; <instantiate(|[])> [<index(|n)> (n, template)]

  /**
   * Rule to format alt(n,[arg]), with non-empty list of arguments
   */
  symbol2abox-alt(|tbl, path, template) =
    ?alt(n, [arg])
    ; <arg2abox(|tbl, n, path)> arg => abox
    ; <instantiate(|[abox])> [<index(|n)> template]

  /**
   * Rule to format optional: Some(x)
   */
  symbol2abox-opt(|tbl, path, template) =
    ?Some(x)
    ; <arg2abox(|tbl, 1, path)> x => abox
    ; <instantiate(| [abox])> template

  /**
   * Rule to format optinal: None
   */
  symbol2abox-opt(|tbl, path, template) =
    ?None(); ![]

  /**
   * Rule to format iter and iter-star list
   */
  symbol2abox-iter(|tbl, path, template) =
      map(arg2abox(|tbl, 1, path)) => abox
    ; <instantiate(| [abox])> template

  /**
   * Rule to format iter-sep and iter-star-sep list
   */
  symbol2abox-iter-sep(|tbl, path, template) =
    map(arg2abox(|tbl, 1, path))
    ; if <collect'(?S(_))> template => [_] then
        rec x(
           \ []     -> []  \
        <+ \ [e]    -> [e] \
        <+ \ [e | xs] -> [e, e| <x> xs] \
        )
      end
    ; instantiate-sep-list(|template)

  /**
   * Rule ro format sequences
   */
  symbol2abox-seq(|tbl, path, template) =
    TupleToList
    ; nzip( \ (n, t) -> <arg2abox(|tbl, n, path)> t \ ) => abox
    ; <instantiate(|abox)> template

rules

  /**
   * Build a sepator list by formatting its elements which are numbered
   * tuples. Odd entries denote symbols and are formatted using the path
   * <path>.1; even entries denote separators and are formatted using the path
   * <path>.2
  BuildSepList(|path) :
    (n, s) -> abox
    where
      if <even> n then !1 else !1 end
      ; <arg2abox> (<id>, path, s) => abox
   */

  /**
   * The symbol of the SDF production is contained in the path of
   * pretty-print rules. Get-symbol returns the last symbol of a path.
   */
  get-symbol :
    Path(cons-name, selectors) -> symbol
    where
      <at-last(?[selector(_, symbol)])> selectors
