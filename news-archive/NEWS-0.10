StrategoXT 0.10 is under construction

---------++ Summary of Changes

   * Language
      * Major redesign of dynamic rules
      * If then else and switch operators

   * Tools
      * Upgrade of XT
      * Introduction of Stratego Regular

   * Deployment
      * Daily verified support for Cygwin
      * Support for Mac OS X

   * Miscellaneous
      * Many bug fixes and minor improvements
      * Issue tracking is paying off

---------++ Dynamic Rules 

For StrategoXT 0.10 we have completely redesigned and reimplemented
dynamic rules. Scoped dynamic rewrite rules have been introduced in
Stratego 0.6 (August 2001). Dynamic rules have been applied
extensively since then. In particular they have proved to be very
useful for implementing context-sensitive transformations. However,
these applications also revealed some missing features in scoped
dynamic rewrite rules.

---------+++ Motivation for Redesign

First, there is a need for forking and merging sets of dynamic rules
in data-flow optimizations and probably many other application
areas. At first we have implemented this at the implementation level
of dynamic rules. In StrategoXT 0.10 this functionality has been lifted
to the language level by allowing intersection and union operations on
sets of rules.

Second, many applications need to define more than one possible rewrite
rules that can all be applied, possibly all at once to retrieve a list
of possible rewrites. A first implementation of this idea was already
available in StrategoXT 0.9.4 (extend rules).

Third, the 'override rules' facility for defining dynamic in rules in
outer scopes proved to be insufficient. To this end we have added
labeled scopes. Rules can be tied to specifically labeled scopes. Labeled
scopes are based on an idea raised by Ganesh Sittampalam in a discussion
at the Stratego User Days 2004.

---------+++ New Syntax and Semantics

The new abstract syntax is introduced by comparing to the old syntax and
and semantics, and is presented in BNF below. Some basic entities are:
<verbatim>
  s     strategy,
  f     rule/strategy identifier, e.g. 'EvalBinOp', or 'innermost',
  dsig  definition signature, identifier with optional strategy and term
        arguments: f(sd*|vd*).
</verbatim>


Generation of new rules always occurred within =override/extend rules(..)=
constructs. Now, just one =rules(..)= construct is available. The dynamic
rule definitions within determine the semantics.

<verbatim>
  s ::= rules(drd*)                       rule definition block
</verbatim>

---------++++ Labeling of Scopes

To prevent rules from being undefined too early at the end of the current
scope, the =override rules(..)= could be used in the past. Rules were tied
to some outer scope, instead of the current innermost.

The new dynamic rules still support the same scoping syntax, but now
*optional* labels maybe attached. These labels are term-patterns, and thus
result in runtime scope-labeling.

<verbatim>
  s ::= {| f1(.p1)?, ... fn(.pn)? : s |}  dynamic rule scope
</verbatim>

Within a =rules(..)= block, the current scope may be assigned additional
labels.
<verbatim>
  drd ::= f+p                             label current scope
</verbatim>

---------++++ Dynamic Rule Definitions

Besides the mandatory rule name, dynamic rule definitions now may also
contain a label, specifying in which scope this rule should be placed.
No label naturally means generation within the current inner scope.
<verbatim>
  drsig ::= sig                           relative to current scope
            sig.p                         relative to labeled scope
            sig+p                         relative to current scope, but add a
                                          label to current scope simultaneously

  drd ::= drsig : p1 -> p2 (where s)?     dynamic rule definition
</verbatim>

Instead of =extend rules= blocks, now the rule definitions specify themselves
whether 'extend-behavior' is intended:
<verbatim>
  drd ::= drsig :+ p1 -> p2 (where s)?    dynamic rule extension
</verbatim>

Undefining rules no longer uses the =Undefined= keyword, again it's the
rule definition itself.
<verbatim>
  drd ::= drsig :- p                      dynamic rule undefining
</verbatim>

A new form of dynamic rule is the dynamic identity rule, that -when applied-
tries to match against the left-hand side and leaves the current term
untouched.
<verbatim>
  drd ::= drsig : p                       dynamic identity rule definition
</verbatim>

Within a nested scope-structure, multiple scopes may have identical labels.
When (un-)defining dynamic rules in a labeled scope, the innermost scope with
that label is selected.

---------++++ Dynamic Rule Calling

Dynamic rules are basically just runtime generated rewriting rules, so for a
definition: =UsedInExp :+ |[ x ]| -> |[ e ]|= the basic call is:
<verbatim>
  <UsedInExp> |[ y ]| => |[ e' ]|         // Normal rewriting
</verbatim>
It tries to rewrite with the most recently generated instance of =UsedInExp=,
and repeatedly tries older instances until rewriting succeeds or no more
instances exist in the same generation scope (i.e. no inheritance from higher
scopes than the one of latest generation).
Note that the semantics of this simple rewriting has changed: in the old model,
no older instances were available for rewriting if the youngest instance failed)

Two special rules are automatically available for each dynamic rule:
the =bagof-= and =once-= rule.
<verbatim>
  <bagof-UsedInExp> |[ y ]| => |[ e* ]|   // Multiple rewritings
</verbatim>
=bagof-RuleName= applies all available instances of =RuleName= (from one scope)
and returns a list of succeeded result terms.

<verbatim>
  <once-UsedInExp> |[ y ]| => |[ e' ]|    // Rewriting once
</verbatim>
=once-RuleName= rewrites just like =RuleName= would do, but upon successful
rewriting that rule instance is removed. A generated rule thus is used for
rewriting only once.

---------++++ Branching and Meeting Rule Sets

When performing control-flow optimizations, rule sets had to be explicitly
saved, intersected and restored. The new model now provides some variants for
this at the language level (with generic functionality available in the API).

The best-known branch-meet operation is the intersection of rule sets after
constant propagation through the then- and else-branch of an if-then-else.
The general syntax allows two strategies to be performed, followed by an
automatic intersection of one or more named rule sets:
<verbatim>
  s1 / f1, ..., fn \ s2                   dynamic rule intersection
</verbatim>
Example: =If(id,s,id)/PropConst\If(id,id,s)=

The same is possible for union, instead of intersection:
<verbatim>
  s1 \ f1, ..., fn / s2                   dynamic rule union
</verbatim>

Control structures that involve repetition (e.g. for-loops) often need
repeated traversal until a fixed point in the rule set is reached.
Two fixpoint traversals are available that meet the dynamic rule set with
the one from the previous iteration until the rule set is free of changes.
<verbatim>
  / f1, ..., fn \* s2                     dynamic rule fixpoint intersection
  \ f1, ..., fn /* s2                     dynamic rule fixpoint union
</verbatim>
Example: =/PropConst\* While(s,s)=

---------++++ Dynamic Rules API

For in-depth specification of the underlying dynamic rules implementation,
please refer to the =dynamic-rules-refactored= module in the SSL.
At least the debug strategies are useful for end-users:
<verbatim>
  dr-debug-rule-set(|name)                // Output dynamic rule set on stderr
  dr-debug-rule-set(|name, msg)           // Id. preceded by user's message
</verbatim>

---------++++ Compatibility and Compiler Flags

The new implementation of dynamic rules is not yet turned on by
default. To turn it on, you need to pass the option =--dr new= to the
Stratego compiler. Although the new implementation is not yet used by
default, all existing applications should work with the new
implementation. That is, if they do not rely on weird semantics in the
old dynamic rule implementation and do not manipulate the internal
representation of dynamic rules.

Parsing of stratego source always uses the new syntax, but for backward
compatibility *all* old constructs are still available.
That is: =extend/override rules(..)= and =Rule: t -> Undefined=.
When the new dynamic rule implementation is selected (=--dr new=), the old
semantics are emulated for both constructs. All other old dynamic rules
constructs still fit within the new implementation.
Note however, that semantics for simple rule application within the new
dynamic rules implementation has changed (see 'Dynamic Rule Calling' above).

The other way around: the new syntax for dynamic rules is supported as much
as possible by the old dynamic rule implementation.
Dynamic rule extension (e.g. =Rule :+ t1 -> t2=), and dynamic rule undefining
(e.g. =Rule :- t=) are translated to their old equivalents.
When the input program contains scope-labels or identity rules, the compiler
warns and exits with an error.
But realize: when using new constructs in your program, there's no need to use
the old compiler implementation.

We advice to test compiling your programs with =--dr new= since future
releases of the Stratego compiler will have this flag switched on by default.

  (Arthur van Dam, Eelco Visser, Karina Olmos and Martin Bravenboer)

---------++ If then else and switch operators

StrategoXT 0.10 introduces a if-then-else and switch operators. Both
operators are defined in terms of the guarded left-choice. Thus, they
are just a more wordy syntax that can be clearer in some case.

The if operator is translated into Stratego-Core by the following
rewrite rule:

<verbatim>
  |[ if s1 then s2 else s3 end ]| -> |[ where(s1) < s2 + s3 ]|
</verbatim>

Note that the application of s1 does not change the subject term. s2
and s3 are applied to the subject term of the if-then-else operator.

The translation of the switch statement is somewhat more complex. It
is best introduced with an example.

The following code fragment from pack-sdf:
<verbatim>
  (  where(of-config => "txt")   < xtc-asfix-yield
  +  where(of-config => "ast")   < xtc-implode-asfix
  +  where(of-config => "asfix")
     <+ <fatal-error> ["pack-sdf: ", <id>, " is not a valid output format."]
  )
</verbatim>

translates into the following code if the switch operator is used:

<verbatim>
  switch of-config
    case "txt"   : xtc-asfix-yield
    case "ast"   : xtc-implode-asfix
    case "asfix" : id
    otherwise    :
      <fatal-error> ["pack-sdf: ", <id>, " is not a valid output format."]
  end
</verbatim>

The case conditions (="txt"=, ="ast"= and ="asfix"=) are not
restricted to term patterns: arbitrary strategies are allowed. They
are applied to the result of the subject of the switch, which is the
result of invoking =of-config= in this case.

The bodies (=xtc-asfix-yield=, =xtc-implode-asfix=, =id= and the
=fatal-error= invocation) are applied to the subject term of the
switch strategy. That is, the switch subject and the conditions do not
modify the subject term, which is comparable to the behaviour of the
if operator.

The words used in these new operators (=if=, =then=, =else=, =end=,
=switch=, =case= and =otherwise=) are not declared as
keywords. Therefore they are still allowed as identifiers.

  (Arthur van Dam and Martin Bravenboer)

---------++ Stratego Regular

Signature generation

Generate just one signature file.

Declare SDF2RTG_FLAGS

  (Martin Bravenboer)

---------++ Upgrade of XT

For StrategoXT 0.10 we have massively updated the XT tools in
StrategoXT.

In particular have the SDF tools all been updated to the most recent
recently released version of SDF2, which is the one in in PGEN
2.0. There a quite some SDF tools in StrategoXT, but the most relevant
ones are ppgen, pack-sdf, and sdf-cons. sdf-to-sig is no longer
available. It has been replaced by the tools of Stratego Regular.

StrategoXT now just contains tools for this version of SDF2. If you
have developed SDF tools based on StrategoXT, then you might need to
upgrade your tools. The previous versions of StrategoXT used to ship
with three versions of SDF. SDF 2.1, which was refered to as
Sdf2-Syntax, an older version of SDF, which was named =sdf= and
=sdf.cons=, and the most recent one, which is called =Sdf2=. The
latest is the only one that is left. If your tools use the older
versions of Sdf, then you need to upgrade. Most SDF tools only have to
change the top-level constructor names, which are now completely
lower-case.

  (Martin Bravenboer and Valentin David)

The Stratego Tools package has been updated to use the latest
definitions of Stratego in stratego-front. The existing tools in
Stratego Tools are not really heavily used, so you will probably never
have experiences any problems.

Stratego Tools in StrategoXT 0.10 contains a new tool,
pp-stratego-latex-alltt. This tool is mainly useful for including
Stratego code in publications and documentation written LaTeX. The
tool adds some macro invocations to a Stratego module, and preserves
the layout of the input. Currently it marks quotation symbols,
meta-variables, dynamic rule scope. You can define the macros yourself
if you want a different presentation of the source code. The source
directory of tool contains an example LaTeX document.

AsFix Tools has been cleanup as well. This packages used to contain
signatues for SDF modules, which have now been removed in StrategoXT
0.10. The SDF signatures of the most recent SDF2 are part of the SDF
Front package. The signature for =asfix= has been replaced by a
new signature, now called =AsFix=. This module defines the AsFix
language in a single signature. If you import this module, then your
program can handle all AsFix constructs.

  (Martin Bravenboer)

---------++ Support for Cygwin and Mac OS X

In the meantime we have added a Cygwin machine to our buildfarm. This
way we can make sure that StrategoXT is working on Cygwin. Since no
Stratego developer is using Cygwin, this used to be a problem in the
past. Testing StrategoXT now and then on Cygwin wasn't working: users
want firm answers. Does it work, or does it not?

  (Martin Bravenboer)

StrategoXT 0.10 also supports the most recent Mac OS X release. This
is mostly thanks to the updates of the development tools for Mac OS X.

---------++ Editor Support

vim, improved nedit.

---------++ Many bug fixes and minor improvements

Just before StrategoXT 0.9.5 we adopted the JIRA issue tracking
system. This has been very helpful in for keeping track of problems
that need to be fixed. Many small problems have been fixed in this
release. Before we adopting JIRA, many of these issues would have been
forgotten.

Please report any issues to JIRA, even if you think that it is not
that important, or if you have already found a workaround. Feedback of
users is very important in adding the finishing touch to our tools!

Some pointers to overview of issues:

   * [[StrategoRelease010Issues][list of all issues closed in StrategoXT 0.10]]
   * [[TODO][StrategoXT roadmap]]

---------++ Download and Installation

The release page contains the source distributions, binary RPMs, and
detailed instructions on how to install the distributions:

   * http://www.stratego-language.org/Stratego/StrategoRelease010

---------++ Bugs and Known Problems

Not all bugs and known problems for StrategXT have been solved in this
release, otherwise this would release 1.0 ;). See our issue tracking
systems for reports about (open) bugs:

   * https://catamaran.labs.cs.uu.nl/jira/

For an overview of features planned for future releases:

   * [[TODO][StrategoXT roadmap]]
   * ReleasePlan: http://www.stratego-language.org/Stratego/ReleasePlan
   * Todo: http://www.stratego-language.org/Stratego/ToDo

Please report any problems with installation or bugs in the
implementation to our issue tracking system. Please check the existing
issues to see if a report about the problem was already submitted.

---------++ Contributions

Developments, beta tests, and bug fixes were carried out by

  * Martin Bravenboer
  * Arthur van Dam
  * Valentin David
  * Eelco Visser
  * Shishir Ramam