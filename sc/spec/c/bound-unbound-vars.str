module bound-unbound-vars
imports Stratego dynamic-rules lib verbose
strategies

  bound-unbound-vars =
    iowrap(mark-bound-unbound-vars)

  mark-bound-unbound-vars =
    if-verbose4(say(!"marking bound-unbound-vars"))
    ; Specification([id, Strategies(map(mark-buv))])
    ; if-verbose4(say(!"marked bound-unbound-vars"))

  mark-scope =
    ? Scope(xs, _)
    ; where(!"unbound" => anno)
    ; Scope(id,
        {| MarkVar : 
           where(!xs; map({?x; rules(MarkVar : Var(x) -> Var(x){anno})}))
           ; mark-buv
        |})

  mark-match :
    Match(t) -> Match(t')
    where !"bound" => anno
        ; <alltd(
             MarkVar
             ; where({x:?Var(x); override rules(MarkVar : Var(x) -> Var(x){anno})})
           )> t => t'

  mark-buv =
    mark-match 
    <+ mark-build
    <+ mark-scope
    <+ mark-let
    <+ mark-traversal
    <+ mark-sdef 
    <+ mark-call
    <+ mark-prim
    <+ mark-rec
    <+ mark-choice(mark-buv)
    <+ mark-lchoice(mark-buv)
    <+ mark-guardedlchoice(mark-buv)
    <+ all(mark-buv)

  mark-build = 
    Build(alltd(MarkVar))

  mark-traversal =
    (?All(_) + ?One(_) + ?Some(_) + ?Thread(_))
    ; where(save-MarkVar => bnd)
    ; one(mark-buv)
    ; where(<isect-MarkVar> bnd)

  mark-call =
    Call(id,id)
    ; where(save-MarkVar => bnd)
    ; Call(id, mark-buv)
    ; where(<isect-MarkVar> bnd)

  mark-call =
    CallT(id,id,id)
    ; where(save-MarkVar => bnd)
    ; CallT(id, id, map(alltd(MarkVar)))
    ; CallT(id, mark-buv, id)
    ; where(<isect-MarkVar> bnd)
  
  mark-prim =
    PrimT(id,id,id)
    ; where(save-MarkVar => bnd)
    ; PrimT(id, id, map(alltd(MarkVar)))
    ; PrimT(id, mark-buv, id)
    ; where(<isect-MarkVar> bnd)

  mark-let =
    Let(id, id)
    ; where(
        where(save-MarkVar => bnd0)
        ; Let(map(mark-buv; where(<isect-MarkVar> bnd0))
	     ,    mark-buv; where(<isect-MarkVar> bnd0))
      ) 
    ; where(save-MarkVar => bnd1)
    ; Let(map(where(<restore-MarkVar> bnd1); mark-buv)
         ,    where(<restore-MarkVar> bnd1); mark-buv)
    ; where(save-MarkVar)

  mark-sdef =
    ? SDefT(_, _, as, _)
    ; where(!"bound" => anno)
    ; SDefT(id, id, id,
        {| MarkVar :
             where(!as; map({?VarDec(x,_); rules(MarkVar : Var(x) -> Var(x){anno})}))
             ; mark-buv
        |})

  mark-rec = 
    ?Rec(_, _)
    ; where(save-MarkVar => bnd0)
    ; where(Rec(id, mark-buv))
    ; where(<isect-MarkVar> bnd0)
    ; Rec(id, mark-buv)

  mark-choice(uv) =
    Choice(id, id)
    ; abstract-choice(Choice(uv,id),Choice(id, uv))

  mark-lchoice(uv) =
    LChoice(id, id)
    ; abstract-choice(LChoice(uv,id),LChoice(id, uv))

  mark-guardedlchoice(uv) =
    GuardedLChoice(id, id, id)
    ; abstract-choice(GuardedLChoice(uv,id,id);GuardedLChoice(id,uv,id)
	           ,GuardedLChoice(id,id,uv))

  abstract-choice(left, right) =
    where(save-MarkVar => bnd0)
    ; left
    ; where(save-MarkVar => bndL; <restore-MarkVar> bnd0)
    ; right
    ; where(<isect-MarkVar> bndL)


strategies // Dynamic rule manipulation

  save-MarkVar =
    <table-getlist> "MarkVar"

  clean-MarkVar =
    where(<table-destroy> "MarkVar";
          <table-putlist>("MarkVar", []))

  restore-MarkVar = ?tbl;
    where(<table-destroy> "MarkVar";
          <table-putlist>("MarkVar", tbl))

  isect-MarkVar = 
     where(save-MarkVar);
     map(try(?(Scopes,_)
        <+ {key, xs, x : ?(key, [Defined(_,x)|xs]); 
            (where(<table-get> ("MarkVar", key) => [Defined(_,x)|_])
             <+ !(key, [Undefined|xs]))
           }))
    ; restore-MarkVar


/*
    Bound/Unbound variable analysis for Stratego programs

    Copyright (C) 2003 Eelco Visser <visser@acm.org>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA

*/