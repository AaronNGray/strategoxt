/*
 stratego-warnings.str: a module for generating stratego compilation warnings 

 author: Merijn de Jonge (m.de.jonge@tue.nl)

 usage: sc -i stratego-wargings.str
        pack-stratego -I <xt>/share/ssl -i <your_spec>.str -o <your_spec>.ast
        frontend -i <your_spec>.ast -o <your_spec>.ast1
        extract -i <your_spec>.ast1 -o <your_spec>.ast2
        stratego-warnings -i <your_spec>.ast.2 -o /dev/null
 */               
module stratego-warnings

imports lib

signature
constructors
   Call: Name * Args -> Call
   SVar: Name  -> SVar
   SDef: Name * x * Def -> SDef
   Build: Strat -> Build
   Str: list(Char) -> Str

   ObsoleteWarning: Str -> Warning
   DebugWarning : Str -> Warning      
strategies

stratego-warnings = iowrap(Stratego-warnings, stratego-warnings-options)

stratego-warnings-options = 
    ArgOption("--warning" + "-W",
        where(<extend-config> ("--warning", [<id>])); !(),
        !"-W | --warning     Set warning level (-W all to switch all warnings on)")

Stratego-warnings =
   (id,
         where(
         ?spec;
         (<get-config>"--warning"; uniq <+ ![]);
         // If -W all was given, create a list of all availabel checks  
         try(fetch-elem("all");!["debug-arguments", "obsolete-strategy-calls"]);
         
         filter(Warning(!spec));
         concat;
         print-warnings
   )
)

Warning(spec)=
   (
     "debug-arguments";
        spec; debug-with-incorrect-string
   +
     "obsolete-strategy-calls";
        spec;obsolete-def
   )
   <+
      <printnl> (stderr, ["** WARNING incorrect parameter passed to -W switch: ", <id>]);
      ![]


// Strategy to find calls to the "obsolete" strategy
obsolete-def = 
   strategy-invokation-warning(
   sdef-with-property( 
     \  Call(SVar("obsolete"),[Build(Str(msg))]) -> ObsoleteWarning(msg) \ )
   )

// Strategy to find calls to "debug" strategy with incorrect argument
debug-with-incorrect-string =
   strategy-argument-warning(
   sdef-with-property({arg, msg:
   \   Call(SVar("debug"),[arg]) -> DebugWarning(msg) 
       where
       !arg;
       not(Build(Str(id)));
       oncetd(Str(?msg))
   \ }))

// Create warning string for obsolete warning
mk-warning: (caller, strat, ObsoleteWarning(warning)) -> msg
   where
   <concat-strings>
   ["warning: obsolete strategy or rule invoked from \"", caller, "\":\n  ", 
     strat, ": \"", warning, "\"\n"] => msg

// Create warning string for debug warning
mk-warning: (strat, DebugWarning(warning)) -> msg
   where
   <concat-strings>
   ["warning: possibly missing build operator in debug strategy in \"", strat,"\"\n",
    "  debug(",<double-quote>warning,")\n"] => msg
   

   
// A strategy-invokation warning is a warning related to a invokation of a
// strategy. Typically, this means a call to an obsolete strategy.
// The result is a list of triples (caller, strat, warning)
// where
//  caller  is the caller to strat
//  strat   is the strategy causeing the warning (for instance because it is
//          obsolete 
//  warning is the warning messeage (typically the argument to obsolete)
strategy-invokation-warning(s) =
    split(id, collect(s);concat;not([]));
    map-apply(get-strategy-callers)
   <+
    ![]
// A strategy-argument warning warns about a possibl incorrect argument to a
// strategy. A typical example is a string argument to the "debug" strategy:
//    debug("debug message")   since it should be   debug(!"debug message)
//
strategy-argument-warning(s) =
   collect(s);concat
      


// Print a list of warnings to standard error and also print a count of the
// number of warnings
print-warnings = 
    []
   <+
    map(mk-warning);
    where(length => nr);
    !(stderr, <id>);
    print;
    !(stderr, ["\n", nr, " warning(s)\n"]);
    print
  
// Return a list of callers to strategy "strat-name"
get-strategy-callers:
  (t, (strat-name, warning-msg) ) -> warning
  where
   !t;
   collect(
      caller(!strat-name);
      not(?strat-name);
      !(<id>, strat-name, warning-msg)
   ) => warning

// Return a list of strategy names which invoke strategy "To"
caller(To) = 
   ?SDef(name, _, def);
   To => to;
   !def;
   collect( Call(SVar(?to), id);!to );
   not([]);
   !name

// Return a list of tuples (name, match) for strategy definition for which
// "prop" holds 
sdef-with-property(prop) =
   SDef(?name, id, ?def);
   !def;
   collect(prop);
   not([]);
   map( \match -> (name, match) \ )
   
// map-apply(s) : (t,l) -> t'
// Transform t by subsequently applying strategy s with argument a1...an
// from the list l
map-apply(s) =
   rec x ({a,as,t:
      (id,[]); Fst
   <+
      ?(t, [a|as]);
      <x>(<s>(t,a), as)
   })
   