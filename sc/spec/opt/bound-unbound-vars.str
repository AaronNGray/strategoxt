module bound-unbound-vars
imports Stratego dynamic-rules lib verbose stratlib
strategies

  bound-unbound-vars-io =
    iowrap(mark-bound-unbound-vars)

  mark-bound-unbound-vars =
    if-verbose4(say(!"marking bound-unbound-vars"))
    ; Specification([id, Strategies(map(mark-buv))])
    ; if-verbose4(say(!"marked bound-unbound-vars"))


  /** 
   * Annotate variables with one of the annotations "bound",
   * "unbound", or "(un)bound".
   * 
   * Variables are bound in matches, used in builds, and
   * refreshed in scopes. Choice operators may lead to 
   * a variable being bound in one path, but not in the
   * other. Such variables are annotated with "(un)bound".
   */

  mark-buv =
    mark-match 
    <+ mark-build
    <+ mark-scope
    <+ mark-let
    <+ mark-traversal
    <+ mark-sdef 
    <+ mark-rdef
    <+ mark-lrule
    <+ mark-srule
    <+ mark-overlay
    <+ mark-call
    <+ mark-prim
    <+ mark-rec
    <+ mark-choice(mark-buv)
    <+ mark-lchoice(mark-buv)
    <+ mark-guardedlchoice(mark-buv)
    <+ all(mark-buv)

  DeclareUnbound =
    where(!"unbound" => anno)
    ; ?x
    ; rules(MarkVar : Var(x) -> Var(x){anno})

  IntroduceBound =
    where(!"bound" => anno)
    ; ?x
    ; rules(MarkVar : Var(x) -> Var(x){anno})

  DeclareBound =
    where(!"bound" => anno)
    ; ?x
    ; override rules(MarkVar : Var(x) -> Var(x){anno})

  mark-scope =
    Scope(?xs, {| MarkVar : where(!xs; map(DeclareUnbound)); mark-buv|})

  mark-match =
    Match(mark-match-vars)

  mark-match-vars = 
      Var(id)     < MarkAndBind
    + App(id,id)  < App(mark-buv, mark-build-vars)
    + RootApp(id) < RootApp(mark-buv)
    + all(mark-match-vars)

  MarkAndBind =
    try(MarkVar)
    ; Var(DeclareBound)

  mark-build = 
    Build(mark-build-vars)

  mark-build-vars =
      Var(id)     < MarkVar
    + App(id,id)  < App(mark-buv, mark-build-vars)
    + RootApp(id) < RootApp(mark-buv)
    + all(mark-build-vars)

  mark-traversal =
    (?All(_) + ?One(_) + ?Some(_) + ?Thread(_))
    ; where(save-MarkVar => bnd)
    ; one(mark-buv)
    ; where(<isect-MarkVar> bnd)

  mark-call =
    Call(id,id)
    ; where(save-MarkVar => bnd)
    ; Call(id, mark-buv)
    ; where(<isect-MarkVar> bnd)

  mark-call =
    CallT(id,id,id)
    ; where(save-MarkVar => bnd)
    ; CallT(id, id, map(alltd(MarkVar)))
    ; CallT(id, mark-buv, id)
    ; where(<isect-MarkVar> bnd)
  
  mark-prim =
    PrimT(id,id,id)
    ; where(save-MarkVar => bnd)
    ; PrimT(id, id, map(alltd(MarkVar)))
    ; PrimT(id, mark-buv, id)
    ; where(<isect-MarkVar> bnd)

  mark-let =
    Let(id, id)
    ; where(undefine-unbound-MarkVar => bnd0)
    ; Let(map(where(<restore-MarkVar> bnd0); mark-buv)
         ,    where(<restore-MarkVar> bnd0); mark-buv)

  mark-sdef :
    SDefT(f, as1, as2, s) -> SDefT(f, as1, as2, s')
    where <map(?VarDec(<id>,_) + ?DefaultVarDec(<id>))> as2 => as2'
	; {| MarkVar :
             <map(IntroduceBound)> as2'
             ; <mark-buv> s => s'
          |}

  mark-rdef : 
    RDefT(f, as1, as2, r@Rule(t1, t2, s)) ->
    RDefT(f, as1, as2, Rule(t1', t2', s'))
    where <map(?VarDec(<id>,_) + ?DefaultVarDec(<id>))> as2 => as2'
	; <diff>(<tvars> r, as2') => xs
	; {| MarkVar :
             <map(IntroduceBound)> as2'
	     ; <map(DeclareUnbound)> xs
	     ; <mark-match-vars> t1 => t1'
             ; <mark-buv> s => s'
	     ; <mark-build-vars> t2 => t2'
          |}

  mark-rdef : 
    RDef(f, as1, r@Rule(t1, t2, s)) ->
    RDef(f, as1, Rule(t1', t2', s'))
    where <tvars> r => xs
	; {| MarkVar :
	     <map(DeclareUnbound)> xs
	     ; <mark-match-vars> t1 => t1'
             ; <mark-buv> s => s'
	     ; <mark-build-vars> t2 => t2'
          |}

  mark-lrule :
    LRule(Rule(t1, t2, s)) -> LRule(Rule(t1', t2', s'))
    where {| MarkVar : 
	     <tvars> t1; map(DeclareUnbound)
	     ; <mark-match-vars> t1 => t1'
             ; <mark-buv> s => s'
	     ; <mark-build-vars> t2 => t2'
	  |}

  mark-srule :
    SRule(Rule(t1, t2, s)) -> SRule(Rule(t1', t2', s'))
    where {| MarkVar : 
	     <tvars> t1; map(DeclareUnbound)
	     ; <mark-match-vars> t1 => t1'
             ; <mark-buv> s => s'
	     ; <mark-build-vars> t2 => t2'
	  |}

  mark-overlay : 
    Overlay(f, xs, t) -> Overlay(f, xs, t')
    where {| MarkVar :
	     <map(IntroduceBound)> xs
	     ; <mark-build-vars> t => t'
          |}

  mark-rec = 
    ?Rec(_, _)
    ; where(save-MarkVar => bnd0)
    ; where(Rec(id, mark-buv))
    ; where(<isect-MarkVar> bnd0)
    ; Rec(id, mark-buv)

  mark-choice(uv) =
    Choice(id, id)
    ; abstract-choice(Choice(uv,id),Choice(id, uv))

  mark-lchoice(uv) =
    LChoice(id, id)
    ; abstract-choice(LChoice(uv,id),LChoice(id, uv))

  mark-guardedlchoice(uv) =
    GuardedLChoice(id, id, id)
    ; abstract-choice(GuardedLChoice(uv,id,id); GuardedLChoice(id,uv,id)
	             ,GuardedLChoice(id,id,uv))

  abstract-choice(left, right) =
    where(save-MarkVar => bnd0)
    ; left
    ; where(save-MarkVar => bndL; <restore-MarkVar> bnd0)
    ; right
    ; where(<isect-MarkVar> bndL)

strategies // Dynamic rule manipulation

  save-MarkVar =
    <table-getlist> "MarkVar"

  debug-MarkVar(s) =
    where(say(s); save-MarkVar; map(debug(!"  ")))

  clean-MarkVar =
    where(<table-destroy> "MarkVar";
          <table-putlist>("MarkVar", []))

  restore-MarkVar = ?tbl;
    where(<table-destroy> "MarkVar";
          <table-putlist>("MarkVar", tbl))

  isect-MarkVar = 
     map(try(?(Scopes,_) <+ isect-MarkVar-Rule))
    ; restore-MarkVar

  isect-MarkVar-Rule :
    (key, [val1@Defined(_,_) | xs]) -> (key, [val3 | xs])
    where <table-get> ("MarkVar", key) => [val2|_]
          ; <CompareEntries> (val1, val2) => val3

  CompareEntries :
    (val@Defined(rl1, x), Defined(rl2, x)) -> val
       
  CompareEntries :
    (val@Defined(rl1, x), Defined(rl2, y)) -> Defined(rl1, "(un)bound")
    where <not(eq)> (x, y)

  CompareEntries :
    (Undefined, _) -> Undefined
    
  CompareEntries :
    (_, Undefined) -> Undefined

  undefine-unbound-MarkVar =
    save-MarkVar
    ; map(try(?(Scopes, _)
		<+ \ (key, [Defined(rl,"unbound") | xs]) -> 
		     (key, [Defined(rl,"(un)bound") | xs]) \ ))
    ; restore-MarkVar

/*
    Bound/Unbound variable analysis for Stratego programs

    Copyright (C) 2003 Eelco Visser <visser@acm.org>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA

*/