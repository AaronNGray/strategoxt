module build-match-laws
imports Stratego sugar

rules // combinations of match and build

  BuildMatch :
    Seq(s1, s2) -> s3
    where <BMF> (s1, s2) => s3

  BuildMatch :
    Seq(s1, Seq(s2, s3)) -> Seq(s4,s3)
    where <BMF> (s1, s2) => s4

  BMF = MisMatch + BuildMatchFusion + BuildBuild + BuildPrim
	+ MatchIdem + BuildMatchIdem 
	+ MatchBuildIdemVar
	// + MatchBuildIdem


  MisMatch :
    (Build(Op(f, ts1)), Match(Op(g, ts2))) -> Fail
    where <not(eq)> (f, g)

  BuildMatchFusion :
    (Build(Op(f, ts1)), Match(Op(f, ts2))) ->
    Seq(Seqs(<zip(\ (t1,t2) -> Seq(Build(t1), Match(t2)) \ )> (ts1, ts2)), 
        Build(Op(f, ts1)))

  BuildBuild :
    (Build(t1), Build(t2)) -> Build(t2)

  BuildPrim :
    (Build(t1), PrimT(f, ss, ts)) -> PrimT(f, ss, ts)

  BuildPrim :
    (Build(t1), Prim(p,ts)) -> Prim(p,ts)

  BuildPrim :
    (Build(t1), Where(Prim(p,ts))) -> Prim(p,ts)

  MatchIdem :
    (Match(t), Match(t)) -> Match(t)
    
  BuildMatchIdem :
    (Build(t), Match(t)) -> Build(t)
    
// not valid as long as annotations are not taken into account
//  MatchBuildIdem :
//    (Match(t), Build(t)) -> Match(t)
    
  MatchBuildIdemVar :
    (Match(Var(x)), Build(Var(x))) -> Match(Var(x))


rules // other rules 

  MatchSimplify = 
    AsMatchWld

  MatchAs :
    Match(As(p1, p2)) -> Seq(Match(p2), Match(p1))

  AsMatchWld :
    As(Wld, t) -> t

  WhereSavesCurrentTerm :
    Where(s) -> Scope([x], Seq(Match(Var(x)), Seq(s, Build(Var(x)))))
    where new => x

  TestSavesCurrentTerm :
    Test(s) -> Scope([x], Seq(Match(Var(x)), Seq(s, Build(Var(x)))))
    where new => x
