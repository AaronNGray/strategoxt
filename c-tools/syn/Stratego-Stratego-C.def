definition
module StrategoStratego
imports Stratego StrategoRenamed

exports

  context-free syntax

              "|[" Module   "]|" -> StrategoTerm {cons("ToTerm"),prefer}
    "Module"  "|[" Module   "]|" -> StrategoTerm {cons("ToTerm")}

              "|[" Decl     "]|" -> StrategoTerm {cons("ToTerm")}
              "|[" Sdecl    "]|" -> StrategoTerm {cons("ToTerm")}

              "|[" Opdecl   "]|" -> StrategoTerm {cons("ToTerm")}
    "Constr"  "|[" Opdecl   "]|" -> StrategoTerm {cons("ToTerm")}

              "|[" Type     "]|" -> StrategoTerm {cons("ToTerm")}
    "Type"    "|[" Type     "]|" -> StrategoTerm {cons("ToTerm")}

              "|[" Term     "]|" -> StrategoTerm {cons("ToTerm")}
    "Term"    "|[" Term     "]|" -> StrategoTerm {cons("ToTerm")}

              "|[" Def      "]|" -> StrategoTerm {cons("ToTerm")}
    "Def"     "|[" Def      "]|" -> StrategoTerm {cons("ToTerm")}

             "|[" Rule      "]|" -> StrategoTerm {cons("ToTerm")}
    "Rule"   "|[" Rule      "]|" -> StrategoTerm {cons("ToTerm")}
             "|[" StratRule "]|" -> StrategoTerm {cons("ToTerm")}

               "|[" Strategy "]|" -> StrategoTerm {cons("ToTerm")}
    "Strat"    "|[" Strategy "]|" -> StrategoTerm {cons("ToTerm")}
    "Strategy" "|[" Strategy "]|" -> StrategoTerm {cons("ToTerm")}

    "O"        "|[" Overlay  "]|" -> StrategoTerm {cons("ToTerm")}
    "Overlay"  "|[" Overlay  "]|" -> StrategoTerm {cons("ToTerm")}

    "Typedid" "|[" Typedid   "]|" -> StrategoTerm {cons("ToTerm")}

  context-free syntax

    %% From Term

    "~"         StrategoTerm -> Term             {cons("FromTerm")}
    "~term:"    StrategoTerm -> Term             {cons("FromTerm")}
    "~term*:"   StrategoTerm -> {Term ","}*      {cons("FromTerm")}
    "~term*:"   StrategoTerm -> {Term ","}+      {cons("FromTerm")}
    "~"         StrategoTerm -> {ID   ","}+      {cons("FromTerm")}

    "~"         StrategoTerm -> Strategy         {cons("FromTerm")}
    "~strat:"   StrategoTerm -> Strategy         {cons("FromTerm")}
    "~*"        StrategoTerm -> {Strategy ","}*  {cons("FromTerm")}
    "~strat*:"  StrategoTerm -> {Strategy ","}*  {cons("FromTerm")}

    "~id:"    StrategoTerm -> Id        {cons("FromTerm")}
    "~int:"   StrategoTerm -> Int       {cons("FromTerm")}
    "~str:"   StrategoTerm -> String    {cons("FromTerm")}

    "~"   StrategoTerm -> Def       {cons("FromTerm")}
    "~*"  StrategoTerm -> Def*      {cons("FromTerm")}

    "~*"  StrategoTerm -> Opdecl*      {cons("FromTerm")}
    "~*"  StrategoTerm -> {Type "*"}+  {cons("FromTerm")}

    "~*"          StrategoTerm -> {Typedid ","}*   {cons("FromTerm")}
    "~typed-id*:" StrategoTerm -> {Typedid ","}*   {cons("FromTerm")}

  context-free syntax 

    %% Hacks

    "<" StrategoStrategy ">" -> StrategoStrategyAngle {bracket}
    "(" StrategoStrategy ")" -> StrategoStrategy {bracket,prefer}

  variables
    [xyzfglc][0-9\']*       -> Id       {prefer}
    [xyzfgl][0-9\']*  "*"   -> {Id ","}* {prefer}
    "xs"[0-9\']*            -> {Id ","}* {prefer}

    [xyzfgl][0-9\']*  "*"   -> {ID ","}* {prefer}

    [t][0-9\']*           -> Term     {prefer}
    [t][0-9\']*   "*"     -> {Term ","}*     {prefer}
    "ts"[0-9\']*          -> {Term ","}*     {prefer}  

    [s][0-9\']*           -> Strategy {prefer}
    "ss"[0-9\']*          -> {Strategy ","}* {prefer}
    "s"[0-9\']*   "*"     -> {Strategy ","}* {prefer}

    [r][0-9\']*           -> Rule {prefer}

    "rd"[0-9\']*          -> RuleDef {prefer}
    "rd"[0-9\']*  "*"     -> RuleDef* {prefer}

    "a"[0-9\']*           -> Typedid        {prefer}
    "a"[0-9\']*   "*"     -> {Typedid ","}+ {prefer}
    "as"[0-9\']*          -> {Typedid ","}+ {prefer} 

    "tp"[0-9\']*          -> Type 
    "tp"[0-9\']*  "*"     -> {Type "*"}+  

  lexical syntax
    "xs"[0-9\']*          -> Id  {reject}

    [t][0-9\']*           -> Id  {reject}
    "ts"[0-9\']*          -> Id  {reject}  

    [s][0-9\']*           -> Id  {reject}
    "ss"[0-9\']*          -> Id  {reject}

    [r][0-9\']*           -> Id  {reject}
 
    "a"[0-9\']*           -> Id  {reject}
    "as"[0-9\']*          -> Id  {reject} 

  context-free syntax

    %% Obsolete; use |[ ... ]| syntax

    "[[" Module      "]]" -> StrategoTerm {cons("ToTerm"),prefer}
    "[[" Decl        "]]" -> StrategoTerm {cons("ToTerm")}
    "[[" Sdecl       "]]" -> StrategoTerm {cons("ToTerm")}

    "[[" Opdecl      "]]" -> StrategoTerm {cons("ToTerm")}
    "[[" Type        "]]" -> StrategoTerm {cons("ToTerm")}


    "[[" Term        "]]"  -> StrategoTerm {cons("ToTerm")}
    "[[" Term        ":" "T" "]]" -> StrategoTerm {cons("ToTerm")}

    "[[" StratRule   "]]" -> StrategoTerm {cons("ToTerm")}
    "[[" Rule        "]]" -> StrategoTerm {cons("ToTerm")}
    "[[" RuleDef     "]]" -> StrategoTerm {cons("ToTerm")}

    "[[" Strategy    "]]"  -> StrategoTerm {cons("ToTerm")}
    "[[" Strategy    ":" "S" "]]" -> StrategoTerm {cons("ToTerm")}
    "[[" StrategyDef "]]"  -> StrategoTerm {cons("ToTerm")}

    "[[" Overlay     ":" "O" "]]" -> StrategoTerm {cons("ToTerm")}

module Stratego-Strategies
exports

  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    Id 				  	  -> Typedid {cons("DefaultVarDec")}
    Id ":" Type 			  -> Typedid {cons("VarDec")}

  context-free syntax
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "fail" 				  -> Strategy {cons("Fail")}
    "id" 				  -> Strategy {cons("Id")}

    %% Abstraction

    Id					  -> SVar {cons("SVar")}
    "let" Def* "in" Strategy 		  -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}
    SVar "(" {Term ","}* "|" {Strategy ","}* ")" -> Strategy {cons("CallT")}


    %% Match and build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}

     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}


    %% Combinators

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
    Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not" "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "test" "(" Strategy ")" 		  -> Strategy {cons("Test")}
    "bagof" "(" Strategy ")" 		  -> Strategy {cons("Bagof")}


    %% Primitives

    "prim" "(" String ")" 		 	 -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")"	 -> Strategy {cons("Prim")}
    "prim" "(" String "," {Term ","}* "|" {Strategy ","}*")" 	-> Strategy {cons("PrimTS")}
    "prim" "(" String "|" {Strategy ","}*")" 	-> Strategy {cons("PrimS")}


    %% Traversal

    Int Strategy 			  -> Strategy {cons("Path")}
    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
    "thread" "(" Strategy ")" 		  -> Strategy {cons("Thread")}


    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}

    "("  ")" 		  		  -> Strategy {cons("TupleCong")}
    "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

  %% Syntactic sugar sugar

  context-free syntax

    %% Dynamic rules

    "rules" "(" RuleDef* ")" 		  -> Strategy {cons("DynamicRules")}
    "override" "rules" "(" RuleDef* ")"   -> Strategy {cons("OverrideDynamicRules")}
    "{|" {Id ","}* ":" Strategy "|}" 	  -> Strategy {cons("DynRuleScope")}

    %% Syntactic sugar

    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
    "(" Rule ")" 			  -> Strategy {cons("SRule")}
    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}
    Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
    Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}

    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}


  %% Priorities

  context-free priorities
   {Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}}
  >
    {"!" Term 				  -> Strategy {cons("Build")}
     "?" Term 				  -> Strategy {cons("Match")}
    }
  > StrategyAngle Term 		          -> Strategy {cons("BA")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
     Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
     Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

     Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
     Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
     Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}

     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

module Stratego-Overlays
exports

  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module Stratego-Rules
exports

%%  context-free syntax
%%    Id 			      ":" (Rule | Stratrule) -> RuleDef {cons("RDefNoArgs")}
%%    Id "(" {Typedid ","}* ")" ":" (Rule | Stratrule) -> RuleDef {cons("RDef")}

  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}

  context-free syntax
    Id "::" StratRule 				-> RuleDef {cons("SRDefNoArgs")}
    Id "(" {Typedid ","}* ")" "::" StratRule 	-> RuleDef {cons("SRDef")}

  context-free syntax
    Term "->" Term 		    		-> Rule {cons("RuleNoCond")}
    Term "->" Term "where" Strategy 		-> Rule {cons("Rule")}

  context-free syntax
    Strategy "-->" Strategy 			-> StratRule {cons("StratRuleNoCond")}
    Strategy "-->" Strategy "where" Strategy 	-> StratRule {cons("StratRule")}

module Stratego-Terms
exports
  context-free syntax
    Id 				-> Var  {cons("Var")}
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    Id				-> ID
    LId				-> ID

    Int 			 -> Term {cons("Int")}
    Real 			 -> Term {cons("Real")}
    String 			 -> Term {cons("Str")}
    Char 			 -> Term {cons("Char")}
    "_" 			 -> Term {cons("Wld")}
    Var 			 -> Term 
    Id "(" {Term ","}* ")" 	 -> Term {cons("Op")}
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
    Term "{" {Term ","}* "}"	 -> Term {cons("Anno")}

    "<" Strategy ">" Term 	 -> Term {cons("App")}
    StrategyAngle		 -> Term {cons("RootApp")}

    Var "@" Term 		 -> Term {cons("As")}
    "(" {Term ","}* ")" 	 -> Term {cons("Tuple")}
    "[" {Term ","}* "]" 	 -> Term {cons("List")}
    "[" {Term ","}* "|" Term "]" -> Term {cons("ListTail")}
    "_" Term 			 -> Term {cons("BuildDefault")}

    %% Var Context 		 -> Term {cons("Con")}
    %% Var "[" Term "]" "(" Id ")"  -> Term {cons("Con")}

    Var "[" Term "]" 				 -> Term {cons("Con1")}
    Var "[" Term "]" "(" Id ")" 		 -> Term {cons("Con")}
    Var "[" Term "where" Strategy "]"  		 -> Term {cons("Con3")}
    Var "[" Term "where" Strategy "]" "(" Id ")" -> Term {cons("Con4")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
  > Term "{" {Term ","}* "}"	 -> Term {cons("Anno")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Signatures
exports

  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  context-free syntax
    Id 			   	-> Sort {cons("SortNoArgs")}
    Id "(" {Term ","}* ")" 	-> Sort {cons("Sort")}

  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

  context-free syntax
    Id ":" Type 		-> Opdecl {cons("OpDecl")}

  context-free syntax
    Term 			-> Type {cons("ConstType")}
    {Type "*"}+ "->" Type 	-> Type {cons("FunType")}
    "(" Type ")" 		-> Type {bracket}

module Stratego-Script
exports

  sorts Script
  context-free syntax
    "stratego" "script" Command* -> Script {cons("Script")}
    Decl 			-> Command {cons("Command")}
    ":dump" String 		-> Command {cons("Dump")}
    ":load" String 		-> Command {cons("Load")}
    ">" Strategy 		-> Command {cons("Eval")}

module Stratego-Modules
imports Stratego-Identifiers
exports 
  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}
    "specification" Decl*	 -> Module {cons("Specification")}

  context-free syntax
    "imports" ModName* 		-> Decl {cons("Imports")}
    "rules" Def* 		-> Decl {cons("Rules")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    StrategyDef 		-> Def 
    RuleDef 			-> Def 


module Stratego-Constants
exports
  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\n\\] 			-> StrChar
    [\\] [\"tn\\] 		-> StrChar
    "\'" CharChar "\'"		-> Char
    ~[\']			-> CharChar
    [\\] [\'ntr\ ]		-> CharChar
    Char		 	-> Id {reject}

module Stratego-Identifiers
exports
  lexical syntax
    [a-zA-Z\'\.\-\_] [a-zA-Z0-9\'\.\-\_]* -> ModName
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}
  lexical syntax
    [a-zA-Z\'\-\_] [a-zA-Z0-9\'\-\_]*     -> Id
    [a-zA-Z\'\-\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
  lexical restrictions
    Id -/- [a-zA-Z0-9\'\.\-\_\*]
    LId -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "all" 		-> Id {reject}
    "constructors" 	-> Id {reject}
    "fail" 		-> Id {reject}
    "id" 		-> Id {reject}
    "in" 		-> Id {reject}
    "let" 		-> Id {reject}
    "module" 		-> Id {reject}
    "not" 		-> Id {reject}
    "one" 		-> Id {reject}
    "overlays" 		-> Id {reject}
    "override" 		-> Id {reject}
    "prim" 		-> Id {reject}
    "rules" 		-> Id {reject}
    "script" 		-> Id {reject}
    "signature" 	-> Id {reject}
    "some" 		-> Id {reject}
    "sorts" 		-> Id {reject}
    "strategies" 	-> Id {reject}
    "stratego" 		-> Id {reject}
    "test" 		-> Id {reject}
    "thread" 		-> Id {reject}
    "where" 		-> Id {reject}
  lexical restrictions
    "all" "constructors" "fail" "id" "in" "let" "module" "not" "one"
    "overlays" "override" "prim" "rules" "script" "signature" "some"
    "sorts" "strategies" "stratego" "test" "thread" "where" 
    -/- [a-zA-Z0-9\'\.\-\_]

module Stratego-Layout
exports

  lexical syntax
    [\t\ \n] 		-> Ws
    "//" ~[\n]* [\n] 	-> ShortCom
    "/*" CommChar* "*/" -> LongCom
    "(*" CommChar* "*)" -> LongCom
    "*" 		-> Asterisk
    ~[\*] 		-> CommChar
    Asterisk 		-> CommChar
  lexical restrictions
    Asterisk -/- [\/\)]

  lexical syntax
    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
    "\\begin{code}" 			   -> VeryLongCom
    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
     					   -> Eof
    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
    ~[\\] 				   -> VLCchar
    Backslash 				   -> VLCchar
    [\\] 				   -> Backslash
  lexical restrictions
    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
    Eof -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    VeryLongCom -> LAYOUT
    Ws 		-> LAYOUT
  context-free restrictions
    LAYOUT? -/- [\ \t\n]

module Stratego
imports Stratego-Layout Stratego-Identifiers Stratego-Constants 
	Stratego-Modules Stratego-Script
	Stratego-Signatures Stratego-Terms Stratego-Rules
	Stratego-Overlays Stratego-Strategies



module StrategoRenamed
imports 
  Stratego [
	Id 		=> StrategoId 
	ID 		=> StrategoID
	ModName 	=> StrategoModName
	Ws 		=> StrategoWs
	ShortCom 	=> StrategoShortCom
	LongCom 	=> StrategoLongCom
	Asterisk 	=> StrategoAsterisk
	CommChar 	=> StrategoCommChar
	VeryLongCom 	=> StrategoVeryLongCom
	Eof 		=> StrategoEof
	VLCchar 	=> StrategoVLCchar 
	Backslash 	=> StrategoBackslash
	Int 		=> StrategoInt
	Real 		=> StrategoReal
	String 		=> StrategoString
	StrChar 	=> StrategoStrChar	
        Char 		=> StrategoChar
        CharChar 	=> StrategoCharChar
	Module 		=> StrategoModule
	Script 		=> StrategoScript
	Command 	=> StrategoCommand
	Decl 		=> StrategoDecl
	Def  		=> StrategoDef
	Sdecl 		=> StrategoSdecl 
	Sort 		=> StrategoSort
	Kind 		=> StrategoKind
	Opdecl 		=> StrategoOpdecl
	Type 		=> StrategoType 
	Var 		=> StrategoVar
	Term 		=> StrategoTerm 
	Context 	=> StrategoContext
	RuleDef 	=> StrategoRuleDef
	Rule 		=> StrategoRule 
	StratRule 	=> StrategoStratRule 
	Strategy 	=> StrategoStrategy 
	StrategyAngle 	=> StrategoStrategyAngle 
	StrategyParen 	=> StrategoStrategyParen 
	SVar 		=> StrategoSVar 
	StrategyMid 	=> StrategoStrategyMid
	Mod 		=> StrategoMod
	StrategyDef 	=> StrategoStrategyDef 
	Typedid 	=> StrategoTypedid  
	Overlay 	=> StrategoOverlay
  ]


module C-AbstractDeclarators
exports
  context-free syntax
    "*" TypeQualifier* -> Pointer {cons("PointerOf")}

  context-free syntax
    UnaryAbstractDeclarator      -> AbstractDeclarator
    PostfixAbstractDeclarator    -> AbstractDeclarator
    PostfixingAbstractDeclarator -> AbstractDeclarator

  context-free syntax
    Pointer+ ( PostfixAbstractDeclarator | PostfixingAbstractDeclarator )? -> UnaryAbstractDeclarator {cons("Pointer")}

  context-free syntax
    ArrayAbstractDeclarator                   -> PostfixingAbstractDeclarator
    "(" {ParamDeclaration ","}+ "," "..." ")" -> PostfixingAbstractDeclarator {cons("ParamListVarArgs")}
    "(" {ParamDeclaration ","}* ")"           -> PostfixingAbstractDeclarator {cons("ParamList")}

  context-free syntax
    ArrayAbstractDeclarator? "[" ConstantExp? "]" -> ArrayAbstractDeclarator {cons("ArrayDecl")}

  context-free syntax
    "(" UnaryAbstractDeclarator ")"                              -> PostfixAbstractDeclarator {cons("DeclBracket")}
    "(" PostfixAbstractDeclarator ")"                            -> PostfixAbstractDeclarator {cons("DeclBracket")}
    "(" PostfixingAbstractDeclarator ")"                         -> PostfixAbstractDeclarator {cons("DeclBracket")}
    "(" UnaryAbstractDeclarator ")" PostfixingAbstractDeclarator -> PostfixAbstractDeclarator {cons("FunType")}

module C-ParameterDeclarators
exports
  context-free syntax
    ParamDeclTypeSpec ( AbstractDeclarator | IdDeclarator )?   -> ParamDeclaration {cons("ParamDecl")}
    ( DeclarationSpecifier | TypeSpecifier ) TypedefDeclarator -> ParamDeclaration {cons("ParamDecl2")}

    %%% TODO: These are almost the same as for FunDef ... 

    TypeSpecifier             -> ParamDeclTypeSpec
    DeclarationSpecifier      -> ParamDeclTypeSpec
    DeclarationQualifierList  -> ParamDeclTypeSpec
    TypeQualifier+            -> ParamDeclTypeSpec

  context-free syntax
    TypeSpecifier  AbstractDeclarator? -> TypeName {cons("TypeName")}
    TypeQualifier+ AbstractDeclarator? -> TypeName {cons("TypeName")}

module C-Enumerators
exports
  context-free syntax
    "enum" IdOrTypedefName? "{" {Enumerator ","}+ "}" -> EnumSpecifier {cons("Enum")}
    "enum" IdOrTypedefName                            -> EnumSpecifier {cons("EnumId")}

  context-free syntax
    IdOrTypedefName EnumeratorValue? -> Enumerator {cons("Enumerator")}

  context-free syntax
    "=" ConstantExp -> EnumeratorValue {cons("EnumVal")}

module C-StructsAndUnions
exports
  context-free syntax
    StructSpecifier -> ElaboratedTypeName
    UnionSpecifier  -> ElaboratedTypeName
    EnumSpecifier   -> ElaboratedTypeName

  context-free syntax
    "struct" IdOrTypedefName? "{" MemberDeclaration+ "}" -> StructSpecifier {cons("Struct")}
    "struct" IdOrTypedefName                             -> StructSpecifier {cons("StructId")}

  context-free syntax
    "union" IdOrTypedefName? "{" MemberDeclaration+ "}" -> UnionSpecifier {cons("Union")}
    "union" IdOrTypedefName                             -> UnionSpecifier {cons("UnionId")}

  context-free syntax
    TypeSpecifier  {MemberDeclarator   ","}+ ";" -> MemberDeclaration {cons("MemDecl")}
    TypeQualifier+ {MemberIdDeclarator ","}+ ";" -> MemberDeclaration {cons("MemDecl")}

  context-free syntax
    Declarator                  -> MemberDeclarator
    Declarator? ":" ConstantExp -> MemberDeclarator {cons("BitFieldSize")}

module C-Expressions
exports

  context-free syntax
    IDENTIFIER        -> PrimaryExp
    Constant          -> PrimaryExp
    StringLiteralList -> PrimaryExp
    "(" CommaExp ")"  -> PrimaryExp {bracket}

  context-free syntax
    PrimaryExp                           -> PostfixExp
    PostfixExp "[" CommaExp "]"          -> PostfixExp {cons("ArrayIndex")}
    PostfixExp "(" {AssignExp ","}* ")"  -> PostfixExp {cons("FunCall")}
    PostfixExp "."  MemberName           -> PostfixExp {cons("Field")}
    PostfixExp "->" MemberName           -> PostfixExp {cons("DerefMember")}
    PostfixExp "++"                      -> PostfixExp {cons("PostIncr")}
    PostfixExp "--"                      -> PostfixExp {cons("PostDecr")}

  context-free syntax
    IDENTIFIER  -> MemberName
    TypedefName -> MemberName

  context-free syntax
    PostfixExp     -> UnaryExp
    "++" UnaryExp  -> UnaryExp {cons("PreIncr")}
    "--" UnaryExp  -> UnaryExp {cons("PreDecr")}
    "&" CastExp    -> UnaryExp {cons("Address")}
    "*" CastExp    -> UnaryExp {cons("Deref")}
    "+" CastExp    -> UnaryExp {cons("Positive")}
    "-" CastExp    -> UnaryExp {cons("Negative")}
    "~" CastExp    -> UnaryExp {cons("Tilde")}
    "!" CastExp    -> UnaryExp {cons("Negation")}

    "sizeof" UnaryExp         -> UnaryExp {cons("SizeofExp")}
    "sizeof" "(" TypeName ")" -> UnaryExp {cons("SizeofType")}

  context-free syntax
    UnaryExp                 -> CastExp
    "(" TypeName ")" CastExp -> CastExp {cons("TypeCast")}

  context-free syntax
    CastExp            -> MulExp
    MulExp "*" CastExp -> MulExp {cons("Mul")}
    MulExp "/" CastExp -> MulExp {cons("Div")}
    MulExp "%" CastExp -> MulExp {cons("Mod")}

  context-free syntax
    MulExp            -> AddExp
    AddExp "+" MulExp -> AddExp {cons("Add")}
    AddExp "-" MulExp -> AddExp {cons("Subt")}

  context-free syntax
    AddExp               -> ShiftExp
    ShiftExp "<<" AddExp -> ShiftExp {cons("ShiftLeft")}
    ShiftExp ">>" AddExp -> ShiftExp {cons("ShiftRight")}

  context-free syntax
    ShiftExp             -> RelExp
    RelExp "<" ShiftExp  -> RelExp {cons("Lt")}
    RelExp ">" ShiftExp  -> RelExp {cons("Gt")}
    RelExp "<=" ShiftExp -> RelExp {cons("Le")}
    RelExp ">=" ShiftExp -> RelExp {cons("Ge")}

  context-free syntax
    RelExp                  -> EqualityExp
    EqualityExp "==" RelExp -> EqualityExp {cons("Equal")}
    EqualityExp "!=" RelExp -> EqualityExp {cons("NotEqual")}

  context-free syntax
    EqualityExp            -> ANDExp
    EqualityExp "&" ANDExp -> ANDExp {cons("And")}

  context-free syntax
    ANDExp               -> ExclORExp
    ANDExp "^" ExclORExp -> ExclORExp {cons("ExOr")}

  context-free syntax
    ExclORExp               -> InclORExp
    ExclORExp "|" InclORExp -> InclORExp {cons("IncOr")}

  context-free syntax
    InclORExp                    -> LogicalANDExp
    LogicalANDExp "&&" InclORExp -> LogicalANDExp {cons("LAnd")}

  context-free syntax
    LogicalANDExp                   -> LogicalORExp
    LogicalORExp "||" LogicalANDExp -> LogicalORExp {cons("LOr")}

  context-free syntax
    LogicalORExp                          -> CondExp
    LogicalORExp "?" CommaExp ":" CondExp -> CondExp {cons("IfExp")}

  context-free syntax
    CondExp                     -> AssignExp
    UnaryExp AssignOp AssignExp -> AssignExp {cons("Assign")}

  context-free syntax
    "="   -> AssignOp {cons("AssignEq")}
    "*="  -> AssignOp {cons("AssignMul")}
    "/="  -> AssignOp {cons("AssignDiv")}
    "%="  -> AssignOp {cons("AssignMod")}
    "+="  -> AssignOp {cons("AssignPlus")}
    "-="  -> AssignOp {cons("AssignMin")}
    "<<=" -> AssignOp {cons("AssignSL")}
    ">>=" -> AssignOp {cons("AssignSR")}
    "&="  -> AssignOp {cons("AssignAnd")}
    "^="  -> AssignOp {cons("AssignExp")}
    "|="  -> AssignOp {cons("AssignOr")}

  context-free syntax
    AssignExp              -> CommaExp
    AssignExp "," CommaExp -> CommaExp    {cons("Comma")}

              -> CommaExpOpt {cons("EmptyExp")}
    CommaExp  -> CommaExpOpt

  context-free syntax
    CondExp -> ConstantExp


module C-Types
exports
  context-free syntax
    "typedef"  -> StorageClass {cons("Typedef")}
    "extern"   -> StorageClass {cons("Extern")}
    "static"   -> StorageClass {cons("Static")}
    "auto"     -> StorageClass {cons("Auto")}
    "register" -> StorageClass {cons("Register")}

  context-free syntax
    "int"      -> BasicTypeName {cons("Int")}
    "char"     -> BasicTypeName {cons("Char")}
    "short"    -> BasicTypeName {cons("Short")}
    "long"     -> BasicTypeName {cons("Long")}
    "float"    -> BasicTypeName {cons("Float")}
    "double"   -> BasicTypeName {cons("Double")}
    "signed"   -> BasicTypeName {cons("Signed")}
    "unsigned" -> BasicTypeName {cons("Unsigned")}
    "void"     -> BasicTypeName {cons("Void")}

  context-free syntax
    "const"    -> TypeQualifier {cons("Const")}
    "volatile" -> TypeQualifier {cons("Volatile")}

  context-free syntax
    ( DeclarationQualifierList | TypeQualifier+ ) {IdDecl ","}* ";" -> Declaration {cons("Declaration")}
    ( DeclarationSpecifier | TypeSpecifier ) {VarDecl ","}* ";"     -> Declaration {cons("Declaration2")}

  context-free syntax
    IdDeclarator                   -> IdDecl
    IdDeclarator "=" Initializer   -> IdDecl      {cons("IdDeclInit")}
    Declarator                     -> VarDecl
    Declarator   "=" Initializer   -> VarDecl     {cons("DeclInit")}

    "{" {Initializer ","}+ "}"     -> Initializer {cons("ArrayInit")}
    "{" {Initializer ","}+ "," "}" -> Initializer {cons("ArrayInitIncomplete")}
    AssignExp                      -> Initializer {cons("AssignInit")}

  context-free syntax
    TypeQualifier* TypeOrDefName (TypeQualifier | BasicTypeName)* -> TypeSpecifier {cons("TypeSpec")}

  context-free syntax
    StorageClass  -> DeclarationQualifier
    TypeQualifier -> DeclarationQualifier

  context-free syntax
    TypeQualifier* StorageClass DeclarationQualifier*  -> DeclarationQualifierList {cons("DQualifiers")}

  context-free syntax
    TypeQualifier* StorageClass DeclarationQualifier* TypeOrDefName
    (DeclarationQualifier | BasicTypeName)* -> DeclarationSpecifier {cons("DeclSpec")}

    (BasicTypeName | ElaboratedTypeName | TypedefName) -> TypeOrDefName



module C-Identifiers
imports C-Keywords

exports
  lexical syntax
    [a-zA-Z\_] [a-zA-Z\_0-9]* -> ID

    Keyword -> ID {reject}

  lexical restrictions
    ID -/- [a-zA-Z\_0-9]

  context-free syntax
    ID          -> IDENTIFIER {cons("Id")}
    ID          -> TypedefName {cons("TypeId"), avoid}
    IDENTIFIER  -> IdOrTypedefName
    TypedefName -> IdOrTypedefName



module C-Statements
exports
  context-free syntax
    LabeledStm    -> Stm
    CompoundStm   -> Stm
    ExpStm        -> Stm
    SelectionStm  -> Stm
    IterationStm  -> Stm
    JumpStm       -> Stm

  context-free syntax
    IdOrTypedefName ":" Stm     -> LabeledStm {cons("Label")}
    "case" ConstantExp ":" Stm  -> LabeledStm {cons("Case")}
    "default" ":" Stm           -> LabeledStm {cons("Default")}

  context-free syntax
    "{" Declaration* Stm* "}" -> CompoundStm {cons("Compound")}

  context-free syntax
    CommaExpOpt ";" -> ExpStm {cons("Stat")}

  context-free syntax
    "if" "(" CommaExp ")" Stm             -> SelectionStm {cons("If")}
    "if" "(" CommaExp ")" Stm "else" Stm  -> SelectionStm {cons("IfElse")}
    "switch" "(" CommaExp ")" Stm         -> SelectionStm {cons("Switch")}

  context-free syntax
    "while" "(" CommaExp ")" Stm           -> IterationStm {cons("While")}
    "do" Stm "while" "(" CommaExp ")" ";"  -> IterationStm {cons("DoWhile")}
    "for" "(" CommaExpOpt ";" CommaExpOpt ";" CommaExpOpt ")" Stm -> IterationStm {cons("For")}

  context-free syntax
    "goto" IdOrTypedefName ";" -> JumpStm {cons("Goto")}
    "continue" ";"             -> JumpStm {cons("Continue")}
    "break" ";"                -> JumpStm {cons("Break")}
    "return" CommaExpOpt ";"   -> JumpStm {cons("Return")}
    "exit" CommaExpOpt ";"     -> JumpStm {cons("Exit")}

module C-Program
exports
  sorts TranslationUnit

  context-free syntax
    ExternalDef+ -> TranslationUnit {cons("TranslationUnit")}

    FunDef      -> ExternalDef
    Declaration -> ExternalDef

    FunDefTypeSpec FunDefDecl CompoundStm -> FunDef {cons("FunDef")}

    NoTypeSpecifier           -> FunDefTypeSpec
    TypeSpecifier             -> FunDefTypeSpec
    DeclarationSpecifier      -> FunDefTypeSpec
    DeclarationQualifierList  -> FunDefTypeSpec
    TypeQualifier+            -> FunDefTypeSpec

     -> NoTypeSpecifier {cons("NoTypeSpecifier")}

    IdDeclarator                   -> FunDefDecl
    OldFunDeclarator Declaration*  -> FunDefDecl



module C-Declarators
exports
  context-free syntax
    IdDeclarator      -> Declarator
    TypedefDeclarator -> Declarator

  context-free syntax
    Pointer* IDENTIFIER PostfixingAbstractDeclarator?           -> IdDeclarator {cons("IdDecl")}
    Pointer* "(" IdDeclarator ")" PostfixingAbstractDeclarator? -> IdDeclarator {cons("FunDecl")}

  context-free syntax
    Pointer* TypedefName PostfixingAbstractDeclarator?               -> TypedefDeclarator {cons("TypedefDeclarator1")}
    Pointer* "(" TypedefDeclarator ")" PostfixingAbstractDeclarator? -> TypedefDeclarator {cons("TypedefDeclarator2")}

  context-free syntax
    Pointer* ParenIdDeclarator "(" {IDENTIFIER ","}+ ")"         -> OldFunDeclarator     {cons("OldFunction1")}
    Pointer* "(" OldFunDeclarator ")" PostfixingAbstractDeclarator? -> OldFunDeclarator     {cons("OldFunction2")}
    IDENTIFIER                                                     -> ParenIdDeclarator
    "(" ParenIdDeclarator ")"                                    -> ParenIdDeclarator {bracket}

module C-Preprocessor
exports
  lexical syntax
    ~[\ \t\n\/]                           -> TokenChar
    [\/]                                  -> Slash
    Slash                                 -> TokenChar
    TokenChar+                            -> Token
    ( [\ \t] | ( [\\] [\n] ) | Comment )+ -> TokWS
    ( [\ \t] | Comment )*                 -> WS
    {Token TokWS}+                        -> TokenSeq
    ~[\"\ \t\n\>]+                        -> FileName

  lexical restrictions
    Slash    -/- [\*]
    Token    -/- ~[\ \t\n\/]
    TokenSeq -/- ~[\ \t\n]
    WS       -/- [\ \t]

  lexical syntax
    "#" WS "define" WS ID WS ( "(" WS {( ID WS ) ( "," WS )}* ")" WS )? TokenSeq? WS [\n] -> ControlLine

  lexical syntax
    "#" WS "undef" WS ID WS [\n]                                     -> ControlLine
    "#" WS "include" WS "<" FileName ">" WS [\n]                     -> ControlLine
    "#" WS "include" WS "\"" FileName "\"" WS [\n]                   -> ControlLine
    "#" WS "include" WS TokenSeq WS [\n]                             -> ControlLineNot
    "#" WS "line" WS [0-9]+ WS ( "\"" WS FileName WS "\"" )? WS [\n] -> ControlLine
    "#" WS IntLiteral WS "\"" FileName "\"" WS {LineFlag [\ ]+}* [\n] -> ControlLine
   
    "#" WS "error" WS TokenSeq? WS [\n]                              -> ControlLine
    "#" WS "pragma" WS TokenSeq? WS [\n]                             -> ControlLine
    "#" WS "if" WS ConstantExp WS [\n]                               -> IfLine
    "#" WS "if" WS ID WS [\n]                                        -> IfLine
    "#" WS "if" WS ID WS "!=" WS [0-9]+ WS [\n]                      -> IfLine
    "#" WS "ifdef" WS ID WS [\n]                                     -> IfLine
    "#" WS "ifndef" WS ID WS [\n]                                    -> IfLine
    "#" WS "elif" WS ConstantExp WS [\n]                             -> ElifLine
    "#" WS "else" WS [\n]                                            -> ElseLine
    
    "1" -> LineFlag
    "2" -> LineFlag
    "3" -> LineFlag
    "4" -> LineFlag

  context-free syntax
    ControlLine -> ExternalDef
    ControlLine -> MemberDeclaration

  context-free syntax
    IfLine ExternalDef* 
    ( ElifLine ExternalDef* )* 
    ( ElseLine ExternalDef* )? 
    "#" "endif" -> ExternalDef {cons("PpIf")}

module C-Lexical
exports
  lexical syntax
    [\ \t\n\12]                     -> LAYOUT
    "/*" ( ~[\*] | Asterisk )* "*/" -> Comment
    Comment                         -> LAYOUT
    [\*]                            -> Asterisk
    "//" ~[\n]* [\n]                -> Comment

  lexical restrictions
    Asterisk -/- [\/]

  context-free restrictions
    LAYOUT? -/- [\ \t\n]

module C-Constants
exports
  context-free syntax
    IntLiteral   -> Constant {cons("IntConst")}
    HexLiteral   -> Constant {cons("HexConst")}
    OctLiteral   -> Constant {cons("OctConst")}
    FloatLiteral -> Constant {cons("FloatConst")}    
    CharLiteral  -> Constant {cons("CharConst")}

    %%% TODO: Why a list??
    StringLiteral+ -> StringLiteralList {cons("StringLit")}

  lexical syntax
    [L]? "\"" StringChar* "\"" -> StringLiteral
    [L]? "'" Char "'"          -> CharLiteral    
    
    [1-9][0-9]+            IntFlags? -> IntLiteral
    "0" [xX] [0-9a-fA-F]+  IntFlags? -> HexLiteral
    "0" [0-7]+             IntFlags? -> OctLiteral    
        
    "." [0-9]+ ( [eE] "-"? [0-9]+ )?        FloatFlags? -> FloatLiteral
    [0-9]+ "." [0-9]* ( [eE] "-"? [0-9]+ )? FloatFlags? -> FloatLiteral
    [0-9]+ [eE] "-"? [0-9]+                 FloatFlags? -> FloatLiteral

    ~[\\\'\n]                  -> Char
    [\\] [ntvbrfa\\\?\'\"]     -> Char
    [\\] [x] [0-9A-E] [0-9A-E] -> Char
    OctalEsc                   -> Char

    ~[\\\"\n]                  -> StringChar
    [\\] [ntvbrfa\\\?\"]       -> StringChar
    [\\] [x] [0-9A-E] [0-9A-E] -> StringChar
    OctalEsc                   -> StringChar
    
    [\\] [0-7] [0-7]? [0-7]?   -> OctalEsc
    
    [uUlL]   -> IntFlags
    [uU][lL] -> IntFlags
    
    [lLfF]   -> FloatFlags
    [lL][fF] -> FloatFlags
    
  lexical restrictions
    FloatLiteral -/- [0-9lLfF]
    IntLiteral   -/- [0-9UuLl]
    HexLiteral   -/- [0-9a-zA-F]
    OctLiteral   -/- [0-9a-zA-F]

module C-Keywords
exports

  context-free syntax

    "auto"     -> Keyword
    "double"   -> Keyword
    "int"      -> Keyword
    "struct"   -> Keyword
    "break"    -> Keyword
    "else"     -> Keyword
    "long"     -> Keyword
    "switch"   -> Keyword
    "case"     -> Keyword
    "enum"     -> Keyword
    "register" -> Keyword
    "typedef"  -> Keyword
    "char"     -> Keyword
    "extern"   -> Keyword
    "return"   -> Keyword
    "exit"     -> Keyword
    "union"    -> Keyword
    "const"    -> Keyword
    "float"    -> Keyword
    "short"    -> Keyword
    "unsigned" -> Keyword
    "continue" -> Keyword
    "for"      -> Keyword
    "signed"   -> Keyword
    "void"     -> Keyword
    "default"  -> Keyword
    "goto"     -> Keyword
    "sizeof"   -> Keyword
    "volatile" -> Keyword
    "do"       -> Keyword
    "if"       -> Keyword
    "static"   -> Keyword
    "while"    -> Keyword

  lexical restrictions

    "auto"
    "double"   
    "int"      
    "struct"   
    "break"    
    "else"     
    "long"     
    "switch"   
    "case"     
    "enum"     
    "register" 
    "typedef"  
    "char"     
    "extern"   
    "return"   
    "exit"     
    "union"    
    "const"    
    "float"    
    "short"    
    "unsigned" 
    "continue" 
    "for"      
    "signed"   
    "void"     
    "default"  
    "goto"     
    "sizeof"   
    "volatile" 
    "do"       
    "if"       
    "static"   
    "while"    -/- [a-zA-Z\_0-9]

module C
imports C-Keywords C-Constants C-Lexical C-Preprocessor C-Declarators C-Program C-Statements
        C-Identifiers C-Types C-Expressions C-StructsAndUnions C-Enumerators
        C-ParameterDeclarators C-AbstractDeclarators



module Stratego-C
imports C StrategoRenamed

exports
  context-free syntax
                         "|[" TranslationUnit "]|" -> StrategoTerm {cons("ToTerm")}
      "translation-unit" "|[" TranslationUnit "]|" -> StrategoTerm {cons("ToTerm")}
    "c:translation-unit" "|[" TranslationUnit "]|" -> StrategoTerm {cons("ToTerm")}

            "|["  CommaExp "]|" -> StrategoTerm {cons("ToTerm")}
      "exp" "|["  CommaExp "]|" -> StrategoTerm {cons("ToTerm")}
    "c:exp" "|["  CommaExp "]|" -> StrategoTerm {cons("ToTerm")}

            "|["  Stm "]|" -> StrategoTerm {cons("ToTerm")}
      "stm" "|["  Stm "]|" -> StrategoTerm {cons("ToTerm")}
    "c:stm" "|["  Stm "]|" -> StrategoTerm {cons("ToTerm")}

      "stm*" "|[" Stm* "]|" -> StrategoTerm {cons("ToTerm")}
    "c:stm*" "|[" Stm* "]|" -> StrategoTerm {cons("ToTerm")}

            "|["  Declaration "]|" -> StrategoTerm {cons("ToTerm")}
      "dec" "|["  Declaration "]|" -> StrategoTerm {cons("ToTerm")}
    "c:dec" "|["  Declaration "]|" -> StrategoTerm {cons("ToTerm")}

      "dec*" "|["  Declaration* "]|" -> StrategoTerm {cons("ToTerm")}
    "c:dec*" "|["  Declaration* "]|" -> StrategoTerm {cons("ToTerm")}

                "|["  FunDef "]|" -> StrategoTerm {cons("ToTerm")}
      "fun-def" "|["  FunDef "]|" -> StrategoTerm {cons("ToTerm")}
    "c:fun-def" "|["  FunDef "]|" -> StrategoTerm {cons("ToTerm")}

                "|["  IdDeclarator "]|" -> StrategoTerm {cons("ToTerm")}
      "id-decl" "|["  IdDeclarator "]|" -> StrategoTerm {cons("ToTerm")}
    "c:id-decl" "|["  IdDeclarator "]|" -> StrategoTerm {cons("ToTerm")}

                "|["  MemberDeclaration "]|" -> StrategoTerm {cons("ToTerm")}
      "mem-dec" "|["  MemberDeclaration "]|" -> StrategoTerm {cons("ToTerm")}
    "c:mem-dec" "|["  MemberDeclaration "]|" -> StrategoTerm {cons("ToTerm")}

                  "|["  ParamDeclaration "]|" -> StrategoTerm {cons("ToTerm")}
      "param-dec" "|["  ParamDeclaration "]|" -> StrategoTerm {cons("ToTerm")}
    "c:param-dec" "|["  ParamDeclaration "]|" -> StrategoTerm {cons("ToTerm")}

                  "|["  TypeSpecifier "]|" -> StrategoTerm {cons("ToTerm")}
      "type-spec" "|["  TypeSpecifier "]|" -> StrategoTerm {cons("ToTerm")}
    "c:type-spec" "|["  TypeSpecifier "]|" -> StrategoTerm {cons("ToTerm")}

                  "|["  TypeName "]|" -> StrategoTerm {cons("ToTerm")}
      "type-name" "|["  TypeName "]|" -> StrategoTerm {cons("ToTerm")}
    "c:type-name" "|["  TypeName "]|" -> StrategoTerm {cons("ToTerm")}

    "~id:"      StrategoTerm -> ID           {cons("FromTerm")}
    "~id-decl:" StrategoTerm -> IdDeclarator {cons("FromTerm")}

    "~dec:"   StrategoTerm -> Declaration  {cons("FromTerm")}
    "~dec*:"  StrategoTerm -> Declaration* {cons("FromTerm")}

    "~stm:"  StrategoTerm -> Stm        {cons("FromTerm")}
    "~stm*:" StrategoTerm -> Stm*       {cons("FromTerm")}

    "~exp:"  StrategoTerm -> PrimaryExp {cons("FromTerm")}
    "~exp*:" StrategoTerm -> {AssignExp ","}* {cons("FromTerm")}

    "~type-name:"  StrategoTerm -> TypeName                {cons("FromTerm")}

    "~type-spec:"  StrategoTerm -> TypeSpecifier           {cons("FromTerm")}
    "~param-dec*:" StrategoTerm -> {ParamDeclaration ","}* {cons("FromTerm")}
    "~mem-dec*:"   StrategoTerm -> MemberDeclaration+      {cons("FromTerm")}

    "~ext-def*:"   StrategoTerm -> ExternalDef+ {cons("FromTerm")}

module Stratego-Stratego-C
imports Stratego-C StrategoStratego

