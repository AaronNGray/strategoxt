/**
 * Transformation from AsFix terms produced y the SDF2 parser to 
 * abstract syntax terms. The transformation removes layout and 
 * literals, collapses lexical terms to strings and replaces 
 * production applications by applications of a derived 
 * constructor name.
 */
module implode-asfix
imports liblib AsFix verbalize-sdf

signature
  constructors
    ToTerm       : Term -> Term
    ToStrategy   : Term -> Term
    ToBuild      : Term -> Term

    layout : String -> Layout

    meta-listvar : String -> Term
    meta-var     : String -> Term

strategies

  implode-asfix = 
    io-wrap(implode-options, implode)

  implode-options = 
    Option( "--lex",    
	where(<set-config>("--lex", <id>)),
	!"--lex            Flatten lexical substrings to strings" )

  + Option( "--layout", 
	where(<set-config>("--layout", <id>)),
	!"--layout         Remove layout nodes from the AsFix? parse tree" )

  + Option( "--lit",    
	where(<set-config>("--lit", <id>)),
	!"--lit            Remove literal nodes from the AsFix? parse tree")

  + Option( "--alt",    
	where(<set-config>("--alt", <id>)),
	!"--alt            Flat alternatives")

  + Option( "--appl",   
	where(<set-config>("--appl", <id>)),
	!"--appl           Replace 'appl' applications by constructor applications" )

  + Option( "--nt",     
	where(<set-config>("--nt", <id>)),
	!"--nt             Replace 'appl' applications by non-terminal application" )

  + Option( "--inj",    
	where(<set-config>("--inj", <id>)),
	!"--inj            Remove injections from the parse tree." )

  + Option( "--list",   
	where(<set-config>("--list", <id>)),
	!"--list           Flatten lists." )

  + Option( "--seq",    
	where(<set-config>("--seq", <id>)),
	!"--seq            Replace sequences by tuples" )

  + Option( "--pt",     
	where(<set-config>("--pt", <id>)),
	!"--pt             Remove the outer 'pt' function symbol from the parse tree" )

  + Option( "--concrete",
	where(<set-config>("--concrete", <id>)),
        !"--concrete       Skip concrete syntax parts for Stratego parsing")

  (*
  short-description(p) = 
    !["Usage: ", <p>(), " [options]"]
 
  long-description(p)  = 
    !["The implode-asfix utility maps an AsFix parse tree to an abstract syntax tree.\n",
      "Without any switches, a full implosion is performed. By specifying any switches,\n",
      "the exact implosion steps to perform can be specified.\n"]
  *)

  implode =
       ?term;
       try(where(<get-config>"--lex");    flat-lex);
       try(where(<get-config>"--layout"); remove-layout);
       try(where(<get-config>"--nt");     appl-to-sort);
       try(where(<get-config>"--list");   flat-list);
       try(where(<get-config>"--lit");    remove-lit);
       try(where(<get-config>"--appl");   replace-appl);
       try(where(<get-config>"--inj");    flat-injections);
       try(where(<get-config>"--alt");    flat-alt);
       try(where(<get-config>"--seq");    remove-seq);
       try(where(<get-config>"--pt");     remove-pt);
       try(?term; (where(<get-config>("--concrete"))
                   < implodeAsfix(id)
                   + implodeAsfix(fail)))

  // 0) Replace applications by application of sort symbol

  appl-to-sort = 
    topdown(repeat(ApplToSort))

  // 1) Flatten lexical sub trees in the parse tree
  flat-lex = downup2( try(implode-lexical), try(flat-layout))
  
  // 2) Remove layout nodes from the parse tree
  remove-layout = remove-x( is-layout' )
   
  // 3) Remove literal nodes from the parse tree
  remove-lit    = 
        topdown(try(is-list;filter(not(lit(id)))))

  // 4) Flatten Alternatives: appl(alt(a,alt(b,alt(c,d))),[d]) -> alt(4,d)
  flat-alt = topdown( try(FlatAlt) )

  // 5) Replace appl nodes with their cons attribute if available.
  replace-appl = topdown(try(appl(id,id); Cns)); conc-to-cons

  // 6) Flatten injections in a parse tree
  flat-injections = bottomup(try(Inj))

  // 7) Flatten list constructs 
  flat-list =  topdown( try(FlatList) )

  // 8) Replace sequence by tuples
  remove-seq = topdown(try(Tuple))

  // 9) Remove parsetree term from parse tree
  remove-pt = PT
  
  // Apply all previous filters together
  implodeAsfix' = 
    PT
  ; rec x(try(
       implode-lexical
    <+ appl(id, filter(not(is-layout); x))
       ; (OptList <+ Cns <+ Inj <+ Tuple <+ FlatAlt)
    <+ amb(list(x))
    ))
  ; conc-to-cons

  annotation(impl, skip) =
    appl(prod(id, id, attrs(oncetd(cons("WithAnno")))), ?l)
    ; !l
    ; filter(not(is-layout); not(appl(prod(id, oncetd(lex(id)), id), id)))
    ; ?[x|xs] 
    ; !"WithAnno"#([<skip> x| <impl> xs])

  skip-concrete(impl) =
    appl(prod(id, cf(sort("StrategoTerm" <+ "StrategoStrategy")),
      attrs(one(term(cons(?cons))))),
      oncetd(appl(prod(id,cf(oncetd(sort(id))),id),id); ?ap))
    ; !cons
    ; (("ToTerm"; !ToTerm(ap))
        <+ ("ToStrategy"; !ToStrategy(ap))
        <+ ("ToBuild"; !ToBuild(ap)))
    ; rec skip(
      alltd((appl(prod(one(varsym(id)), id, id), id); impl)
        <+ (appl(prod(id, id, attrs(oncetd(cons("FromTerm"
                                              + "FromApp")))), id); impl)
        <+ annotation(impl, skip)))

  // Apply all previous filters together
  implodeAsfix = implodeAsfix(fail)

  implodeAsfix(concrete) =
    PT
  ; rec impl(
       implode-lexical
    <+ (where(concrete)
        ; skip-concrete(impl))
    <+ appl(id, filter(not(is-layout)))
       ; (OptList; impl 
          <+ ReplCons(impl) 
          <+ Inj; impl 
          <+ Tuple; impl 
          <+ FlatAlt; impl)
    <+ amb(list(impl))
    <+ all(impl)
    )

rules

  ApplToSort :
    appl(prod(as, sort("<START>"), _), [t]) -> t

  ApplToSort :
    appl(prod(as, a, _), ts) -> c#(ts)
    where <?cf(<sort(id)>)> a
        //; ![["\""],<PpSym>,["\""]]; concat
        ; PpSym
        ; concat-strings 
       => c

  ApplToSort :
    appl(prod(as, a, _), ts) -> c#(ts)
    where <?cf(<not(sort(id))>)> a
        ; ![["\""],<PpSym>,["\""]]; concat
        //; PpSym
        ; concat-strings 
       => c

rules

  PT : parsetree(t, _) -> t  

strategies

  // Remove nodes from the prod and arguments of an appl for which 'cond'
  // holds.
  remove-x(cond) =
    topdown(try(
      appl(prod(filter(not(cond)),id,id),filter(not(cond)))))

  flat-layout =
      \ appl(prod(_,cf(layout),_), x) -> <concat-strings> x \
    + \ appl(prod(_,cf(opt(layout)),_),[]) -> layout([]) \
    + \ appl(prod(_,cf(opt(layout)),_),[xs]) -> layout([xs]) \

strategies

  FlatAlt = 
   (  appl(prod([cf(?s)<+?s], cf(?alt(a1,a2)),  id), ?args)
   <+ appl(prod([?s],         lex(?alt(a1,a2)), id), ?args)
   );  
   !(alt(a1, a2), 1);
   rec x({n, ai, aj:
        ?(s, n); !alt(n,args)
     <+ ?(alt(s, si), n); !alt(n, args)
     <+ ?(alt(ai, aj), n); <x>(aj, <add>(n, 1))
   })

// Flatten list constructs
rules

  FlatList: 
    appl(prod([cf(iter(_))],cf(iter-star(_)),_),[x]) -> <FlatList>x

  FlatList: 
    appl(prod([],cf(iter-star(_)),_),[]) -> []

  FlatList: 
    appl(prod(_,cf(iter(_)),_),[x]) -> [x]

  FlatList: 
    appl(prod(_,cf(iter(_)),_),[x|xs]) -> z
    where
      rec x (
         \ appl(prod(_,cf(iter(_)),_),[a]) -> [a] \
      <+ \ appl(prod(_,cf(iter(_)),_),[a,b]) -> <concat>[<x>a, <x>b] \
      <+ \ appl(prod(_,cf(iter(_)),_),[a,w,b]) -> <concat>[<x>a,[w],<x>b] \
      ) => z

  FlatList: 
    appl(prod([cf(iter-sep(_,_))],cf(iter-star-sep(_,_)),_),[x]) -> <FlatList>x

  FlatList: 
    appl(prod([], cf(iter-star-sep(_,_)),_),[]) -> []

  FlatList: 
    appl(prod(_,cf(iter-sep(_,_)),_),[x]) -> [x]

  FlatList: 
    appl(prod(_,cf(iter-sep(_,_)),_),[x|xs]) -> z
    where
      rec x (
          \ appl(prod(_,cf(iter-sep(_,_)),_),[a]) -> [a] \
       <+ \ appl(prod(_,cf(iter-sep(_,_)),_),[a,b,c]) -> <concat>[<x>a, [b],<x>c] \
       <+ \ appl(prod(_,cf(iter-sep(_,_)),_),[a,w1,b,w2,c])
	  -> <concat>[<x>a, [w1,b,w2],<x>c] \
      ) => z


rules
  Kids  : appl(p, ts) -> <concat> ts
  Kids' : x -> [x]

/**
 * Implode lexicals
 */
strategies

  /**
   * The yield of an AsFixTerm is the string consisting of the
   * characters at the leaves of the tree.1
   */
  yield =
    ?appl(_, _){anno*}
    ; rec x((appl(id, map(x)); Kids) <+ Kids')
    ; implode-string
    ; ?s
    ; !s{anno*}

  implode-lexical = 
       ?appl(prod([lex(_)],cf(_),_), _); yield
    <+ ?appl(prod(_,lex(_),_), _); yield
    <+ ?appl(prod(_,lit(_),_),_); !lit(<yield>)
    <+ ?appl(prod(_,varsym(cf(iter-star(_))),_),_); !meta-listvar(<yield>)
    <+ ?appl(prod(_,varsym(cf(iter-star-sep(_,_))),_),_); !meta-listvar(<yield>)
    <+ ?appl(prod(_,varsym(cf(iter(_))),_),_); !meta-listvar(<yield>)
    <+ ?appl(prod(_,varsym(cf(iter-sep(_,_))),_),_); !meta-listvar(<yield>)
    //<+ ?appl(prod(_,varsym(cf(iter-n(_))),_),_); !meta-listvar(<yield>)
    //<+ ?appl(prod(_,varsym(cf(iter-sep-n(_,_))),_),_); !meta-listvar(<yield>)
    <+ ?appl(prod(_,varsym(_),_),_); !meta-var(<yield>)

/**
 * Layout
 *
 * A tree represents layout if it is either of sort
 * cf(opt(layout)) or a literal, i.e., of sort
 * lit(_). The strategy rm-layout removes all
 * layout from a tree.
 */
strategies

  is-layout =
    appl(prod(id, cf(opt(layout)) + lit(id), id), id) 
//+ appl(prod([lit(id)],cf(alt(id,id)),no-attrs), id)
  + cf(opt(layout))

  is-layout' = appl(prod(id, cf(opt(layout)), id), id)
             + cf(opt(layout))
             + layout(id)
             
  rm-layout = rec x(try(appl(id, filter(not(is-layout); x)) + amb(list(x))))

/**
 * Constructors
 *
 * An application of a context-free production is transformed
 * into an actual application of a constructor name to the list
 * of children. The Stratego primitive \verb|mkterm| takes a pair
 * of a string \verb|c| and a list of terms \verb|ts| and turns
 * it into the term \verb|c(ts)|. The constructor \verb|c| is
 * derived from the production. If it has a \verb|cons(c)|
 * attribute that attribute is taken. Otherwise the production
 * should be some derived production for regular expressions.
 */
strategies

  ReplCons(impl) =
    ReplNamedCons(impl)
    <+ ReplConsNil(impl)
    <+ ReplConsNone(impl)
    <+ ReplConsIns(impl)
    <+ ReplConsSome(impl)
    <+ ReplConsConc(impl)

rules

  ReplNamedCons(impl) : 
    appl(p, ts){a*} -> c#(<map(impl)>ts){a*}
    where <get-cons> p => c

  get-cons : 
    prod(_, _, as) -> x
    where <oncetd(?cons(x))> as

  ReplConsNil(impl) : 
    appl(p, []) -> []
    where <is-nil> p

  ReplConsNone(impl) : 
    appl(p, []) -> None
    where <is-none> p

  ReplConsIns(impl) : 
    appl(p, [t]) -> [<impl>t]
    where <is-ins> p

  ReplConsSome(impl) : 
    appl(p, [t]) -> Some(<impl>t)
    where <is-some> p

  ReplConsConc(impl) : 
    appl(p, [t1,t2]) -> t
    where <is-conc> p
        ; <impl>t1 => ts1
        ; <impl>t2 => ts2
        ; (<[] + [id|id]> ts2; <conc>(ts1, ts2)
          <+ !Conc(ts1, ts2)) => t

  ReplConsConc(impl) : 
    appl(p, [t1,t2,t3]) -> <conc>(<impl>t1, [<impl>t2 | <impl>t3])
    where <is-conc> p
    // Note: the separator of this concatenation operator is
    // made into an element of the list. Does this make sense?

  is-nil  = ?prod([],cf(iter-star-sep(_,_)),_)
  is-nil  = ?prod([],cf(iter-star(_)),_)
  is-nil  = ?prod([],iter-star-sep(_,_),_)
  is-nil  = ?prod([],iter-star(_),_)

  is-ins  = ?prod([cf(x)], cf(iter-sep(x,_)), _)
  is-ins  = ?prod([cf(x)], cf(iter(x)), _)
  is-ins  = ?prod([x], iter-sep(x,_), _)
  is-ins  = ?prod([x], iter(x), _)

  is-conc = ?prod([_,_,_,_,_],cf(iter-sep(_,_)),_)
  is-conc = ?prod([_,_,_],cf(iter(_)),_)
  is-conc = ?prod([_,_,_],iter-sep(_,_),_)
  is-conc = ?prod([_,_],iter(_),_)
  is-conc = ?prod([_,_,_],cf(iter-star(_)),_)
  is-conc = ?prod([_,_,_],iter-star(_),_)

  is-none = ?prod([], cf(opt(_)), _)
  is-none = ?prod([], opt(_), _)

  is-some = ?prod([cf(x)], cf(opt(x)), _)
  is-some = ?prod([x], opt(x), _)

strategies

  Cns = CnsNil <+ CnsGeneric

rules

  Position : 
    t -> position(t, p)
    where <get-annotation>(t, "position") => p

  CnsNil : 
    appl(p, ts) -> []
    where <ConstrNil> p => c 

  ConstrNil : prod([],cf(iter-star-sep(_,_)),_)     -> "Nil"
  ConstrNil : prod([],cf(iter-star(_)),_)           -> "Nil"
  ConstrNil : prod([],iter-star-sep(_,_),_)         -> "Nil"
  ConstrNil : prod([],iter-star(_),_)               -> "Nil"

  CnsGeneric : 
    appl(p, ts) -> c#(ts)
    where <Constr0 <+ Constr1> p => c 

  Constr0 : 
    prod(_, _, as) -> x
    where <oncetd(?cons(x))> as

  Constr1 : prod([cf(x)], cf(iter-sep(x,_)), _)   -> "Ins"
  Constr1 : prod([cf(x)], cf(iter(x)), _)         -> "Ins"
  Constr1 : prod([x], iter-sep(x,_), _)           -> "Ins"
  Constr1 : prod([x], iter(x), _)                 -> "Ins"

  Constr1 : prod([_,_,_,_,_],cf(iter-sep(_,_)),_) -> "Conc"
  Constr1 : prod([_,_,_],    cf(iter-sep(_,_)),_) -> "Conc" // after layout removal
  Constr1 : prod([_,_,_],    cf(iter(_)),_)       -> "Conc"
  Constr1 : prod([_,_],      cf(iter(_)),_)       -> "Conc" // after layout removal
  Constr1 : prod([_,_,_],    iter-sep(_,_),_)	  -> "Conc"
  Constr1 : prod([_,_],      iter(_),_)           -> "Conc"

  Constr1 : prod([], cf(opt(_)), _)		  -> "None"
  Constr1 : prod([], opt(_), _)			  -> "None"

  Constr1 : prod([cf(x)], cf(opt(x)), _)          -> "Some"
  Constr1 : prod([x], opt(x), _)                  -> "Some"

  Constr23 : 
    prod(args, cf(iter-sep(x, y)), _) -> c
    where <(?[cf(x)]; !"Ins" <+ ?[_,_,_,_,_]; !"Conc")> args => c

rules

  OptList : 
    appl(prod([], cf(opt(s)), _), []) -> []
    where <is-asfix-list> s

  OptList : 
    appl(prod([cf(s)], cf(opt(s)), _), [x]) -> x
    where <is-asfix-list> s

  OptList : 
    appl(prod([], opt(s), _), []) -> []
    where <is-asfix-list> s

  OptList : 
    appl(prod([s], opt(s), _), [x]) -> x
    where <is-asfix-list> s

strategies

  list-sort =  
    iter(id) +
    iter-sep(id, id) +
    iter-star(id) + 
    iter-star-sep(id, id)

  is-asfix-list = 
    rec x(list-sort +
          seq(list(lit(id) + layout + x)))

/**
 * Injections
 *
 * Injections are nodes in a tree with a single child. Such nodes
 * can be ignored if they only relate syntactic information
 * instead of structural information. For instance, bracket nodes
 * are only necessary for syntactic purposes.
 * 	
 * Note: the \verb|?sort("<START>")| is necessary because
 * \verb|sort| is also defined as a strategy operator that sorts
 * lists.
 */
rules

  Inj : 
    appl(p, [t]) -> t
    where <injection> p

strategies

  injection = 
    ?prod(_, sort("<START>"), no-attrs)

  injection = 
    prod(id, id, oncetd("bracket" + bracket))

  injection = 
    ?prod([cf(iter(x))],cf(iter-star(x)),no-attrs)

  injection = 
    ?prod([cf(iter-sep(x,l))],cf(iter-star-sep(x,l)),no-attrs)

  injection = 
    prod([not(lit(id))]
	 ,rec x(sort(id) + cf(x) + lex(x) 
		+ iter(x) + iter-star(x) 
		+ iter-sep(x,lit(id)) + iter-star-sep(x,lit(id)))
	,not(oncetd(cons(id))))

  injection' = 
    prod(filter(not(cf(opt(layout)) + lit(id) )); [id], 
         cf(seq(id)), not(oncetd(cons(id))))

  injection = 
    prod([sort(id) + cf(sort(id))]
        ,injective-alt
        ,not(oncetd(cons(id))))

  injection = 
    prod([varsym(id)],id,not(oncetd(cons(id))))

  injective-alt = 
    rec x(sort(id) + cf(x) + alt(x,x))

/**
 * Tuples
 * 
 * @todo  The seq/1 constructor doesn't seem to be an AsFix construct.
 */
signature
  constructors
    seq : List(Symbol) -> Symbol

rules

  Tuple : 
    appl(prod(_, cf(seq(_)), _), args) -> ""#(args)

  Tuple : 
    appl(prod(_, seq(_), _), args) -> ""#(args)         

/**
 * Conc to Cons
 *
 * SDF2 lists are composed by means of a binary concatenation
 * operator (\verb|A+ A+ -> A+|) that we translated to
 * \verb|Conc| above. In abstract syntax trees we want to
 * represent lists by \verb|Cons/Nil| structures. The following
 * rules achieve this transformation.
 */
rules

  CTC0 : Snoc(x, y) -> Conc(x, Ins(y))
  CTC0 : [x | y] -> Conc(Ins(x), y)

  CTC1 : Conc(Conc(x, y), z) -> Conc(x, Conc(y, z))

  CTC1 : Conc( Conc( a, b, c ), d, e) ->
         Conc( a, b, Conc( c, d, e ) )
  CTC2 : Conc( x, y, z ) -> <concat>[x,[y],z]

  CTC1 : Conc([], x) -> x
  CTC1 : Conc(x, []) -> x

  CTC2 : Conc(Ins(x), []) -> [x]
  CTC2 : Conc(Ins(x), Ins(y)) -> [x, y]
  CTC2 : Conc(Ins(x), [y | z]) -> [x, y | z]

  CTC3 : Ins(x) -> [x]

  CTC4 : Conc([x | y], z) -> Conc(Ins(x), Conc(y, z))

signature
  constructors
    Ins  : a -> List(a)
    Conc : List(a) * List(a) -> List(a)
    Conc : List(a) * List(a) * List(a) -> List(a)

    Snoc : List(a) * a -> List(a)

    position : a * List(b) -> a

strategies

  conc-to-cons = 
    rec x(repeat(CTC0 + CTC1 + Conc(CTC0, id)); 
          (Conc(id, x) <+ all(x)); 
          try(CTC2; Cons(x, id) + CTC3))
