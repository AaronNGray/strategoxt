templates // URIs
 
  URI.URI             = <<Language>://<Segment*; separator="/">>

  Language.Language   = <<ID>>
  
  Segment.ID          = <<ID>.<ID>.<Qualifier>>
  Segment.Subsequent  = <subsequent(<STRING>)>
  Segment.Anonymous   = <anonymous(<STRING>)>
  Segment.ExternalDef = <context(<STRING>)>
  
  Qualifier.Unique    = <u(<STRING>)>
  Qualifier.Unique    = <u(*)>
  Qualifier.NonUnique = <*>
  
templates // index entries
 
  Index.Index = <<Partition*>>
  
  Partition.Partition = <
  partition
    <STRING><Entry*>
  >
  
  Entry.Global    = <
  global <URI>>
  
  Entry.Global    = <
	global <URI> {<Entry*>
	}>
  
  Entry.Def       = <
  binding instance <URI>>
  
  Entry.Alias     = [
  alias [URI] -> [URI]]
  
  Entry.Use       = <
  binding prospect <URI>>
  
  Entry.Prop      = <
  property <URI>.<ID> = <Term>>

  Entry.DoneTask  = <
  result <TaskID> = <Term>>
  
  Entry.FailTask  = <
  error <TaskID> = <Term>>

  Entry.StoreTask = <
  task <TaskID>
    <Instruction>>

  Entry.StoreTaskDep = [
  dependency [TaskID] -> [TaskID]]
  
lexical syntax

  TaskID = INT
  
templates // tasks
  
  Task.Task = <
  task <TaskID> depends on <TaskID*; separator=", ">
    <Instruction>>

  Instruction.Resolve = <
  resolve <ID> <ID> in <URI> <Prop> <Range>>
  
  Prop.None = <>
  Prop.Prop = <<ID> = <Term>>
  
  Range.All = <>
  Range.One = <one>
  
  Instruction.Choice = <
  choose <Term+; separator=" || ">>

  Instruction.PropCalc = <
  calculate <ID> of <Term>>
    
  Instruction.Match = <
  match <ID>(<Term*; separator=", ">) with <Term> >
  
templates // results 

  Result.Done       = <done <Term>>
  Result.Fail       = <failed <Term>>
  Result.Dependency = <depends on <INT*; separator=", ">>
  
  Term.Result = <result <TaskID>>

