definition
module Stratego-Strategies
exports

  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    Id 				  	  -> Typedid {cons("DefaultVarDec")}
    Id ":" Type 			  -> Typedid {cons("VarDec")}

  context-free syntax
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "fail" 				  -> Strategy {cons("Fail")}
    "id" 				  -> Strategy {cons("Id")}

    %% Abstraction

    Id					  -> SVar {cons("SVar")}
    "let" Def* "in" Strategy 		  -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}
    SVar "(" {Term ","}* "|" {Strategy ","}* ")" -> Strategy {cons("CallT")}


    %% Match and build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}

     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}


    %% Combinators

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
    Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not" "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "test" "(" Strategy ")" 		  -> Strategy {cons("Test")}
    "bagof" "(" Strategy ")" 		  -> Strategy {cons("Bagof")}


    %% Primitives

    "prim" "(" String ")" 		 	 -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")"	 -> Strategy {cons("Prim")}
    "prim" "(" String "," {Term ","}* "|" {Strategy ","}*")" 	-> Strategy {cons("PrimTS")}
    "prim" "(" String "|" {Strategy ","}*")" 	-> Strategy {cons("PrimS")}


    %% Traversal

    Int Strategy 			  -> Strategy {cons("Path")}
    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
    "thread" "(" Strategy ")" 		  -> Strategy {cons("Thread")}


    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}

    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
    "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

  %% Syntactic sugar sugar

  context-free syntax

    %% Dynamic rules

    "rules" "(" RuleDef* ")" 		  -> Strategy {cons("DynamicRules")}
    "override" "rules" "(" RuleDef* ")"   -> Strategy {cons("OverrideDynamicRules")}
    "{|" {Id ","}* ":" Strategy "|}" 	  -> Strategy {cons("DynRuleScope")}

    %% Syntactic sugar

    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
    "(" Rule ")" 			  -> Strategy {cons("SRule")}
    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}
    Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
    Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}

    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}


  %% Priorities

  context-free priorities
   {Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}}
  >
    {"!" Term 				  -> Strategy {cons("Build")}
     "?" Term 				  -> Strategy {cons("Match")}
    }
  > StrategyAngle Term 		          -> Strategy {cons("BA")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
     Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
     Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

     Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
     Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
     Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}

     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

module Stratego-Overlays
exports

  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module Stratego-Rules
exports

%%  context-free syntax
%%    Id 			      ":" (Rule | Stratrule) -> RuleDef {cons("RDefNoArgs")}
%%    Id "(" {Typedid ","}* ")" ":" (Rule | Stratrule) -> RuleDef {cons("RDef")}

  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}

  context-free syntax
    Id "::" StratRule 				-> RuleDef {cons("SRDefNoArgs")}
    Id "(" {Typedid ","}* ")" "::" StratRule 	-> RuleDef {cons("SRDef")}

  context-free syntax
    Term "->" Term 		    		-> Rule {cons("RuleNoCond")}
    Term "->" Term "where" Strategy 		-> Rule {cons("Rule")}

  context-free syntax
    Strategy "-->" Strategy 			-> StratRule {cons("StratRuleNoCond")}
    Strategy "-->" Strategy "where" Strategy 	-> StratRule {cons("StratRule")}

module Stratego-Terms
exports
  context-free syntax
    Id 				-> Var  {cons("Var")}
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    Id				-> ID
    LId				-> ID

    Int 			 -> Term {cons("Int")}
    Real 			 -> Term {cons("Real")}
    String 			 -> Term {cons("Str")}
    Char 			 -> Term {cons("Char")}
    "_" 			 -> Term {cons("Wld")}
    Var 			 -> Term 
    Id "(" {Term ","}* ")" 	 -> Term {cons("Op")}
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
    Term "{" {Term ","}* "}"	 -> Term {cons("Anno")}

    "<" Strategy ">" Term 	 -> Term {cons("App")}
    StrategyAngle		 -> Term {cons("RootApp")}

    Var "@" Term 		 -> Term {cons("As")}
    "(" {Term ","}* ")" 	 -> Term {cons("Tuple")}
    "[" {Term ","}* "]" 	 -> Term {cons("List")}
    "[" {Term ","}* "|" Term "]" -> Term {cons("ListTail")}
    "_" Term 			 -> Term {cons("BuildDefault")}

    %% Var Context 		 -> Term {cons("Con")}
    %% Var "[" Term "]" "(" Id ")"  -> Term {cons("Con")}

    Var "[" Term "]" 				 -> Term {cons("Con1")}
    Var "[" Term "]" "(" Id ")" 		 -> Term {cons("Con")}
    Var "[" Term "where" Strategy "]"  		 -> Term {cons("Con3")}
    Var "[" Term "where" Strategy "]" "(" Id ")" -> Term {cons("Con4")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
  > Term "{" {Term ","}* "}"	 -> Term {cons("Anno")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Signatures
exports

  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  context-free syntax
    Id 			   	-> Sort {cons("SortNoArgs")}
    Id "(" {Term ","}* ")" 	-> Sort {cons("Sort")}

  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

  context-free syntax
    Id ":" Type 		-> Opdecl {cons("OpDecl")}

  context-free syntax
    Term 			-> Type {cons("ConstType")}
    {Type "*"}+ "->" Type 	-> Type {cons("FunType")}
    "(" Type ")" 		-> Type {bracket}

module Stratego-Script
exports

  sorts Script
  context-free syntax
    "stratego" "script" Command* -> Script {cons("Script")}
    Decl 			-> Command {cons("Command")}
    ":dump" String 		-> Command {cons("Dump")}
    ":load" String 		-> Command {cons("Load")}
    ">" Strategy 		-> Command {cons("Eval")}

module Stratego-Modules
imports Stratego-Identifiers
exports 
  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}
    "specification" Decl*	 -> Module {cons("Specification")}

  context-free syntax
    "imports" ModName* 		-> Decl {cons("Imports")}
    "rules" Def* 		-> Decl {cons("Rules")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    StrategyDef 		-> Def 
    RuleDef 			-> Def 


module Stratego-Constants
exports
  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\n\\] 			-> StrChar
    [\\] [\"tn\\] 		-> StrChar
    "\'" CharChar "\'"		-> Char
    ~[\']			-> CharChar
    [\\] [\'ntr\ ]		-> CharChar
    Char		 	-> Id {reject}

module Stratego-Identifiers
exports
  lexical syntax
    [a-zA-Z\'\.\-\_] [a-zA-Z0-9\'\.\-\_]* -> ModName
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}
  lexical syntax
    [a-zA-Z\'\-\_] [a-zA-Z0-9\'\-\_]*     -> Id
    [a-zA-Z\'\-\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
  lexical restrictions
    Id -/- [a-zA-Z0-9\'\.\-\_\*]
    LId -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "all" 		-> Id {reject}
    "constructors" 	-> Id {reject}
    "fail" 		-> Id {reject}
    "id" 		-> Id {reject}
    "in" 		-> Id {reject}
    "let" 		-> Id {reject}
    "module" 		-> Id {reject}
    "not" 		-> Id {reject}
    "one" 		-> Id {reject}
    "overlays" 		-> Id {reject}
    "override" 		-> Id {reject}
    "prim" 		-> Id {reject}
    "rules" 		-> Id {reject}
    "script" 		-> Id {reject}
    "signature" 	-> Id {reject}
    "some" 		-> Id {reject}
    "sorts" 		-> Id {reject}
    "strategies" 	-> Id {reject}
    "stratego" 		-> Id {reject}
    "test" 		-> Id {reject}
    "thread" 		-> Id {reject}
    "where" 		-> Id {reject}
  lexical restrictions
    "all" "constructors" "fail" "id" "in" "let" "module" "not" "one"
    "overlays" "override" "prim" "rules" "script" "signature" "some"
    "sorts" "strategies" "stratego" "test" "thread" "where" 
    -/- [a-zA-Z0-9\'\.\-\_]

module Stratego-Layout
exports

  lexical syntax
    [\t\ \n] 		-> Ws
    "//" ~[\n]* [\n] 	-> ShortCom
    "/*" CommChar* "*/" -> LongCom
    "(*" CommChar* "*)" -> LongCom
    "*" 		-> Asterisk
    ~[\*] 		-> CommChar
    Asterisk 		-> CommChar
  lexical restrictions
    Asterisk -/- [\/\)]

  lexical syntax
    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
    "\\begin{code}" 			   -> VeryLongCom
    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
     					   -> Eof
    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
    ~[\\] 				   -> VLCchar
    Backslash 				   -> VLCchar
    [\\] 				   -> Backslash
  lexical restrictions
    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
    Eof -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    VeryLongCom -> LAYOUT
    Ws 		-> LAYOUT
  context-free restrictions
    LAYOUT? -/- [\ \t\n]

module Stratego
imports Stratego-Layout Stratego-Identifiers Stratego-Constants 
	Stratego-Modules Stratego-Script
	Stratego-Signatures Stratego-Terms Stratego-Rules
	Stratego-Overlays Stratego-Strategies



module StrategoRenamed
imports 
  Stratego [
	Id 		=> StrategoId 
	ID 		=> StrategoID
	ModName 	=> StrategoModName
	Ws 		=> StrategoWs
	ShortCom 	=> StrategoShortCom
	LongCom 	=> StrategoLongCom
	Asterisk 	=> StrategoAsterisk
	CommChar 	=> StrategoCommChar
	VeryLongCom 	=> StrategoVeryLongCom
	Eof 		=> StrategoEof
	VLCchar 	=> StrategoVLCchar 
	Backslash 	=> StrategoBackslash
	Int 		=> StrategoInt
	Real 		=> StrategoReal
	String 		=> StrategoString
	StrChar 	=> StrategoStrChar	
        Char 		=> StrategoChar
        CharChar 	=> StrategoCharChar
	Module 		=> StrategoModule
	Script 		=> StrategoScript
	Command 	=> StrategoCommand
	Decl 		=> StrategoDecl
	Def  		=> StrategoDef
	Sdecl 		=> StrategoSdecl 
	Sort 		=> StrategoSort
	Kind 		=> StrategoKind
	Opdecl 		=> StrategoOpdecl
	Type 		=> StrategoType 
	Var 		=> StrategoVar
	Term 		=> StrategoTerm 
	Context 	=> StrategoContext
	RuleDef 	=> StrategoRuleDef
	Rule 		=> StrategoRule 
	StratRule 	=> StrategoStratRule 
	Strategy 	=> StrategoStrategy 
	StrategyAngle 	=> StrategoStrategyAngle 
	StrategyParen 	=> StrategoStrategyParen 
	SVar 		=> StrategoSVar 
	StrategyMid 	=> StrategoStrategyMid
	Mod 		=> StrategoMod
	StrategyDef 	=> StrategoStrategyDef 
	Typedid 	=> StrategoTypedid  
	Overlay 	=> StrategoOverlay
  ]


module Sdf-Disamb
imports Sdf2-Syntax

exports
  lexical syntax
    "LAYOUT"            -> Sort    {reject}

  context-free syntax
    "aliases"           -> UQLiteral {reject}
    "lexical"           -> UQLiteral {reject}
    "priorities"        -> UQLiteral {reject}
    "context-free"      -> UQLiteral {reject}
    "definition"        -> UQLiteral {reject}
    "syntax"            -> UQLiteral {reject}
    "variables"         -> UQLiteral {reject}
    "module"            -> UQLiteral {reject}
    "exports"           -> UQLiteral {reject}
    "hiddens"           -> UQLiteral {reject}
    "imports"           -> UQLiteral {reject}
    "left"              -> UQLiteral {reject}
    "right"             -> UQLiteral {reject}
    "assoc"             -> UQLiteral {reject}
    "non-assoc"         -> UQLiteral {reject}
    "bracket"           -> UQLiteral {reject}
    "sorts"             -> UQLiteral {reject}
    "restrictions"      -> UQLiteral {reject}
    "constructor"       -> UQLiteral {reject}
    "memo"              -> UQLiteral {reject}

    "aliases"           -> ModuleName {reject}
    "lexical"           -> ModuleName {reject}
    "priorities"        -> ModuleName {reject}
    "context-free"      -> ModuleName {reject}
    "definition"        -> ModuleName {reject}
    "syntax"            -> ModuleName {reject}
    "variables"         -> ModuleName {reject}
    "module"            -> ModuleName {reject}
    "exports"           -> ModuleName {reject}
    "hiddens"           -> ModuleName {reject}
    "imports"           -> ModuleName {reject}
    "left"              -> ModuleName {reject}
    "right"             -> ModuleName {reject}
    "assoc"             -> ModuleName {reject}
    "non-assoc"         -> ModuleName {reject}
    "bracket"           -> ModuleName {reject}
    "sorts"             -> ModuleName {reject}
    "bracket"           -> ModuleName {reject}
    "sorts"             -> ModuleName {reject}
    "restrictions"      -> ModuleName {reject}
    "constructor"       -> ModuleName {reject}
    "memo"              -> ModuleName {reject}
    Literal "(" {Symbol ","}* ")" -> Symbols {reject}
  restrictions
    <Sort -CF>
    <UQLiteral -CF>
    "aliases"
    "lexical"
    "priorities"
    "context-free"
    "definition"
    "syntax"
    "variables"
    "module"
    "exports"
    "hiddens"
    "imports"
    "left"
    "right"
    "assoc"
    "non-assoc"
    "bracket"
    "sorts"             -/- [A-Za-z0-9]
    <NatCon -CF>        -/- [0-9]
    <LAYOUT?-CF>        -/- [\ \t\n\%]
    <NumChar -CF>       -/- [0-9]
    <ModuleName -CF>    -/- [A-Za-z0-9\_\-]

module Alias-Sdf-Syntax
imports Kernel-Sdf-Syntax

exports
  sorts Alias
  
  context-free syntax
  
    "aliases" Alias*    -> Grammar {cons("aliases")}
    Symbol "->" Symbol  -> Alias   {cons("alias")}

module Restrictions-Sdf-Syntax
imports CC-Sdf-Syntax

exports
  sorts Restriction Restrictions
  
  context-free syntax
    CharClass                    -> Lookahead
    CharClass "." Lookaheads     -> Lookahead  {cons("lookahead-seq")}
    Lookahead                    -> Lookaheads
    Lookaheads "|" Lookaheads    -> Lookaheads {cons("lookaheads-alt"),right}
    "(" Lookaheads ")"           -> Lookaheads {bracket}
    "[[" {Lookahead ","}* "]]"   -> Lookaheads {cons("lookaheads-list")}

    Symbols "-/-" Lookaheads     -> Restriction		{cons("follow-restriction")}

    Restriction*                 -> Restrictions
    "restrictions" Restrictions  -> Grammar		{cons("restrictions")}
    "reject"                     -> Attribute		{cons("reject")}
    "prefer"                     -> Attribute           {cons("prefer")}
    "avoid"                      -> Attribute           {cons("avoid")}

  context-free priorities
    CharClass "." Lookaheads     -> Lookahead
  >  Lookaheads "|" Lookaheads   -> Lookaheads


module RealCon
imports IntCon
exports
  sorts OptExp RealCon
  context-free syntax
    "e" IntCon                -> OptExp
                              -> OptExp
    IntCon "." NatCon OptExp  -> RealCon



module ATerms
imports Literals IntCon RealCon
exports
  sorts ATerms ATermList ACon AFun ATerm Ann
  context-free syntax
    ATerm                     -> ATerms
    ATerm "," ATerms          -> ATerms
    "[" "]"                   -> ATermList
    "[" ATerms "]"            -> ATermList
    IntCon                    -> ACon
    RealCon                   -> ACon
    Literal                   -> AFun
    ACon                      -> ATerm
    ATermList                 -> ATerm
    AFun                      -> ATerm
    AFun "(" ATerms ")"       -> ATerm
    "{" ATerms "}"            -> Ann
    ACon                 Ann  -> ATerm
    ATermList            Ann  -> ATerm
    AFun                 Ann  -> ATerm
    AFun "(" ATerms ")"  Ann  -> ATerm





module Label-Sdf-Syntax
imports Kernel-Sdf-Syntax Literals-Sdf-Syntax ATerms

exports
  context-free syntax
  
    Literal ":" Symbol   -> Symbol    {cons("label")}
    "cons" "(" ATerm ")" -> Attribute {cons("cons")}
    "constructor"        -> Attribute {cons("constructor")}
    "memo"               -> Attribute {cons("memo")}

module Literals
imports Layout
exports
  sorts Literal
  lexical syntax
    "\\" ~ []                  -> EscChar
    "\\" [01] [0-7] [0-7]      -> EscChar
    ~ [\0-\31\"\\] \/ [\t\n]   -> L-Char
    EscChar                    -> L-Char
    "\"" L-Char* "\""          -> Literal





module Literals-Sdf-Syntax
imports Kernel-Sdf-Syntax Literals

exports
  sorts UQLiteral
  
  lexical syntax
    [a-z]                          -> UQLiteral
    [a-z][A-Za-z0-9\-]*[A-Za-z0-9] -> UQLiteral
    
  context-free syntax
    UQLiteral  -> Literal
    Literal    -> Symbol  {cons("lit")}
    
    Literal "(" {Symbol ","}* ")" "->" Symbol Attributes -> Production	{cons("prod-fun")}

module Sorts-Sdf-Syntax
imports Kernel-Sdf-Syntax
exports
  sorts Sort
  lexical syntax
    [A-Z]                          -> Sort
    [A-Z][A-Za-z0-9\-]*[A-Za-z0-9] -> Sort
  context-free syntax
    Sort             -> Symbol					{cons("sort")}
    "sorts" Symbols  -> Grammar					{cons("Sorts")}

module Character-Syntax
imports Layout
exports
  sorts Character NumChar ShortChar
  lexical syntax
    [\\] [0-9]+                    -> NumChar
    [a-zA-Z0-9]                    -> ShortChar
    [\\] ~[\0-\31A-Za-mo-su-z0-9]  -> ShortChar
  context-free syntax
    NumChar   -> Character
    ShortChar -> Character
    "\\TOP"   -> Character
    "\\EOF"   -> Character





module Character-Class-Syntax
imports Character-Syntax

exports
  context-free syntax
    Character                 -> CharRange  
    Character "-" Character   -> CharRange   {cons("range")}

    CharRange                 -> CharRanges
    CharRanges CharRanges     -> CharRanges  {cons("conc-ranges"), right, memo}
    "(" CharRanges ")"        -> CharRanges  {bracket}
    
                              -> OptCharRanges {cons("no-charranges")}
    CharRanges                -> OptCharRanges
    
    "[" OptCharRanges "]"     -> CharClass {cons("simple-charclass")}          
    "~" CharClass             -> CharClass {cons("not-charclass")}
    CharClass "/" CharClass   -> CharClass {cons("diff-charclass"), left, memo}
    CharClass "/\\" CharClass -> CharClass {cons("and-charclass"),  left, memo}   
    CharClass "\\/" CharClass -> CharClass {cons("or-charclass"),   left}   
   "(" CharClass ")"          -> CharClass {bracket}
   
  context-free priorities
  
      "~" CharClass             -> CharClass
    > CharClass "/" CharClass   -> CharClass
    > CharClass "/\\" CharClass -> CharClass
    > CharClass "\\/" CharClass -> CharClass


module CC-Sdf-Syntax
imports Character-Class-Syntax Kernel-Sdf-Syntax

exports

  context-free syntax
    CharClass -> Symbol {cons("char-class")}

module Priority-Sdf-Syntax
imports Kernel-Sdf-Syntax
exports
  sorts Associativity Group Priority Priorities
  context-free syntax
    "left"                                -> Associativity	{cons("left")}
    "right"                               -> Associativity	{cons("right")}
    "non-assoc"                           -> Associativity	{cons("non-assoc")}
    "assoc"                               -> Associativity	{cons("assoc")}
    "bracket"                             -> Attribute		{cons("bracket")}
    Associativity                         -> Attribute		{cons("atr")}
    Production                            -> Group              {cons("simple-group")}
    "{" Productions "}"                   -> Group              {cons("prods-group")}
    "{" Associativity ":" Productions "}" -> Group              {cons("assoc-group")}
    {Group ">"}+                          -> Priority		{cons("priority-chain")}
    Group Associativity Group             -> Priority		{cons("priority-assoc")}
    {Priority  ","}*                      -> Priorities         {cons("priority-list")}
  "priorities"  Priorities              -> Grammar		{cons("priorities")}

module IntCon
imports Layout
exports
  sorts NatCon IntCon
  lexical syntax
    [0-9]+ -> NatCon
  context-free syntax
    NatCon     -> IntCon
    "+" NatCon -> IntCon
    "-" NatCon -> IntCon





module Regular-Sdf-Syntax
imports Kernel-Sdf-Syntax IntCon
exports
  context-free syntax
    "(" ")"                          -> Symbol			{cons("empty")}
    "(" Symbol Symbol+ ")"           -> Symbol			{cons("seq")}
    Symbol "?"                       -> Symbol			{cons("opt")}
    Symbol "+"                       -> Symbol			{cons("iter")}
    Symbol "*"                       -> Symbol			{cons("iter-star")}
    "{" Symbol Symbol "}" "+"        -> Symbol			{cons("iter-sep")}
    "{" Symbol Symbol "}" "*"        -> Symbol			{cons("iter-star-sep")}
    Symbol  NatCon "+"               -> Symbol			{cons("iter-n")}
    "{" Symbol Symbol "}" NatCon "+" -> Symbol			{cons("iter-sep-n")}
    "Set" "[" Symbol "]"             -> Symbol			{cons("set")}
    Symbol "#" Symbol                -> Symbol 			{right,cons("pair")}
    "(" Symbols "=>" Symbol ")"      -> Symbol			{cons("func")}
    Symbol "|" Symbol                -> Symbol 			{right,cons("alt")}
    "<<" Symbols ">>"                -> Symbol			{cons("perm")}
  context-free priorities
    {Symbol "?"               -> Symbol
    Symbol "*"                -> Symbol
    Symbol "+"                -> Symbol
    Symbol NatCon "+"         -> Symbol} >
    Symbol "#" Symbol         -> Symbol  >
    Symbol "|" Symbol         -> Symbol


module Renaming-Sdf-Syntax
imports Kernel-Sdf-Syntax
exports
  sorts Renaming Renamings
  context-free syntax
    "[" Renaming* "]"     -> Renamings
    Symbol     "=>" Symbol      -> Renaming
    Production "=>" Production  -> Renaming





module Modular-Sdf-Syntax
imports Kernel-Sdf-Syntax Renaming-Sdf-Syntax
exports
  sorts ModuleId ModuleName Import Imports
        Section Sections Module Definition ImpSection
  lexical syntax
    [A-Za-z0-9\_\-]+        -> ModuleWord
    ModuleWord              -> ModuleId
    "/" ModuleId            -> ModuleId
    ModuleWord "/" ModuleId -> ModuleId
  context-free syntax
    Module*                                  -> Definition	
    "module" ModuleName ImpSection* Section* -> Module		{cons("Module")}
    "exports" Grammar            -> Section			{cons("Exports")}
    "hiddens" Grammar            -> Section			{cons("Hiddens")}
    Section*                     -> Sections
    ModuleId                     -> ModuleName		
    ModuleId "[" Symbols "]"     -> ModuleName                  {cons("RenamedModuleName")}
    "id" "(" ModuleName ")"      -> Attribute			{cons("Id")}
    "imports" Imports            -> ImpSection			{cons("Imports")}
    ImpSection                   -> Grammar
    Import*                      -> Imports
    ModuleName                   -> Import
    ModuleName Renamings         -> Import
    "(" Import ")"               -> Import {bracket}

module Basic-Sdf-Syntax
imports Kernel-Sdf-Syntax

exports
  context-free syntax
  
    "lexical" "syntax"      Productions -> Grammar {cons("lexical-syntax")}
    "context-free" "syntax" Productions -> Grammar {cons("context-free-syntax")}
    "variables"             Productions -> Grammar {cons("variables")}
    "lexical" "variables"   Productions -> Grammar {cons("lexical-variables")}

    "<" Symbol "-CF"  ">"               -> Symbol {cons("cf")}
    "<" Symbol "-LEX" ">"               -> Symbol {cons("lex")}
    "<" Symbol "-VAR" ">"               -> Symbol {cons("varsym")}
    "LAYOUT"                            -> Symbol {cons("layout")}

module Grammar-Syntax
imports Layout

exports
  sorts Grammar
  
  context-free syntax
    "(/)"            -> Grammar {cons("empty-grammar")}
    Grammar Grammar  -> Grammar {cons("conc-grammars"), assoc}
    "(" Grammar ")"  -> Grammar {bracket}

module Layout
exports
  lexical syntax
    [\ \t\n]           -> LAYOUT
    "%%" ~[\n]* [\n]   -> LAYOUT
    "%" ~[\n\%]+ "%"   -> LAYOUT
    "default-"         -> TagId
  context-free syntax
                       -> TagId





module Symbols
imports Layout
exports
  sorts Symbol Symbols
  context-free syntax
    "(" Symbol ")"       -> Symbol {bracket}
    Symbol*              -> Symbols





module Kernel-Sdf-Syntax
imports Symbols Grammar-Syntax

exports

  sorts Attribute Attributes Production Productions
  
  context-free syntax
    "{" {Attribute ","}* "}"       -> Attributes  {cons("attrs")}
                                   -> Attributes  {cons("no-attrs")}
    Symbols "->" Symbol Attributes -> Production  {cons("prod")}
    Production*                    -> Productions
    "syntax" Productions           -> Grammar     {cons("syntax")}

module Sdf2-Syntax
imports Kernel-Sdf-Syntax
        Basic-Sdf-Syntax
        Modular-Sdf-Syntax
        Regular-Sdf-Syntax
        Priority-Sdf-Syntax
        CC-Sdf-Syntax
        Sorts-Sdf-Syntax
        Literals-Sdf-Syntax
        Label-Sdf-Syntax
        Restrictions-Sdf-Syntax
        Alias-Sdf-Syntax
        Sdf-Disamb
        
exports
  sorts SDF SDF-GrammarID Module-GrammarID
  
  context-free syntax
  
    SDF     ->    SDF-GrammarID {prefer, cons("\"sdf-2.1\"")}
    Module  -> Module-GrammarID {prefer, cons("\"sdf-2.1\"")}
    
  context-free syntax
    "<START>"                                   -> Symbol	{cons("START")}
    "<Start>"                                   -> Symbol	{cons("Start")}
    "lexical"      "priorities" Priorities      -> Grammar	{cons("lexical-priorities")}
    "context-free" "priorities" Priorities      -> Grammar	{cons("context-free-priorities")}
    "lexical"      "restrictions" Restrictions  -> Grammar	{cons("lexical-restrictions")}
    "context-free" "restrictions" Restrictions  -> Grammar	{cons("context-free-restrictions")}
    "definition" Definition                     -> SDF		{cons("Definition")}
    
  context-free priorities
    Symbol "|" Symbol  -> Symbol >
    Literal ":" Symbol -> Symbol

module Stratego-Sdf2
imports Sdf2-Syntax StrategoRenamed

exports
  context-free syntax

    "|[" Production  "]|" -> StrategoTerm {cons("ToTerm"), prefer}
    "|[" Symbol      "]|" -> StrategoTerm {cons("ToTerm")}
    "|[" Production+ "]|" -> StrategoTerm {cons("ToTerm")}

    "~"     StrategoTerm   -> Symbol {cons("FromTerm")}
    "~sym:" StrategoTerm   -> Symbol {cons("FromTerm")}

  variables
    "sym" [0-9]*         -> Symbol {prefer}