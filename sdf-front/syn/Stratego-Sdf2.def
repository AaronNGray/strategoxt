definition
module Stratego-Overlays
imports
  Stratego-Terms
  Stratego-Identifiers

exports
  sorts Overlay
  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module Stratego-Strategies
imports
  Stratego-Terms
  Stratego-Constants
  Stratego-Rules
  Stratego-Modules
  Stratego-Signatures

exports
  sorts StrategyDef

  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}

  sorts Typedid
  context-free syntax
    ID 				  	  -> Typedid {cons("DefaultVarDec")}
    ID ":" Type 			  -> Typedid {cons("VarDec")}

  sorts StrategyParen Strategy SVar StrategyMid StrategyCurly StrategyAngle Mod
  context-free syntax
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "fail" 				  -> Strategy {cons("Fail")}
    "id" 				  -> Strategy {cons("Id")}

    %% Abstraction

    Id					  -> SVar {cons("SVar")}
    "let" Def* "in" Strategy "end"	  -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}
    SVar "(" {Strategy ","}* 
         "|" {Term ","}* ")" 	          -> Strategy {cons("CallT")}


    %% Match and build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}

     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}


    %% Combinators

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
    Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}
    "bagof" "(" Strategy ")" 		  -> Strategy {cons("Bagof")}


    %% Primitives

    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}
    "prim" "(" String "," {Strategy ","}* 
                      "|" {Term ","}*")"  -> Strategy {cons("PrimT")}

    %% Traversal

    Int Strategy 			  -> Strategy {cons("Path")}
    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
    "thread" "(" Strategy ")" 		  -> Strategy {cons("Thread")}

    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}
    Char 			 	  -> Strategy {cons("CharCong")}

    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}

    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
    "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

  %% Syntactic sugar sugar

  context-free syntax

    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
    "(" Rule ")" 			  -> Strategy {cons("SRule")}
    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}
    Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
    Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}
    "if" Strategy "then" Strategy "else" Strategy "end" -> Strategy {cons("CondChoice")}
    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}

    "switch" Strategy ("case" Strategy ":" Strategy)* "end" -> Strategy {cons("SwitchChoiceNoOtherwise")}
    "switch" Strategy ("case" Strategy ":" Strategy)*
                       "otherwise" ":" Strategy "end" -> Strategy {cons("SwitchChoice")}

    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}

  %% Priorities

  context-free priorities
    { Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
      Strategy "#" StrategyParen          -> Strategy {cons("ExplodeCong")}
    }
  > { "!" Term 				  -> Strategy {cons("Build")}
      "?" Term 				  -> Strategy {cons("Match")}
    }
  > StrategyAngle Term 		          -> Strategy {cons("BA")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
     Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
     Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

     Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
     Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
     Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}

     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

module Stratego-DynamicRules
imports
  Stratego-Identifiers
  Stratego-Strategies
  Stratego-Rules

exports
 
  sorts ScopeLabels
  context-free syntax

    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}

    {DynRuleScopeId ","}*   -> ScopeLabels
    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}

  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
  context-free syntax

    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}

    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}

    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}

    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
    RuleDec                     -> DynRuleId {cons("DynRuleId")}

    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}

  context-free syntax

    Id                          -> RuleDec {cons("RDecNoArgs")}
    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}

  sorts RuleNames
  context-free syntax

    {Id ","}*				  -> RuleNames
    "~" Term				  -> RuleNames {cons("RuleNames")}

    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
    "\\" RuleNames "/*" Strategy          -> Strategy {cons("DynRuleUnionFix")}

    "/" RuleNames "\\" 
        RuleNames "/*"  Strategy          -> Strategy {cons("DynRuleIntersectUnionFix")}

    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}

    Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}

  context-free priorities
    StrategyAngle Term 		          -> Strategy {cons("BA")}
  > {"/" RuleNames "\\*" Strategy         -> Strategy {cons("DynRuleIntersectFix")}
     "\\" RuleNames "/*" Strategy         -> Strategy {cons("DynRuleUnionFix")}
     "/" RuleNames "\\" 
         RuleNames "/*"  Strategy         -> Strategy {cons("DynRuleIntersectUnionFix")}
    }
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
  > Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}

  context-free syntax %% legacy Dynamic rules

    "override" "rules" "(" RuleDef* ")"		 -> Strategy {cons("OverrideDynamicRules")}
    "extend"   "rules" "(" RuleDef* ")"		 -> Strategy {cons("ExtendDynamicRules")}
    "extend" "override" "rules" "(" RuleDef* ")" -> Strategy {cons("ExtendOverrideDynamicRules")}

module Stratego-Rules
imports Stratego-Strategies
exports

%%  context-free syntax
%%    Id 			      ":" (Rule | Stratrule) -> RuleDef {cons("RDefNoArgs")}
%%    Id "(" {Typedid ","}* ")" ":" (Rule | Stratrule) -> RuleDef {cons("RDef")}

  sorts RuleDef
  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}

  context-free syntax
    Id "::" StratRule 				-> RuleDef {cons("SRDefNoArgs")}
    Id "(" {Typedid ","}* ")" "::" StratRule 	-> RuleDef {cons("SRDef")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}*")" "::" StratRule 	-> RuleDef {cons("SRDefT")}

  sorts Rule
  context-free syntax
    Term "->" Term 		    		-> Rule {cons("RuleNoCond")}
    Term "->" Term "where" Strategy 		-> Rule {cons("Rule")}

  sorts StratRule
  context-free syntax
    Strategy "-->" Strategy 			-> StratRule {cons("StratRuleNoCond")}
    Strategy "-->" Strategy "where" Strategy 	-> StratRule {cons("StratRule")}

module Stratego-Terms
imports
  Stratego-Identifiers
  Stratego-Strategies

exports
  sorts ID LID Var
  context-free syntax
    Id 				-> Var  {cons("Var")}
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    Id				-> ID
    LId				-> ID
    ":" Var                     -> Var  {cons("SeqVar")}

  sorts Term
  context-free syntax
    Int 			 -> Term {cons("Int")}
    Real 			 -> Term {cons("Real")}
    String 			 -> Term {cons("Str")}
    Char 			 -> Term {cons("Char")}
    "_" 			 -> Term {cons("Wld")}
    Var 			 -> Term 
    Id "(" {Term ","}* ")" 	 -> Term {cons("Op")}
    String "(" {Term ","}* ")" 	 -> Term {cons("OpQ")}
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
    Term "{" {Term ","}* "}"	 -> Term {cons("Anno")}
    Term "{" {Term ","}* "|" Term "}" -> Term {cons("AnnoTail")}

    "<" Strategy ">" Term 	 -> Term {cons("App")}
    StrategyAngle		 -> Term {cons("RootApp")}

    Var "@" Term 		 -> Term {cons("As")}
    "(" {Term ","}* ")" 	 -> Term {cons("Tuple")}
    "[" {Term ","}* "]" 	 -> Term {cons("List")}
    "[" {Term ","}* "|" Term "]" -> Term {cons("ListTail")}
    "_" Term 			 -> Term {cons("BuildDefault")}

    %% Var Context 		 -> Term {cons("Con")}
    %% Var "[" Term "]" "(" Id ")"  -> Term {cons("Con")}

    Var "[" Term "]" 				 -> Term {cons("Con1")}
    Var "[" Term "]" "(" Id ")" 		 -> Term {cons("Con")}
    Var "[" Term "where" Strategy "]"  		 -> Term {cons("Con3")}
    Var "[" Term "where" Strategy "]" "(" Id ")" -> Term {cons("Con4")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
  > Term "{" {Term ","}* "}"	 -> Term {cons("Anno")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Signatures
imports
  Stratego-Identifiers
  Stratego-Constants

exports

  sorts Sdecl
  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  sorts Sort
  context-free syntax
    LCID 			 -> Sort {cons("SortVar")}
    UCID 			 -> Sort {cons("SortNoArgs")}
    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}
    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}

  sorts Kind
  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

  sorts Opdecl
  context-free syntax
    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
           ":" Type 		-> Opdecl {cons("OpDeclInj")}

  sorts Type
  context-free syntax
    Sort			-> Type {cons("ConstType")}
    {Type "*"}+ "->" Type 	-> Type {cons("FunType")}
    "(" Type ")" 		-> Type {bracket}

module Stratego-Modules
imports
  Stratego-Identifiers
  Stratego-Overlays
  Stratego-Strategies
  Stratego-Rules
  Stratego-Signatures

exports 
  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}
    "specification" Decl*	 -> Module {cons("Specification")}

  sorts Decl Def
  context-free syntax
    "imports" ModName* 		-> Decl {cons("Imports")}
    "rules" Def* 		-> Decl {cons("Rules")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    StrategyDef 		-> Def 
    RuleDef 			-> Def 


module Stratego-Constants
imports Stratego-Identifiers
exports
  sorts Int Real String StrChar Char CharChar
  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\\] 			-> StrChar
    [\\] [\"tnr\\] 		-> StrChar
    "\'" CharChar "\'"		-> Char
    ~[\']			-> CharChar
    [\\] [\'ntr\ ]		-> CharChar
    Char		 	-> Id {reject}

module Stratego-Identifiers
exports
  sorts ModName
  lexical syntax
    [a-zA-Z\'\.\-\_] [a-zA-Z0-9\'\.\-\_]* -> ModName
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}

  sorts Id LId LCID UCID
  lexical syntax
    [a-zA-Z\'\-\_] [a-zA-Z0-9\'\-\_]*     -> Id
    [a-zA-Z\'\-\_] [a-zA-Z0-9\'\-\_]* "*" -> LId

    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID
  lexical restrictions
    Id   -/- [a-zA-Z0-9\'\-\_\*]
    LId  -/- [a-zA-Z0-9\'\-\_]
    LCID -/- [a-zA-Z0-9\'\-\_]
    UCID -/- [a-zA-Z0-9\'\-\_]

  lexical syntax
    "_"                 -> Id {reject}
    "all" 		-> Id {reject}
    "constructors" 	-> Id {reject}
    "fail" 		-> Id {reject}
    "id" 		-> Id {reject}
    "in" 		-> Id {reject}
    "let" 		-> Id {reject}
    "module" 		-> Id {reject}
    "not" 		-> Id {reject}
    "one" 		-> Id {reject}
    "overlays" 		-> Id {reject}
    "override" 		-> Id {reject}
    "prim" 		-> Id {reject}
    "rules" 		-> Id {reject}
    "script" 		-> Id {reject}
    "signature" 	-> Id {reject}
    "some" 		-> Id {reject}
    "sorts" 		-> Id {reject}
    "strategies" 	-> Id {reject}
    "stratego" 		-> Id {reject}
    "test" 		-> Id {reject}
    "thread" 		-> Id {reject}
    "where" 		-> Id {reject}
  lexical restrictions
    "all" "constructors" "fail" "id" "in" "let" "module" "not" "one"
    "overlays" "override" "prim" "rules" "script" "signature" "some"
    "sorts" "strategies" "stratego" "test" "thread" "where" 
    -/- [a-zA-Z0-9\'\-\_]

module Stratego-Layout
exports
  sorts Ws ShortCom LongCom CommChar1 CommChar2 Asterisk1 Asterisk2
  lexical syntax
    [\t\ \n\r]		 -> Ws

    "//" ~[\n]* ([\n] | Eof) -> ShortCom
    "/*" CommChar1* "*/"  -> LongCom
    "(*" CommChar2* "*)"  -> LongCom

    ~[\*]      -> CommChar1
    ~[\*]      -> CommChar2

    "*"        -> Asterisk1
    "*"        -> Asterisk2
    Asterisk1  -> CommChar1
    Asterisk2  -> CommChar2

  lexical restrictions
    Asterisk1 -/- [\/]
    Asterisk2 -/- [\)]

  sorts VeryLongCom Eof VLCchar Backslash
  lexical syntax
    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
    "\\begin{code}" 			   -> VeryLongCom
    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
     					   -> Eof
    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
    ~[\\] 				   -> VLCchar
    Backslash 				   -> VLCchar
    [\\] 				   -> Backslash

  lexical restrictions
    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
    Eof -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    VeryLongCom -> LAYOUT
    Ws 		-> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]

module Stratego
imports
  Stratego-Layout
  Stratego-Identifiers
  Stratego-Constants 
  Stratego-Modules
  Stratego-Signatures
  Stratego-Terms
  Stratego-Rules
  Stratego-DynamicRules
  Stratego-Strategies
  Stratego-Overlays

hiddens
  context-free start-symbols Module

module StrategoRenamed
imports Stratego
          [ RuleNames      => StrategoRuleNames
            RuleDec        => StrategoRuleDec
            DynRuleScopeId => StrategoDynRuleScopeId
            DynRuleId      => StrategoDynRuleId
            DynRuleDef     => StrategoDynRuleDef
            ScopeLabels    => StrategoScopeLabels
            Def            => StrategoDef
            Decl           => StrategoDecl
            Module         => StrategoModule
            Overlay        => StrategoOverlay
            ID             => StrategoID
            LID            => StrategoLID
            Var            => StrategoVar
            Mod            => StrategoMod
            StrategyCurly  => StrategoStrategyCurly
            StrategyMid    => StrategoStrategyMid
            StrategyAngle  => StrategoStrategyAngle
            SVar           => StrategoSVar
            StrategyParen  => StrategoStrategyParen
            Typedid        => StrategoTypedid
            StrategyDef    => StrategoStrategyDef
            Type           => StrategoType
            Opdecl         => StrategoOpdecl
            Kind           => StrategoKind
            Sort           => StrategoSort
            Sdecl          => StrategoSdecl
            StratRule      => StrategoStratRule
            Rule           => StrategoRule
            RuleDef        => StrategoRuleDef
            CharChar       => StrategoCharChar
            Char           => StrategoChar
            StrChar        => StrategoStrChar
            String         => StrategoString
            Real           => StrategoReal
            Int            => StrategoInt
            UCID           => StrategoUCID
            LCID           => StrategoLCID
            LId            => StrategoLId
            Id             => StrategoId
            ModName        => StrategoModName
            Backslash      => StrategoBackslash
            VLCchar        => StrategoVLCchar
            Eof            => StrategoEof
            VeryLongCom    => StrategoVeryLongCom
            Asterisk2      => StrategoAsterisk2
            Asterisk1      => StrategoAsterisk1
            CommChar2      => StrategoCommChar2
            CommChar1      => StrategoCommChar1
            LongCom        => StrategoLongCom
            ShortCom       => StrategoShortCom
            Ws             => StrategoWs
            Term           => StrategoTerm
            Strategy       => StrategoStrategy ]


module languages/sdf2/syntax/Aliases

imports languages/sdf2/syntax/Kernel

exports
  sorts Alias Aliases
  context-free syntax 
    "aliases" Aliases              -> Grammar  {cons("aliases")}
    Symbol arrow:"->" alias:Symbol -> Alias    {cons("alias")}
    list:Alias*                    -> Aliases



module languages/sdf2/syntax/Restrictions

imports languages/sdf2/syntax/CC

exports
  sorts Lookahead Lookaheads Restriction Restrictions

  context-free syntax
    CharClass                          -> Lookahead  {cons("char-class")}
    head:CharClass "." tail:Lookaheads -> Lookahead  {cons("seq")}

    Lookahead                                -> Lookaheads  {cons("single")}
    "left":Lookaheads "|" "right":Lookaheads -> Lookaheads  {cons("alt"),right}
    "(" Lookaheads ")"                       -> Lookaheads  {bracket}
    "[[" list:{Lookahead ","}* "]]"          -> Lookaheads  {cons("list")}

    Symbols "-/-" Lookaheads -> Restriction  {cons("follow")}

    list:Restriction* -> Restrictions

    "restrictions" Restrictions -> Grammar  {cons("restrictions")}

    "reject" -> Attribute  {cons("reject")}
    "prefer" -> Attribute  {cons("prefer")}
    "avoid"  -> Attribute  {cons("avoid")}

  context-free priorities    
    CharClass "." Lookaheads    -> Lookahead >
    Lookaheads "|" Lookaheads   -> Lookaheads


module languages/sdf2/syntax/Labels

imports languages/sdf2/syntax/Kernel 
        languages/sdf2/syntax/Literals 
        languages/aterm/syntax/ATerms

exports
  context-free syntax
    label:Literal ":" Symbol -> Symbol  {cons("label")}

module languages/sdf2/syntax/Literals

imports languages/sdf2/syntax/Kernel 
imports languages/aterm/syntax/Literals

exports
  context-free syntax
    Literal  -> Symbol  {cons("lit")}

    function-symbol: Literal "(" arguments:{Symbol ","}* ")"
      "->" result:Symbol Attributes -> Production  {avoid, cons("prod-fun")}

module languages/sdf2/syntax/Start-Symbols

imports languages/sdf2/syntax/Kernel

exports
  context-free syntax
  
    "start-symbols" Symbols                -> Grammar {cons("kernel-start-symbols")} 
    "lexical" "start-symbols" Symbols      -> Grammar {cons("lexical-start-symbols")}
    "context-free" "start-symbols" Symbols -> Grammar {cons("context-free-start-symbols")}

module languages/sdf2/syntax/Sorts

imports languages/sdf2/syntax/Kernel

exports
  sorts Sort
  lexical syntax
    [A-Z]                          -> Sort {cons("one-char")}
    [A-Z][A-Za-z0-9\-]*[A-Za-z0-9] -> Sort {cons("more-chars")}

  context-free syntax
    Sort                                    -> Symbol  {cons("sort")}
    Sort "[[" parameters:{Symbol ","}+ "]]" -> Symbol  {cons("parameterized-sort")}

    "sorts" Symbols -> Grammar {cons("sorts")}

  lexical restrictions
    Sort -/- [A-Za-z0-9]

module languages/sdf2/syntax/Character

imports basic/Comments

exports
  sorts Character NumChar ShortChar
  lexical syntax
    [\\] [0-9]+                     -> NumChar   {cons("digits")}
    [a-zA-Z0-9]                     -> ShortChar {cons("regular")}
    [\\] ~[\0-\31A-Za-mo-qsu-z0-9]  -> ShortChar {cons("escaped")}
  context-free syntax
    NumChar   -> Character {cons("numeric")}
    ShortChar -> Character {cons("short")}
    "\\TOP"   -> Character {cons("top")}
    "\\EOF"   -> Character {cons("eof")}
    "\\BOT"   -> Character {cons("bot")}
    "\\LABEL_START" -> Character {cons("label_start")}

module languages/sdf2/syntax/Character-Class

imports languages/sdf2/syntax/Character

hiddens
  sorts CharRange CharRanges OptCharRanges 
exports
  sorts CharClass
  context-free syntax 
    Character                           -> CharRange
    start:Character "-" end:Character   -> CharRange            {cons("range")}

    CharRange                                   -> CharRanges
    "left":CharRanges "right":CharRanges        -> CharRanges   {cons("conc"),right,memo}
    "(" CharRanges ")"                          -> CharRanges   {bracket}

                              -> OptCharRanges  {cons("absent")}
    CharRanges                -> OptCharRanges  {cons("present")}

    "[" OptCharRanges "]"                    -> CharClass  {cons("simple-charclass")}
    "~" CharClass                            -> CharClass  {cons("comp")}
    "left":CharClass "/" "right":CharClass   -> CharClass  {cons("diff"),left,memo}
    "left":CharClass "/\\" "right":CharClass -> CharClass  {cons("isect"),left,memo}
    "left":CharClass "\\/" "right":CharClass -> CharClass  {cons("union"),left}
    "(" CharClass ")"                        -> CharClass  {bracket, avoid}

  context-free priorities
    "~" CharClass             -> CharClass >
    CharClass "/" CharClass   -> CharClass >
    CharClass "/\\" CharClass -> CharClass >
    CharClass "\\/" CharClass -> CharClass           


module languages/sdf2/syntax/CC

imports languages/sdf2/syntax/Character-Class 
        languages/sdf2/syntax/Kernel

exports
  context-free syntax
    CharClass -> Symbol {cons("char-class")}

module languages/sdf2/syntax/Priority

imports languages/sdf2/syntax/Kernel

exports
  sorts Associativity Group Priority Priorities

  context-free syntax
    "left"      -> Associativity  {cons("left")}
    "right"     -> Associativity  {cons("right")}
    "non-assoc" -> Associativity  {cons("non-assoc")}
    "assoc"     -> Associativity  {cons("assoc")}

    "bracket"     -> Attribute  {cons("bracket")}
    Associativity -> Attribute  {cons("assoc")}

    Production                            -> Group  {cons("simple-group")}
    "{" Productions "}"                   -> Group  {cons("prods-group")}
    "{" Associativity ":" Productions "}" -> Group  {cons("assoc-group")}

    list:{Group ">"}+                        -> Priority  {cons("chain")}
    "left":Group Associativity "right":Group -> Priority  {cons("assoc")}

    list:{Priority  ","}* -> Priorities

    "priorities" Priorities  -> Grammar  {cons("priorities")}

module languages/sdf2/syntax/Lifting

imports languages/sdf2/syntax/Kernel

exports
  context-free syntax
    left-quote:"`" Symbol right-quote:"`" -> Symbol  {cons("lifting")}

module languages/sdf2/syntax/Regular

imports languages/sdf2/syntax/Kernel 
imports languages/aterm/syntax/IntCon

exports
  context-free syntax
    "(" ")"                                       -> Symbol {cons("empty")}
    "(" head:Symbol tail:Symbol+ ")"              -> Symbol {cons("seq")}
    Symbol "?"                                    -> Symbol {cons("opt")}
    Symbol "+"                                    -> Symbol {cons("iter")}
    Symbol "*"                                    -> Symbol {cons("iter-star")}
    "{" Symbol sep:Symbol "}" "+"                 -> Symbol {cons("iter-sep")}
    "{" Symbol sep:Symbol "}" "*"                 -> Symbol {cons("iter-star-sep")}
    Symbol  n:NatCon "+"                          -> Symbol {cons("iter-n")}
    "{" Symbol sep:Symbol "}" n:NatCon "+"        -> Symbol {cons("iter-sep-n")}
    "<" head:Symbol "," rest:{Symbol ","}+ ">"    -> Symbol {cons("tuple")}
    "left":Symbol "#" "right":Symbol              -> Symbol {right,cons("pair")}
    "(" arguments:Symbols "=>" results:Symbol ")" -> Symbol {cons("func")}
    "left":Symbol "|" "right":Symbol              -> Symbol {right,cons("alt")}
    "(" "left":Symbol "->" "right":Symbol ")"     -> Symbol {cons("strategy")}

  context-free priorities
    {Symbol "?"               -> Symbol
    Symbol "*"                -> Symbol
    Symbol "+"                -> Symbol
    Symbol NatCon "+"         -> Symbol} >
    Symbol "#" Symbol         -> Symbol  >
    Symbol "|" Symbol         -> Symbol       


module languages/sdf2/syntax/Renaming

imports languages/sdf2/syntax/Kernel

exports
  sorts Renaming Renamings
  context-free syntax 
    "[" list:Renaming* "]" -> Renamings  {cons("renamings")}

    from:Symbol "=>" to:Symbol                   -> Renaming  {cons("symbol")}
    from-prod:Production "=>" to-prod:Production -> Renaming  {cons("production")}

module languages/sdf2/syntax/Modules

imports languages/sdf2/syntax/Kernel 
        languages/sdf2/syntax/Renaming

hiddens
  sorts ModuleWord
exports
  context-free start-symbols Module

  sorts ModuleId ModuleName Import Imports
        Section Sections Module Definition ImpSection

  lexical syntax    
    [A-Za-z0-9\_\-]+ -> ModuleWord  {cons("word")}

    ModuleWord              -> ModuleId  {cons("word")}
    "/" ModuleId            -> ModuleId  {cons("slash-word")}
    ModuleWord "/" ModuleId -> ModuleId  {cons("word-slash-word")}
         
  context-free syntax
    list:Module* -> Definition

    "module" ModuleName list:ImpSection* Sections -> Module  {cons("module")}

    "exports" Grammar            -> Section  {cons("exports")}
    "hiddens" Grammar            -> Section  {cons("hiddens")}

    list:Section*                -> Sections

    ModuleId                        -> ModuleName  {cons("unparameterized")}
    ModuleId "[" params:Symbols "]" -> ModuleName  {cons("parameterized")}

    "id" "(" ModuleName ")" -> Attribute  {cons("id")}

    "imports" list:Imports -> ImpSection  {cons("imports")}

    ImpSection -> Grammar  {cons("imp-section")}

    list:Import* -> Imports

    ModuleName            -> Import  {cons("module")}
    ModuleName Renamings  -> Import  {cons("renamed-module")}
    "(" Import ")"        -> Import  {bracket}

  lexical restrictions
    ModuleWord -/- [A-Za-z0-9\_\-]
    ModuleId -/- [\/]

module languages/sdf2/syntax/Basic

imports languages/sdf2/syntax/Kernel

exports
  context-free syntax
    "lexical" "syntax"      Productions -> Grammar  {cons("lexical-syntax")}
    "context-free" "syntax" Productions -> Grammar  {cons("context-free-syntax")}
    "variables"             Productions -> Grammar  {cons("variables")}
    "lexical" "variables"   Productions -> Grammar  {cons("lexical-variables")}

    "<" Symbol "-CF"  ">"               -> Symbol  {cons("cf")}
    "<" Symbol "-LEX" ">"               -> Symbol  {cons("lex")}
    "<" Symbol "-VAR" ">"               -> Symbol  {cons("varsym")}

    "LAYOUT"                            -> Symbol  {cons("layout")}

module languages/sdf2/syntax/Grammars

imports basic/Comments

exports
  sorts Grammar
  context-free syntax    
    "(/)"                          -> Grammar  {cons("empty-grammar")}
    "left":Grammar "right":Grammar -> Grammar  {assoc,cons("conc-grammars")}
    "(" Grammar ")"                -> Grammar  {bracket}

module basic/Comments

imports
  basic/Whitespace

exports
  lexical syntax
    "%%" ~[\n]* "\n"	-> LAYOUT
    "%" ~[\%\n]+ "%"	-> LAYOUT
  context-free restrictions
    LAYOUT? -/- [\%]

module languages/sdf2/syntax/Symbols

imports basic/Comments

exports
  sorts Symbol Symbols

  context-free syntax
    "(" Symbol ")" -> Symbol {bracket}

    list:Symbol* -> Symbols



module languages/aterm/syntax/RealCon

imports languages/aterm/syntax/IntCon

hiddens
  context-free start-symbols 
    RealCon

exports
  sorts OptExp RealCon

  context-free syntax
    "e" IntCon -> OptExp {cons("present")}
               -> OptExp {cons("absent")}

    IntCon "." NatCon OptExp  -> RealCon {cons("real-con")}

module languages/aterm/syntax/IntCon

imports basic/Whitespace

hiddens
  context-free start-symbols 
    IntCon

exports

  sorts NatCon IntCon
  lexical syntax   
    [0-9]+ -> NatCon  {cons("digits")}
  context-free syntax
    NatCon         -> IntCon {cons("natural")}
    pos:"+" NatCon -> IntCon {cons("positive")}
    neg:"-" NatCon -> IntCon {cons("negative")}

module basic/Whitespace

exports
  lexical syntax
    [\ \t\n\r]	-> LAYOUT
  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]

module languages/aterm/syntax/Literals

imports basic/Whitespace

hiddens
  sorts AlphaNumericalEscChar DecimalEscChar EscChar L-Char
  context-free start-symbols
    Literal

exports
  sorts QLiteral
  lexical syntax
    "\\" ~[012]                    -> AlphaNumericalEscChar {cons("default")}

    "\\" [01] [0-9] [0-9]          -> DecimalEscChar {cons("dec0_199")}
    "\\" "2" [0-4] [0-9]           -> DecimalEscChar {cons("dec200_249")}
    "\\" "2" "5" [0-5]             -> DecimalEscChar {cons("dec250_255")}

    alpha:AlphaNumericalEscChar  -> EscChar {cons("alpha-numeric")}
    decimal:DecimalEscChar       -> EscChar {cons("decimal")}

    ~[\000-\031\"\\] \/ [\t\n\r] -> L-Char {cons("normal")}
    EscChar                      -> L-Char {cons("escaped")}

    "\"" chars:L-Char* "\""        -> QLiteral {cons("quoted")}

  sorts UQLiteral
  lexical syntax
    [a-z]                          -> UQLiteral {cons("one-char")}
    [a-z][A-Za-z0-9\-]*[A-Za-z0-9] -> UQLiteral {cons("more-chars")}

  sorts Literal
  context-free syntax
    QLiteral  -> Literal {cons("qlit")}
    UQLiteral -> Literal {cons("uqlit")}

  lexical restrictions
    UQLiteral -/- [A-Za-z0-9]

module languages/aterm/syntax/ATerms

imports languages/aterm/syntax/Literals 
        languages/aterm/syntax/IntCon 
        languages/aterm/syntax/RealCon

hiddens
  context-free start-symbols 
    ATerm

exports
  sorts ATermList ACon AFun ATerm Ann

  context-free syntax
    "[" elems:{ ATerm ","}* "]"             -> ATermList {cons("not-empty")}
    IntCon                                  -> ACon      {cons("int")}
    RealCon                                 -> ACon      {cons("real")}
    Literal                                 -> AFun
    ACon                                    -> ATerm     {cons("constant")}
    list:ATermList                          -> ATerm     {cons("list")}
    fun:AFun                                -> ATerm     {cons("fun")}
    fun:AFun "(" args:{ ATerm ","}+ ")"     -> ATerm     {cons("appl")}
    "<" type:ATerm ">"                      -> ATerm {cons("placeholder")}
    "{" annos:{ ATerm ","}+ "}"             -> Ann       {cons("annotation")}
    ACon Ann                                -> ATerm     {cons("annotated-constant")}
    list:ATermList Ann                      -> ATerm     {cons("annotated-list")}
    fun:AFun Ann                            -> ATerm     {cons("annotated-fun")}
    fun:AFun "(" args:{ ATerm ","}+ ")" Ann -> ATerm {cons("annotated-appl")}
    "<" type:ATerm ">" Ann                  -> ATerm {cons("annotated-placeholder")}

module languages/sdf2/syntax/Kernel

imports languages/aterm/syntax/ATerms 
        languages/sdf2/syntax/Symbols 
        languages/sdf2/syntax/Grammars

exports
  sorts Attribute Attributes Production Productions
  context-free syntax
    aterm:ATerm -> Attribute  {cons("term"),avoid}

    "{" list:{Attribute ","}* "}" -> Attributes  {cons("attrs")}
                                  -> Attributes  {cons("no-attrs")}

    Symbols "->" result:Symbol Attributes -> Production  {cons("prod")}

    list:Production* -> Productions

    "syntax" Productions -> Grammar {cons("syntax")}

module languages/sdf2/syntax/Sdf2-Syntax

imports languages/sdf2/syntax/Kernel
        languages/sdf2/syntax/Basic
        languages/sdf2/syntax/Modules
        languages/sdf2/syntax/Regular
        languages/sdf2/syntax/Lifting
        languages/sdf2/syntax/Priority
        languages/sdf2/syntax/CC
        languages/sdf2/syntax/Sorts
        languages/sdf2/syntax/Start-Symbols
        languages/sdf2/syntax/Literals
        languages/sdf2/syntax/Labels
        languages/sdf2/syntax/Restrictions
        languages/sdf2/syntax/Aliases

exports
  sorts SDF

  context-free syntax
    "<START>" -> Symbol {cons("start")}
    "<Start>" -> Symbol {cons("file-start")}

    "lexical"      "priorities" Priorities      -> Grammar {cons("lexical-priorities")}
    "context-free" "priorities" Priorities      -> Grammar {cons("context-free-priorities")}
    "lexical"      "restrictions" Restrictions  -> Grammar {cons("lexical-restrictions")}
    "context-free" "restrictions" Restrictions  -> Grammar {cons("context-free-restrictions")}

    "definition" Definition -> SDF {cons("definition")}

  context-free priorities
    Symbol "|" Symbol  -> Symbol >
    Literal ":" Symbol -> Symbol                  


module languages/sdf2/syntax/Sdf2

imports languages/sdf2/syntax/Sdf2-Syntax

exports
  lexical syntax
    "LAYOUT"            -> Sort    {reject}

  context-free syntax
    "aliases"           -> UQLiteral {reject}
    "lexical"           -> UQLiteral {reject}
    "priorities"        -> UQLiteral {reject}
    "context-free"      -> UQLiteral {reject}
    "definition"        -> UQLiteral {reject}
    "syntax"            -> UQLiteral {reject}
    "variables"         -> UQLiteral {reject}
    "module"            -> UQLiteral {reject}
    "imports"           -> UQLiteral {reject}
    "exports"           -> UQLiteral {reject}
    "hiddens"           -> UQLiteral {reject}
    "left"              -> UQLiteral {reject}
    "right"             -> UQLiteral {reject}
    "assoc"             -> UQLiteral {reject}
    "non-assoc"         -> UQLiteral {reject}
    "bracket"           -> UQLiteral {reject}
    "sorts"             -> UQLiteral {reject}
    "restrictions"      -> UQLiteral {reject}

    "aliases"           -> ModuleName {reject}
    "lexical"           -> ModuleName {reject}
    "priorities"        -> ModuleName {reject}
    "context-free"      -> ModuleName {reject}
    "definition"        -> ModuleName {reject}
    "syntax"            -> ModuleName {reject}
    "variables"         -> ModuleName {reject}
    "module"            -> ModuleName {reject}
    "imports"           -> ModuleName {reject}
    "exports"           -> ModuleName {reject}
    "hiddens"           -> ModuleName {reject}
    "left"              -> ModuleName {reject}
    "right"             -> ModuleName {reject}
    "assoc"             -> ModuleName {reject}
    "non-assoc"         -> ModuleName {reject}
    "bracket"           -> ModuleName {reject}
    "sorts"             -> ModuleName {reject}
    "bracket"           -> ModuleName {reject}
    "sorts"             -> ModuleName {reject}
    "restrictions"      -> ModuleName {reject}

    Literal "(" {Symbol ","}* ")" -> Symbols {reject}

  restrictions
    <Sort -CF>
    <UQLiteral -CF>
    "aliases"
    "lexical"
    "priorities"
    "context-free"
    "definition"
    "syntax"
    "variables"
    "module"
    "imports"
    "exports"
    "hiddens"
    "left"
    "right"
    "assoc"
    "non-assoc"
    "bracket"
    "sorts"             -/- [A-Za-z0-9]
    <NatCon -CF>        -/- [0-9]
    <LAYOUT?-CF>        -/- [\ \t\n\%]
    <NumChar -CF>       -/- [0-9]
    <ModuleName -CF>    -/- [A-Za-z0-9\_\-]


hiddens
  context-free start-symbols
    SDF Module

module Stratego-Sdf2
imports languages/sdf2/syntax/Sdf2 StrategoRenamed
hiddens
  context-free start-symbols StrategoModule

%% The definition of Sdf2 in Stratego tries to stay as close to the ASF+SDF 
%% specification of SDF2 in "Syntax Definition for Language Prototyping" by 
%% Eelco Visser.
exports
  context-free syntax

        "|[" SDF "]|" -> StrategoTerm {cons("ToTerm")}
    "d" "|[" SDF "]|" -> StrategoTerm {cons("ToTerm")}

        "|[" Module "]|" -> StrategoTerm {cons("ToTerm")}
    "m" "|[" Module "]|" -> StrategoTerm {cons("ToTerm")}
    "M" "|[" ModuleName "]|" -> StrategoTerm {cons("ToTerm")}

    "i" "|[" Import "]|" -> StrategoTerm {cons("ToTerm")}

        "|[" Section  "]|" -> StrategoTerm {cons("ToTerm")}
    "s" "|[" Section  "]|" -> StrategoTerm {cons("ToTerm")}

        "|[" Grammar  "]|" -> StrategoTerm {cons("ToTerm")}
    "G" "|[" Grammar  "]|" -> StrategoTerm {cons("ToTerm")}

    "is" "|[" ImpSection "]|" -> StrategoTerm {cons("ToTerm")}

        "|[" Attributes "]|" -> StrategoTerm {cons("ToTerm")}
    "$" "|[" Attributes "]|" -> StrategoTerm {cons("ToTerm")}

        "|[" Production  "]|" -> StrategoTerm {cons("ToTerm"), prefer}
    "p" "|[" Production  "]|" -> StrategoTerm {cons("ToTerm")}

         "|[" Productions "]|" -> StrategoTerm {cons("ToTerm")}
    "p*" "|[" Productions "]|" -> StrategoTerm {cons("ToTerm")}

        "|[" Symbol      "]|" -> StrategoTerm {cons("ToTerm")}
    "A" "|[" Symbol      "]|" -> StrategoTerm {cons("ToTerm")}

         "|[" Renaming "]|" -> StrategoTerm {cons("ToTerm")}
    "ro" "|[" Renaming "]|" -> StrategoTerm {cons("ToTerm")}

         "|[" Alias "]|" -> StrategoTerm {cons("ToTerm")}
    "al" "|[" Alias "]|" -> StrategoTerm {cons("ToTerm")}

    "~"     StrategoTerm   -> Symbol {cons("FromTerm")}
    "~sym:" StrategoTerm   -> Symbol {cons("FromTerm")}

  variables %% section 7.1 (unfortunately no Unicode support in SDF ;) )

    [ABC][0-9\']*      -> Symbol
    [ABC][0-9\']* "*"  -> Symbol*
    [ABC][0-9\']* "+"  -> Symbol+

  variables %% section 7.2

    "G" [0-9\']* -> Grammar

  variables %% section 7.3.1

    "attr" [0-9\']*     -> Attribute
    "attr" [0-9\']* "*" -> {Attribute ","}*
    "attr" [0-9\']* "+" -> {Attribute ","}+
    "$" [0-9\']*        -> Attributes

    "p" [0-9\']*     -> Production
    "p" [0-9\']* "*" -> Production*
    "p" [0-9\']* "+" -> Production+

  variables %% section 7.4.1

    "S" [0-9\']* -> Sort {prefer}

  variables %% section

    "L" -> Literal

  variables %% section 8.1.1

    "g" [0-9\']*      -> Group
    "gg" [0-9\']* "*" -> {Group ">"}*
    "gg" [0-9\']* "+" -> {Group ">"}+

    "pr" [0-9\']*     -> Priority
    "pr" [0-9\']* "*" -> {Priority ","}*
    "pr" [0-9\']* "+" -> {Priority ","}+

    "as" [0-9\']*     -> Associativity

  variables %% section 8.4.1

    "restr" [0-9\']*     -> Restriction
    "restr" [0-9\']* "*" -> Restriction*
    "restr" [0-9\']* "+" -> Restriction+

  variables %% section 9.1.1

    "ro" [0-9\']*     -> Renaming
    "ro" [0-9\']* "*" -> Renaming*
    "ro" [0-9\']* "+" -> Renaming+

  variables %% section 9.2.1

    "al" [0-9\']*     -> Alias
    "al" [0-9\']* "*" -> Alias*
    "al" [0-9\']* "+" -> Alias+

  variables %% section 9.3.1

    "Mid" [0-9\']* -> ModuleId
    "M"   [0-9\']* -> ModuleName
    
    "s" [0-9\']*     -> Section
    "s" [0-9\']* "*" -> Section*
    "s" [0-9\']* "+" -> Section+

    "m" [0-9\']*     -> Module
    "m" [0-9\']* "*" -> Module*
    "m" [0-9\']* "+" -> Module+

    "d" [0-9\']*     -> Definition

    "i" [0-9\']*     -> Import
    "i" [0-9\']* "*" -> Import*
    "i" [0-9\']* "+" -> Import+

    "is" [0-9\']*     -> ImpSection
    "is" [0-9\']* "*" -> ImpSection*

