/**
 * pack-sdf creates an SDF definition file containing all modules imported 
 * from the given top module.
 *
 * pack-sdf is an instantiation of pack-modules implemented with graph-nodes. 	
 *
 * @authors    Merijn de Jonge <mdejonge@cwi.nl>
 *             Eelco Visser <visser@acm.org>
 *             Joost Visser <jvisser@cwi.nl>
 *             Martin Bravenboer <martin@cs.uu.nl>
 */
module pack-sdf
imports pack-sdf-options
imports xtc-lib lib strategoxt-xtc-tools sdf-xtc-tools 
imports Sdf2
imports asfix-abstractions pack-modules 

/**
 * Entry point
 */
strategies

  main-pack-sdf =
    xtc-io-wrap(pack-sdf-options,
      process-options
    ; pack-sdf(|<include-path>) => (files, spec)
    ; <maybe-create-depfile> files
    ; <write-to> spec
    ; (  where(of-config => "txt")   < xtc-asfix-yield
      +  where(of-config => "ast")   < xtc-implode-asfix
      +  where(of-config => "asfix")
         <+ <fatal-error> ["pack-sdf: ", <id>, " is not a valid output format."]
      )
    )

/**
 * Main strategy
 */
strategies

  pack-sdf(|mkpt) =
      ?FILE(<id>)
    ; !(<id>, mkpt, [])
    ; graph-nodes-undef(parse-sdf', get-sdf-imports, \ (n,x,xs) -> [x|xs] \ )
    ; (id, map(<fatal-error> ["pack-sdf: Error: module ", <id>, " not found\n"]); [])
    ; Fst
    ; unzip
    ; (id, ConcatModules)

  /**
   * @type  (String, List(IncludeVal)) -> (String, AsFix(Module))
   */
  parse-sdf' =
      (guarantee-extension(!"sdf"); remove-extension, id)
    ; ?(mod, includes)
    ; <fetch-elem(
         include-from-dir(|mod)
       + include-from-def(|mod)
       + include-from-xtc(|mod)
       )> includes

  include-from-dir(|mod) :
    IncludeDir(dir) -> (file, tree)
      where <concat-strings; file-exists> [dir,"/", mod, ".sdf"] => file
          ; if-verbose1(debug(!"  including "))
          ; ( <parse-sdf2-module-to-asfix> file => tree
            <+ <fatal-error> ["pack-sdf: Error: module ", <id>, " cannot be parsed\n"])

  include-from-xtc(|mod) :
    IncludeXTC() -> (file, tree)
      where <conc-strings; xtc-find-loc> (mod, ".sdf") => file
          ; if-verbose1(say(<concat-strings> ["  including ", mod, " from XTC repository"]))
          ; <parse-sdf2-module-to-asfix> file => tree

  include-from-def(|mod) :
    IncludeDef(file, mods) -> (file, Module_START(NewLine(), tree, NewLine()))
      where <fetch-elem(?(mod, <id>))> mods => tree
          ; if-verbose1(say(<concat-strings> ["  including ", mod, " from ", file]))

  parse-sdf2-module-to-asfix = 
      <xtc-sglr(!"Sdf2.baf", !"Module")> FILE(<id>)
    ; read-from
    ; ?parsetree(<id>, _)

strategies

  get-sdf-imports = 
    collect(
        ?appl(prod(_,cf(sort("Import")),_),_)
      ; get-module-name
    , skip-non-imports
    )

  skip-non-imports(search, ignore) =  
    parsetree(search,id)
    //<+ appl(prod(id, cf(sort("Module")),id),[id,id,id,search,id,search])
    <+ appl(prod(id, cf(opt(layout) <+ 
                        sort("Productions" <+ "Symbols" <+ 
                             "Priorities" <+ "Restrictions" <+
                             "Aliases")), id); ignore, ignore)
    <+ appl(ignore,search)

strategies

  /**
   * Obtain module name from Import construct by removing optional parameters
   */
  get-module-name =
      oncetd(?appl(prod(_,cf(sort("ModuleId")),_),_); yield => y)
    ; !y

  module-to-module-name = 
    ?appl(prod(_, cf(sort("Module")), _), [_, _, mid | _])
    ; <get-module-name> mid

  /**
   * Composing AsFix; The parser produces an AsFix term for each module. These
   * have to be merged into a list of modules. This entails merging the layout
   * at the end and start of subsequent trees. Note that the prefer longets
   * match of laout is not considered here. This means that the layout nodes may not be
   * equavalent to the layout nodes when parsing the resulting definition file:
   *  
   * parse( unparse(pack(m))) != pack(m) 
   *
   */
  ConcatModules =
   rec x(
   {w1, w2, m, m1, m2, xs:
      []; 
      !(NoCfLayout, EmptyModuleIterStar, NoCfLayout)
   <+ 
      [id];
      ?[Module_START(w1, m, w2)]; 
      !(NoCfLayout, M-iter(m), NoCfLayout)
   <+
      ?[m1,m2|xs];
      <concat-modules>( <x>[m1], <x>[m2|xs])
   }) => (w1, modules, w2);
   !parsetree(SDF_START(NoCfLayout, 
      Definition-overlay(
         <concat-layout>[OptNewLine, w1], 
         Module-s-overlay(NonEmptyModuleIterStar(modules))),w2),0)


  concat-modules =
    ?( (w1, m1, w2), (w3, m2, w4) );
    !(w1, MM-iter( 
            m1, 
            <concat-layout>[w2, OptNewLine, OptNewLine, w3], 
            m2), w4)

signature
  constructors
    'id: Arg -> ID

/**
 * Overlays for SDF constructs
 */
overlays 

  /**
   * Module -> <START>
   */
  Module_START(w1, t, w2) =
    appl(
      prod(
        [ cf(opt(layout()))
        , cf(sort("Module"))
        , cf(opt(layout()))
        ]
      , sort("<START>")
      , no-attrs()
      )
    , [ w1, t, w2]
    )

  /**
   * SDF -> <START>
   */
  SDF_START(w1, t, w2) =
    appl(
      prod(
        [ cf(opt(layout()))
        , cf(sort("SDF"))
        , cf(opt(layout()))
        ]
      , sort("<START>")
      , no-attrs()
      )
    , [w1, t, w2]
    )

  /**
   *   -> M*
   */
  EmptyModuleIterStar =
    appl(prod([],cf(iter-star(sort("Module"))),no-attrs),[])

  /**
   * M+ -> M*
   */
  NonEmptyModuleIterStar(m) = 
    appl(prod([cf(iter(sort("Module")))],cf(iter-star(sort("Module"))),no-attrs),[m])

  /**
   * M+ M+ -> M+ {left}
   */
  MM-iter(m1, w, m2) =
    appl(prod([cf(iter(sort("Module"))),cf(opt(layout)),cf(iter(sort("Module")))],
     cf(iter(sort("Module"))),attrs([assoc(left())])),[m1, w, m2])

  /**
   * M -> M+
   */
  M-iter( m ) = 
    appl(prod([cf(sort("Module"))],cf(iter(sort("Module"))),no-attrs),[m])

  /**
   *  Module* -> Definition
   */
  Module-s-overlay ( g_6 ) =
    appl ( prod ( [ cf ( iter-star ( sort ( "Module" ) ) ) ] , cf ( sort ( "Definition" ) ) , no-attrs  ) , [ g_6 ] )

  /**
   * definition Definition -> SDF
   */
  Definition-overlay(b_1,c_1) = 
  appl(prod([lit("definition"),cf(opt(layout())),cf(sort("Definition"))],cf(sort("SDF")),
         attrs([term(cons("definition"))])),[appl(prod([
    char-class([100]),
    char-class([101]),
    char-class([102]),
    char-class([105]),
    char-class([110]),
    char-class([105]),
    char-class([116]),
    char-class([105]),
    char-class([111]),
    char-class([110])],lit("definition"),no-attrs()),[100,101,102,105,110,105,116,105,111,110]),b_1,c_1])

