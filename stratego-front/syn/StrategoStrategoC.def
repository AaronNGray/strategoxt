definition
module AbstractDeclarators
exports
  context-free syntax
    "*" TypeQualifier* -> Pointer     {cons("PointerOf")}
    Pointer+           -> Pointers
    Pointer*           -> PointersOpt

  context-free syntax
    UnaryAbstractDeclarator      -> AbstractDeclarator
    PostfixAbstractDeclarator    -> AbstractDeclarator
    PostfixingAbstractDeclarator -> AbstractDeclarator

  context-free syntax
    Pointers ( PostfixAbstractDeclarator | PostfixingAbstractDeclarator )? -> UnaryAbstractDeclarator {cons("Pointer")}

  context-free syntax
    ArrayAbstractDeclarator                       -> PostfixingAbstractDeclarator
    "(" {ParameterDeclaration ","}+ "," "..." ")" -> PostfixingAbstractDeclarator {cons("ParamListVarArgs")}
    "(" {ParameterDeclaration ","}* ")"           -> PostfixingAbstractDeclarator {cons("ParamList")}

  context-free syntax
    ArrayAbstractDeclarator? "[" ConstantExpression? "]" -> ArrayAbstractDeclarator {cons("ArrayDecl")}

  context-free syntax
    "(" UnaryAbstractDeclarator ")"                              -> PostfixAbstractDeclarator {cons("DeclBracket")}
    "(" PostfixAbstractDeclarator ")"                            -> PostfixAbstractDeclarator {cons("DeclBracket")}
    "(" PostfixingAbstractDeclarator ")"                         -> PostfixAbstractDeclarator {cons("DeclBracket")}
    "(" UnaryAbstractDeclarator ")" PostfixingAbstractDeclarator -> PostfixAbstractDeclarator {cons("FunType")}

module ParameterDeclarators
exports
  context-free syntax
    ( DeclarationQualifierList | TypeQualifiers | DeclarationSpecifier | TypeSpecifier ) 
    ( AbstractDeclarator | IdentifierDeclarator ) -> ParameterDeclaration {cons("ParamDecl")}

    ( DeclarationQualifierList | TypeQualifiers | DeclarationSpecifier | TypeSpecifier ) 
     -> ParameterDeclaration

    ( DeclarationSpecifier | TypeSpecifier ) 
    TypedefDeclarator -> ParameterDeclaration {cons("ParamDeclTD")}

  context-free syntax
    ( TypeSpecifier | TypeQualifiers ) AbstractDeclarator? -> TypeName {cons("TypeName")}

module Enumerators
exports
  context-free syntax
    "enum" IdentifierOrTypedefName? "{" {Enumerator ","}+ "}" -> EnumSpecifier {cons("Enum")}
    "enum" IdentifierOrTypedefName                            -> EnumSpecifier {cons("EnumId")}

  context-free syntax
    IdentifierOrTypedefName EnumeratorValue? -> Enumerator {cons("Enumerator")}

  context-free syntax
    "=" ConstantExpression -> EnumeratorValue {cons("EnumVal")}

module StructsAndUnions
exports
  context-free syntax
    StructSpecifier -> ElaboratedTypeName
    UnionSpecifier  -> ElaboratedTypeName
    EnumSpecifier   -> ElaboratedTypeName

  context-free syntax
    "struct" IdentifierOrTypedefName? "{" MemberDeclaration+ "}" -> StructSpecifier {cons("Struct")}
    "struct" IdentifierOrTypedefName                             -> StructSpecifier {cons("StructId")}

  context-free syntax
    "union" IdentifierOrTypedefName? "{" MemberDeclaration+ "}" -> UnionSpecifier {cons("Union")}
    "union" IdentifierOrTypedefName                             -> UnionSpecifier {cons("UnionId")}

  context-free syntax
    TypeSpecifier {MemberDeclarator ","}+ ";"            -> MemberDeclaration {cons("MemDecl")}
    TypeQualifier+ {MemberIdentifierDeclarator ","}+ ";" -> MemberDeclaration {cons("MemDecl")}

  context-free syntax
    Declarator                         -> MemberDeclarator
    Declarator? ":" ConstantExpression -> MemberDeclarator {cons("BitFieldSize")}

module Expressions
exports
  context-free syntax
    INTEGERconstant   -> Constant {cons("IntConst")}
    FLOATINGconstant  -> Constant {cons("FloatConst")}
    OCTALconstant     -> Constant {cons("OctConst")}
    HEXconstant       -> Constant {cons("HexConst")}
    CHARACTERconstant -> Constant {cons("CharConst")}

  context-free syntax
    STRINGliteral+ -> StringLiteralList {cons("StringLit")}

  context-free syntax
    IDENTIFIER              -> PrimaryExpression
    Constant                -> PrimaryExpression
    StringLiteralList       -> PrimaryExpression
    "(" CommaExpression ")" -> PrimaryExpression {bracket}
 
  context-free syntax
    PrimaryExpression                                -> PostfixExpression
    PostfixExpression "[" CommaExpression "]"        -> PostfixExpression {cons("ArrayIndex")}
    PostfixExpression "(" {AssignmentExpression ","}* ")" -> PostfixExpression {cons("FunCall")}
    PostfixExpression "." MemberName                 -> PostfixExpression {cons("Field")}
    PostfixExpression "->" MemberName                -> PostfixExpression {cons("DerefMember")}
    PostfixExpression "++"                           -> PostfixExpression {cons("PostIncr")}
    PostfixExpression "--"                           -> PostfixExpression {cons("PostDecr")}

  context-free syntax
    IDENTIFIER  -> MemberName
    TypedefName -> MemberName

  context-free syntax
    PostfixExpression         -> UnaryExpression
    "++" UnaryExpression      -> UnaryExpression {cons("PreIncr")}
    "--" UnaryExpression      -> UnaryExpression {cons("PreDecr")}
    "sizeof" UnaryExpression  -> UnaryExpression {cons("SizeofExp")}
    "sizeof" "(" TypeName ")" -> UnaryExpression {cons("SizeofType")}
    "&" CastExpression        -> UnaryExpression {cons("Address")}
    "*" CastExpression        -> UnaryExpression {cons("Deref")}
    "+" CastExpression        -> UnaryExpression {cons("Positive")}
    "-" CastExpression        -> UnaryExpression {cons("Negative")}
    "~" CastExpression        -> UnaryExpression {cons("Tilde")}
    "!" CastExpression        -> UnaryExpression {cons("Negation")}

  context-free syntax
    UnaryExpression                 -> CastExpression
    "(" TypeName ")" CastExpression -> CastExpression {cons("TypeCast")}

  context-free syntax
    CastExpression                              -> MultiplicativeExpression
    MultiplicativeExpression "*" CastExpression -> MultiplicativeExpression {cons("Mul")}
    MultiplicativeExpression "/" CastExpression -> MultiplicativeExpression {cons("Div")}
    MultiplicativeExpression "%" CastExpression -> MultiplicativeExpression {cons("Mod")}

  context-free syntax
    MultiplicativeExpression                        -> AdditiveExpression
    AdditiveExpression "+" MultiplicativeExpression -> AdditiveExpression {cons("Add")}
    AdditiveExpression "-" MultiplicativeExpression -> AdditiveExpression {cons("Subt")}

  context-free syntax
    AdditiveExpression                      -> ShiftExpression
    ShiftExpression "<<" AdditiveExpression -> ShiftExpression {cons("ShiftLeft")}
    ShiftExpression ">>" AdditiveExpression -> ShiftExpression {cons("ShiftRight")}

  context-free syntax
    ShiftExpression                           -> RelationalExpression
    RelationalExpression "<" ShiftExpression  -> RelationalExpression {cons("Lt")}
    RelationalExpression ">" ShiftExpression  -> RelationalExpression {cons("Gt")}
    RelationalExpression "<=" ShiftExpression -> RelationalExpression {cons("Le")}
    RelationalExpression ">=" ShiftExpression -> RelationalExpression {cons("Ge")}

  context-free syntax
    RelationalExpression                         -> EqualityExpression
    EqualityExpression "==" RelationalExpression -> EqualityExpression {cons("Equal")}
    EqualityExpression "!=" RelationalExpression -> EqualityExpression {cons("NotEqual")}

  context-free syntax
    EqualityExpression                   -> ANDexpression
    EqualityExpression "&" ANDexpression -> ANDexpression {cons("And")}

  context-free syntax
    ANDexpression                           -> ExclusiveORExpression
    ANDexpression "^" ExclusiveORExpression -> ExclusiveORExpression {cons("ExOr")}

  context-free syntax
    ExclusiveORExpression                           -> InclusiveORExpression
    ExclusiveORExpression "|" InclusiveORExpression -> InclusiveORExpression {cons("IncOr")}

  context-free syntax
    InclusiveORExpression                           -> LogicalANDExpression
    LogicalANDExpression "&&" InclusiveORExpression -> LogicalANDExpression {cons("LAnd")}

  context-free syntax
    LogicalANDExpression                          -> LogicalORExpression
    LogicalORExpression "||" LogicalANDExpression -> LogicalORExpression {cons("LOr")}

  context-free syntax
    LogicalORExpression                                               -> ConditionalExpression
    LogicalORExpression "?" CommaExpression ":" ConditionalExpression -> ConditionalExpression {cons("IfExp")}

  context-free syntax
    ConditionalExpression                                   -> AssignmentExpression
    UnaryExpression AssignmentOperator AssignmentExpression -> AssignmentExpression {cons("Assign")}

  context-free syntax
    "="   -> AssignmentOperator {cons("AssignEq")}
    "*="  -> AssignmentOperator {cons("AssignMul")}
    "/="  -> AssignmentOperator {cons("AssignDiv")}
    "%="  -> AssignmentOperator {cons("AssignMod")}
    "+="  -> AssignmentOperator {cons("AssignPlus")}
    "-="  -> AssignmentOperator {cons("AssignMin")}
    "<<=" -> AssignmentOperator {cons("AssignSL")}
    ">>=" -> AssignmentOperator {cons("AssignSR")}
    "&="  -> AssignmentOperator {cons("AssignAnd")}
    "^="  -> AssignmentOperator {cons("AssignExp")}
    "|="  -> AssignmentOperator {cons("AssignOr")}

  context-free syntax
    AssignmentExpression                     -> CommaExpression
    AssignmentExpression "," CommaExpression -> CommaExpression    {cons("Comma")}
                                             -> CommaExpressionOpt {cons("EmptyExp")}
    CommaExpression                          -> CommaExpressionOpt

  context-free syntax
    ConditionalExpression -> ConstantExpression



module Types
exports
  context-free syntax
    "typedef"  -> StorageClass {cons("Typedef")}
    "extern"   -> StorageClass {cons("Extern")}
    "static"   -> StorageClass {cons("Static")}
    "auto"     -> StorageClass {cons("Auto")}
    "register" -> StorageClass {cons("Register")}

  context-free syntax
    "int"      -> BasicTypeName {cons("Int")}
    "char"     -> BasicTypeName {cons("Char")}
    "short"    -> BasicTypeName {cons("Short")}
    "long"     -> BasicTypeName {cons("Long")}
    "float"    -> BasicTypeName {cons("Float")}
    "double"   -> BasicTypeName {cons("Double")}
    "signed"   -> BasicTypeName {cons("Signed")}
    "unsigned" -> BasicTypeName {cons("Unsigned")}
    "void"     -> BasicTypeName {cons("Void")}

  context-free syntax
    "const"    -> TypeQualifier {cons("Const")}
    "volatile" -> TypeQualifier {cons("Volatile")}

  context-free syntax
    ( DeclarationQualifierList | TypeQualifier+ ) {IdDecl ","}* ";" -> Declaration {cons("Declaration")}
    ( DeclarationSpecifier | TypeSpecifier ) {VarDecl ","}* ";"     -> Declaration {cons("Declaration2")}

  context-free syntax
    IdentifierDeclarator                 -> IdDecl
    IdentifierDeclarator "=" Initializer -> IdDecl      {cons("IdDeclInit")}
    Declarator                           -> VarDecl
    Declarator "=" Initializer           -> VarDecl     {cons("DeclInit")}
    "{" {Initializer ","}+ "}"           -> Initializer {cons("ArrayInit")}
    "{" {Initializer ","}+ "," "}"       -> Initializer {cons("ArrayInitIncomplete")}
    AssignmentExpression                 -> Initializer {cons("AssignInit")}

  context-free syntax
    TypeQualifier* 
    ( BasicTypeName | ElaboratedTypeName | TypedefName ) 
    ( TypeQualifier | BasicTypeName )* 				-> TypeSpecifier {cons("TypeSpec")}

  context-free syntax
    StorageClass  -> DeclarationQualifier
    TypeQualifier -> DeclarationQualifier

  context-free syntax
    TypeQualifier* StorageClass DeclarationQualifier* 		-> DeclarationQualifierList {cons("DQualifiers")}

  context-free syntax
    TypeQualifier* StorageClass DeclarationQualifier* 
    ( BasicTypeName | ElaboratedTypeName | TypedefName ) 
    ( DeclarationQualifier | BasicTypeName )* 			-> DeclarationSpecifier {cons("DeclSpec")}

module Identifiers
exports
  lexical syntax
    [a-zA-Z\_] [a-zA-Z\_0-9]* -> ID

  lexical restrictions
    ID -/- [a-zA-Z\_0-9]

  context-free syntax
    ID          -> IDENTIFIER  {cons("Id")}
    ID          -> TypedefName {cons("TypeId"), avoid}
    IDENTIFIER  -> IdentifierOrTypedefName
    TypedefName -> IdentifierOrTypedefName



module Statements
exports
  context-free syntax
    LabeledStatement    -> Statement
    CompoundStatement   -> Statement
    ExpressionStatement -> Statement
    SelectionStatement  -> Statement
    IterationStatement  -> Statement
    JumpStatement       -> Statement

  context-free syntax
    IdentifierOrTypedefName ":" Statement   -> LabeledStatement {cons("Label")}
    "case" ConstantExpression ":" Statement -> LabeledStatement {cons("Case")}
    "default" ":" Statement                 -> LabeledStatement {cons("Default")}

  context-free syntax
    "{" Declaration* Statement* "}" -> CompoundStatement {cons("Compound")}

  context-free syntax
    CommaExpressionOpt ";" -> ExpressionStatement {cons("Stat")}

  context-free syntax
    "if" "(" CommaExpression ")" Statement                  -> SelectionStatement {cons("If")}
    "if" "(" CommaExpression ")" Statement "else" Statement -> SelectionStatement {cons("IfElse")}
    "switch" "(" CommaExpression ")" Statement              -> SelectionStatement {cons("Switch")}

  context-free syntax
    "while" "(" CommaExpression ")" Statement                                                -> IterationStatement {cons("While")}
    "do" Statement "while" "(" CommaExpression ")" ";"                                       -> IterationStatement {cons("DoWhile")}
    "for" "(" CommaExpressionOpt ";" CommaExpressionOpt ";" CommaExpressionOpt ")" Statement -> IterationStatement {cons("For")}

  context-free syntax
    "goto" IdentifierOrTypedefName ";" -> JumpStatement {cons("Goto")}
    "continue" ";"                     -> JumpStatement {cons("Continue")}
    "break" ";"                        -> JumpStatement {cons("Break")}
    "return" CommaExpressionOpt ";"    -> JumpStatement {cons("Return")}
    "exit" CommaExpressionOpt ";"      -> JumpStatement {cons("Exit")}

module Program
exports
  sorts TranslationUnit

  context-free syntax
    ExternalDefinition+ -> TranslationUnit {cons("TranslationUnit")}

  context-free syntax
    FunctionDefinition -> ExternalDefinition
    Declaration        -> ExternalDefinition

  context-free syntax
    ( NoTypeSpecifier | DeclarationSpecifier | TypeSpecifier | DeclarationQualifierList |  TypeQualifiers) 
    ( IdentifierDeclarator | OldFun )
    CompoundStatement -> FunctionDefinition {cons("FunDef")}

    TypeQualifier+ -> TypeQualifiers {cons("TypeQualifiers")}

    OldFunctionDeclarator Declaration* -> OldFun {cons("OldFun")}

  context-free syntax
     -> NoTypeSpecifier {cons("NoTypeSpecifier")}

module Declarators
exports
  context-free syntax
    IdentifierDeclarator -> Declarator
    TypedefDeclarator    -> Declarator

  context-free syntax
    PointersOpt IDENTIFIER PostfixingAbstractDeclarator?                   -> IdentifierDeclarator {cons("IdDecl")}
    PointersOpt "(" IdentifierDeclarator ")" PostfixingAbstractDeclarator? -> IdentifierDeclarator {cons("FunDecl")}

  context-free syntax
    PointersOpt TypedefName PostfixingAbstractDeclarator?               -> TypedefDeclarator {cons("TypedefDeclarator1")}
    PointersOpt "(" TypedefDeclarator ")" PostfixingAbstractDeclarator? -> TypedefDeclarator {cons("TypedefDeclarator2")}

  context-free syntax
    PointersOpt ParenIdentifierDeclarator "(" {IDENTIFIER ","}+ ")"         -> OldFunctionDeclarator     {cons("OldFunction1")}
    PointersOpt "(" OldFunctionDeclarator ")" PostfixingAbstractDeclarator? -> OldFunctionDeclarator     {cons("OldFunction2")}
    IDENTIFIER                                                              -> ParenIdentifierDeclarator
    "(" ParenIdentifierDeclarator ")"                                       -> ParenIdentifierDeclarator {bracket}

module Preprocessor
exports
  lexical syntax
    ~[\ \t\n\/]                           -> TokenChar
    [\/]                                  -> Slash
    Slash                                 -> TokenChar
    TokenChar+                            -> Token
    ( [\ \t] | ( [\\] [\n] ) | Comment )+ -> TokWS
    ( [\ \t] | Comment )*                 -> WS
    {Token TokWS}+                        -> TokenSeq
    ~[\"\ \t\n\>]+                        -> FileName

  lexical restrictions
    Slash    -/- [\*]
    Token    -/- ~[\ \t\n\/]
    TokenSeq -/- ~[\ \t\n]
    WS       -/- [\ \t]

  lexical syntax
    "#" WS "define" WS ID WS ( "(" WS {( ID WS ) ( "," WS )}* ")" WS )? TokenSeq? WS [\n] -> ControlLine

  lexical syntax
    "#" WS "undef" WS ID WS [\n]                                     -> ControlLine
    "#" WS "include" WS "<" FileName ">" WS [\n]                     -> ControlLine
    "#" WS "include" WS "\"" FileName "\"" WS [\n]                   -> ControlLine
    "#" WS "include" WS TokenSeq WS [\n]                             -> ControlLineNot
    "#" WS "line" WS [0-9]+ WS ( "\"" WS FileName WS "\"" )? WS [\n] -> ControlLine
    "#" WS Constant ( "\"" WS FileName WS "\"" )? WS [\n]            -> ControlLine
    "#" WS "error" WS TokenSeq? WS [\n]                              -> ControlLine
    "#" WS "pragma" WS TokenSeq? WS [\n]                             -> ControlLine
    "#" WS "if" WS ConstantExpression WS [\n]                        -> IfLine
    "#" WS "if" WS ID WS [\n]                                        -> IfLine
    "#" WS "if" WS ID WS "!=" WS [0-9]+ WS [\n]                      -> IfLine
    "#" WS "ifdef" WS ID WS [\n]                                     -> IfLine
    "#" WS "ifndef" WS ID WS [\n]                                    -> IfLine
    "#" WS "elif" WS ConstantExpression WS [\n]                      -> ElifLine
    "#" WS "else" WS [\n]                                            -> ElseLine

  context-free syntax
    ControlLine -> ExternalDefinition
    ControlLine -> MemberDeclaration

  context-free syntax
    IfLine ExternalDefinition* 
    ( ElifLine ExternalDefinition* )* 
    ( ElseLine ExternalDefinition* )? 
    "#" "endif" -> ExternalDefinition {cons("PpIf")}

module Lexical
exports
  lexical syntax
    [\ \t\n]                        -> LAYOUT
    "/*" ( ~[\*] | Asterisk )* "*/" -> Comment
    Comment                         -> LAYOUT
    [\*]                            -> Asterisk
    "//" ~[\n]* [\n]                -> Comment

  lexical restrictions
    Asterisk -/- [\/]

  context-free restrictions
    LAYOUT? -/- [\ \t\n]

module Constants
exports
  lexical syntax
    [L]? "\"" StringChar* "\"" -> STRINGliteral
    ~[\\\"\n]                  -> StringChar
    [\\] [ntvbrfa\\\?\"]       -> StringChar
    [\\] [x] [0-9A-E] [0-9A-E] -> StringChar
    Octal                      -> StringChar
    [\\] [0-7] [0-7]? [0-7]?   -> Octal

  lexical syntax
    "." [0-9]+ ( [eE] "-"? [0-9]+ )? [fFlL]?        -> FLOATINGconstant
    [0-9]+ "." [0-9]* ( [eE] "-"? [0-9]+ )? [fFlL]? -> FLOATINGconstant
    [0-9]+ [eE] "-"? [0-9]+ [fFlL]?                 -> FLOATINGconstant
    [0-9]+                                          -> INTEGERconstant
    [L]? "'" Char "'"                               -> CHARACTERconstant
    ~[\\\'\n]                                       -> Char
    [\\] [ntvbrfa\\\?\'\"]                          -> Char
    Octal                                           -> Char
    [\\] [x] [0-9A-E] [0-9A-E]                      -> Char

  lexical syntax
    "0" [xX] [0-9]+ -> HEXconstant

  lexical restrictions
    INTEGERconstant HEXconstant FLOATINGconstant -/- [0-9]

module Keywords
exports
  context-free syntax
    "return" -> RETURN {cons("return")}
    "exit"   -> RETURN {cons("exit")}

  context-free syntax
    "auto"     -> IDENTIFIER {reject}
    "double"   -> IDENTIFIER {reject}
    "int"      -> IDENTIFIER {reject}
    "struct"   -> IDENTIFIER {reject}
    "break"    -> IDENTIFIER {reject}
    "else"     -> IDENTIFIER {reject}
    "long"     -> IDENTIFIER {reject}
    "switch"   -> IDENTIFIER {reject}
    "case"     -> IDENTIFIER {reject}
    "enum"     -> IDENTIFIER {reject}
    "register" -> IDENTIFIER {reject}
    "typedef"  -> IDENTIFIER {reject}
    "char"     -> IDENTIFIER {reject}
    "extern"   -> IDENTIFIER {reject}
    "return"   -> IDENTIFIER {reject}
    "exit"     -> IDENTIFIER {reject}
    "union"    -> IDENTIFIER {reject}
    "const"    -> IDENTIFIER {reject}
    "float"    -> IDENTIFIER {reject}
    "short"    -> IDENTIFIER {reject}
    "unsigned" -> IDENTIFIER {reject}
    "continue" -> IDENTIFIER {reject}
    "for"      -> IDENTIFIER {reject}
    "signed"   -> IDENTIFIER {reject}
    "void"     -> IDENTIFIER {reject}
    "default"  -> IDENTIFIER {reject}
    "goto"     -> IDENTIFIER {reject}
    "sizeof"   -> IDENTIFIER {reject}
    "volatile" -> IDENTIFIER {reject}
    "do"       -> IDENTIFIER {reject}
    "if"       -> IDENTIFIER {reject}
    "static"   -> IDENTIFIER {reject}
    "while"    -> IDENTIFIER {reject}

module C
imports Keywords Constants C-Lexical Preprocessor Declarators Program Statements
        Identifiers Types Expressions StructsAndUnions Enumerators
        ParameterDeclarators AbstractDeclarators



module StrategoRenamed
imports 
  Stratego [
	Id 		=> StrategoId 
	ModName 	=> StrategoModName
	Ws 		=> StrategoWs
	ShortCom 	=> StrategoShortCom
	LongCom 	=> StrategoLongCom
	Asterisk 	=> StrategoAsterisk
	CommChar 	=> StrategoCommChar
	VeryLongCom 	=> StrategoVeryLongCom
	Eof 		=> StrategoEof
	VLCchar 	=> StrategoVLCchar 
	Backslash 	=> StrategoBackslash
	Int 		=> StrategoInt
	Real 		=> StrategoReal
	String 		=> StrategoString
	StrChar 	=> StrategoStrChar	
	Module 		=> StrategoModule
	Script 		=> StrategoScript
	Command 	=> StrategoCommand
	Decl 		=> StrategoDecl
	Def  		=> StrategoDef
	Sdecl 		=> StrategoSdecl 
	Sort 		=> StrategoSort
	Kind 		=> StrategoKind
	Opdecl 		=> StrategoOpdecl
	Type 		=> StrategoType 
	Var 		=> StrategoVar
	Term 		=> StrategoTerm 
	Context 	=> StrategoContext
	RuleDef 	=> StrategoRuleDef
	Rule 		=> StrategoRule 
	StratRule 	=> StrategoStratRule 
	Strategy 	=> StrategoStrategy 
	StrategyAngle 	=> StrategoStrategyAngle 
	StrategyParen 	=> StrategoStrategyParen 
	SVar 		=> StrategoSVar 
	StrategyMid 	=> StrategoStrategyMid
	Mod 		=> StrategoMod
	StrategyDef 	=> StrategoStrategyDef 
	Typedid 	=> StrategoTypedid  
	Overlay 	=> StrategoOverlay
  ]


module Stratego
exports
  lexical syntax
    [a-zA-Z\'\.\-\_] [a-zA-Z0-9\'\.\-\_]* -> Id
    [a-zA-Z\'\.\-\_] [a-zA-Z0-9\'\.\-\_]* "*" -> LId
  lexical restrictions
    Id -/- [a-zA-Z0-9\'\.\-\_\*]
    LId -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "all" 		-> Id {reject}
    "constructors" 	-> Id {reject}
    "fail" 		-> Id {reject}
    "id" 		-> Id {reject}
    "in" 		-> Id {reject}
    "let" 		-> Id {reject}
    "module" 		-> Id {reject}
    "not" 		-> Id {reject}
    "one" 		-> Id {reject}
    "overlays" 		-> Id {reject}
    "override" 		-> Id {reject}
    "prim" 		-> Id {reject}
    "rules" 		-> Id {reject}
    "script" 		-> Id {reject}
    "signature" 	-> Id {reject}
    "some" 		-> Id {reject}
    "sorts" 		-> Id {reject}
    "strategies" 	-> Id {reject}
    "stratego" 		-> Id {reject}
    "test" 		-> Id {reject}
    "thread" 		-> Id {reject}
    "where" 		-> Id {reject}

    

  lexical restrictions
    "all" 		
    "constructors" 	
    "fail" 		
    "id" 		
    "in" 		
    "let" 		
    "module" 		
    "not" 		
    "one" 		
    "overlays" 		
    "override" 		
    "prim" 		
    "rules" 		
    "script" 		
    "signature" 	
    "some" 		
    "sorts" 		
    "strategies" 	
    "stratego" 		
    "test" 		
    "thread" 		
    "where" 	 	-/- [a-zA-Z0-9\'\.\-\_]	

  lexical syntax
    [a-zA-Z\'\.\-\_] [a-zA-Z0-9\'\.\-\_]* -> ModName
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}

  lexical syntax
    [\t\ \n] 		-> Ws
    "//" ~[\n]* [\n] 	-> ShortCom
    "/*" CommChar* "*/" -> LongCom
    "(*" CommChar* "*)" -> LongCom
    "*" 		-> Asterisk
    ~[\*] 		-> CommChar
    Asterisk 		-> CommChar
  lexical restrictions
    Asterisk -/- [\/\)]

  lexical syntax
    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
    "\\begin{code}" 			   -> VeryLongCom
    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
     					   -> Eof
    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
    ~[\\] 				   -> VLCchar
    Backslash 				   -> VLCchar
    [\\] 				   -> Backslash
  lexical restrictions
    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
    Eof -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    VeryLongCom -> LAYOUT
    Ws 		-> LAYOUT
  context-free restrictions
    LAYOUT? -/- [\ \t\n]

  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\n\\] 			-> StrChar
    [\\] [\"tn\\] 		-> StrChar

  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}

    "specification" Decl*	 -> Module {cons("Specification")}

  sorts Script
  context-free syntax
    "stratego" "script" Command* -> Script {cons("Script")}
    Decl 			-> Command {cons("Command")}
    ":dump" String 		-> Command {cons("Dump")}
    ":load" String 		-> Command {cons("Load")}
    ">" Strategy 		-> Command {cons("Eval")}

    %%"<" Strategy ">" Term 	 -> Start {cons("TopApply")}
    %%Strategy 			 -> Start {cons("TopStrategy")}

  context-free syntax
    "imports" ModName* 		-> Decl {cons("Imports")}
    "rules" Def* 		-> Decl {cons("Rules")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    StrategyDef 		-> Def 
    RuleDef 			-> Def 

  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  context-free syntax
    Id 			   	-> Sort {cons("SortNoArgs")}
    Id "(" {Term ","}* ")" 	-> Sort {cons("Sort")}

  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

  context-free syntax
    Id ":" Type 		-> Opdecl {cons("OpDecl")}

  context-free syntax
    Term 			-> Type {cons("ConstType")}
    {Type "*"}+ "->" Type 	-> Type {cons("FunType")}
    "(" Type ")" 		-> Type {bracket}

  context-free syntax
    Id 				-> Var  {cons("Var")}
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    Id				-> ID				
    LId				-> ID

  context-free syntax
    "_" 			 -> Term {cons("Wld")}
    Int 			 -> Term {cons("Int")}
    Real 			 -> Term {cons("Real")}
    String 			 -> Term {cons("Str")}
    "_" Term 			 -> Term {cons("BuildDefault")}
    Var 			 -> Term %% {cons("Inj")}
    Var Context 		 -> Term {cons("Con")}

%%    Var "[" Term "]" "(" Id ")"  -> Term {cons("Con")}

    Id "(" {Term ","}* ")" 	 -> Term {cons("Op")}
    Var "@" Term 		 -> Term {cons("As")}
    "(" {Term ","}* ")" 	 -> Term {cons("Tuple")}
    "<" Strategy ">" Term 	 -> Term {cons("App")}
    "[" {Term ","}* "]" 	 -> Term {cons("List")}
    "[" {Term ","}* "|" Term "]" -> Term {cons("ListTail")}
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
    StrategyAngle		 -> Term {cons("RootApp")}
    Term "{" Term "}"		 -> Term {cons("Anno")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
  > Var "@" Term 		 -> Term {cons("As")}

  context-free syntax
    "[" Term "]" 				-> Context {cons("Con1")}
    "[" Term "]" "(" Id ")" 			-> Context {cons("Con2")}
    "[" Term "where" Strategy "]"  		-> Context {cons("Con3")}
    "[" Term "where" Strategy "]" "(" Id ")" 	-> Context {cons("Con4")}

%%  context-free syntax
%%    Id 			      ":" (Rule | Stratrule) -> RuleDef {cons("RDefNoArgs")}
%%    Id "(" {Typedid ","}* ")" ":" (Rule | Stratrule) -> RuleDef {cons("RDef")}

  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}

  context-free syntax
    Id "::" StratRule 				-> RuleDef {cons("SRDefNoArgs")}
    Id "(" {Typedid ","}* ")" "::" StratRule 	-> RuleDef {cons("SRDef")} 

  context-free syntax
    Term "->" Term 		    		-> Rule {cons("RuleNoCond")}
    Term "->" Term "where" Strategy 		-> Rule {cons("Rule")}

  context-free syntax
    Strategy "-->" Strategy 			-> StratRule {cons("StratRuleNoCond")}
    Strategy "-->" Strategy "where" Strategy 	-> StratRule {cons("StratRule")}

  context-free syntax
    "fail" 				  	-> Strategy {cons("Fail")}
    "id" 				  	-> Strategy {cons("Id")}
 
    %% Abstraction

    Id					  -> SVar {cons("SVar")}

    "let" ( StrategyDef | RuleDef )* 
     "in" Strategy 			  -> Strategy {cons("Let")}
    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}

    %% Match and Build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     Strategy "=>" Term 		  -> Strategy {cons("AM")}

    "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}

    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

    Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
    Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
    Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}

    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not" "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "test" "(" Strategy ")" 		  -> Strategy {cons("Test")}
    "bagof" "(" Strategy ")" 		  -> Strategy {cons("Bagof")}

  context-free priorities
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}
  >
    {"!" Term 				  -> Strategy {cons("Build")}
     "?" Term 				  -> Strategy {cons("Match")}
    }
  > StrategyAngle Term 		          -> Strategy {cons("BA")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
     Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
     Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

     Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
     Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
     Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}

     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

  context-free syntax

    %% Primitives

    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}

    %% Traversal

    Int Strategy 			  -> Strategy {cons("Path")}
    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
    "thread" "(" Strategy ")" 		  -> Strategy {cons("Thread")}

    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    "("  ")" 		  		  -> Strategy {cons("TupleCong")}
    "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

    %% Dynamic rules

    "rules" "(" RuleDef* ")" 		  -> Strategy {cons("DynamicRules")}
    "override" "rules" "(" RuleDef* ")"   -> Strategy {cons("OverrideDynamicRules")}
    "{|" {Id ","}* ":" Strategy "|}" 	  -> Strategy {cons("DynRuleScope")}

  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    Id 					-> Typedid {cons("DefaultVarDec")}
    Id ":" Type 			-> Typedid {cons("VarDec")}

  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module StrategoStratego
imports Stratego StrategoRenamed

exports
  context-free syntax
    "[[" Module      "]]" -> StrategoTerm {cons("ToTerm"),prefer}
    "[[" Decl        "]]" -> StrategoTerm {cons("ToTerm")}
    "[[" Sdecl       "]]" -> StrategoTerm {cons("ToTerm")}

    "[[" Opdecl      "]]" -> StrategoTerm {cons("ToTerm")}
    "[[" Type        "]]" -> StrategoTerm {cons("ToTerm")}


    "[[" Term        "]]"  -> StrategoTerm {cons("ToTerm")}
    "[[" Term        ":" "T" "]]" -> StrategoTerm {cons("ToTerm")}

    "[[" StratRule   "]]" -> StrategoTerm {cons("ToTerm")}
    "[[" Rule        "]]" -> StrategoTerm {cons("ToTerm")}
    "[[" RuleDef     "]]" -> StrategoTerm {cons("ToTerm")}

    "[[" Strategy    "]]"  -> StrategoTerm {cons("ToTerm")}
    "[[" Strategy    ":" "S" "]]" -> StrategoTerm {cons("ToTerm")}
    "[[" StrategyDef "]]"  -> StrategoTerm {cons("ToTerm")}

    "[[" Overlay     ":" "O" "]]" -> StrategoTerm {cons("ToTerm")}

    "~" StrategoTerm      -> Strategy {cons("FromTerm")}

    "<" StrategoStrategy ">" -> StrategoStrategyAngle {bracket}
    %%"((" StrategoStrategy "))" -> StrategoStrategy {bracket,prefer}
    "(" StrategoStrategy ")" -> StrategoStrategy {bracket,prefer}

  variables
    [xyzfglc][0-9\']*    	-> Id       {prefer}
    [xyzfgl][0-9\']*	"*" 	-> {Id ","}* {prefer}
    "xs"[0-9\']*       		-> {Id ","}* {prefer}

    [t][0-9\']* 	  	-> Term     {prefer}
    [t][0-9\']*   	"*"  	-> {Term ","}*     {prefer}
    "ts"[0-9\']*    		-> {Term ","}*     {prefer}  

    [s][0-9\']* 	  	-> Strategy {prefer}
    "ss"[0-9\']*	  	-> {Strategy ","}* {prefer}
    "s"[0-9\']*	 	"*"  	-> {Strategy ","}* {prefer}

    [r][0-9\']* 	  	-> Rule     {prefer}

    "a"[0-9\']*   		-> Typedid        {prefer}
    "a"[0-9\']* 	"*"   	-> {Typedid ","}+ {prefer}
    "as"[0-9\']*  		-> {Typedid ","}+ {prefer} 

  lexical syntax
    "xs"[0-9\']*       		-> Id  {reject}

    [t][0-9\']* 	  	-> Id  {reject}
    "ts"[0-9\']*    		-> Id  {reject}  

    [s][0-9\']* 	  	-> Id  {reject}
    "ss"[0-9\']*	  	-> Id  {reject}

    [r][0-9\']* 	  	-> Id  {reject}
 
    "a"[0-9\']*   		-> Id  {reject}
    "as"[0-9\']*  		-> Id  {reject}

module StrategoStrategoC
imports StrategoStratego C
exports
  context-free syntax
    "[[" Expression "]]" -> StrategoTerm {cons("ToTerm")}