definition
module Stratego-Overlays
imports
  Stratego-Terms
  Stratego-Identifiers

exports
  sorts Overlay
  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module Stratego-Strategies
imports
  Stratego-Terms
  Stratego-Constants
  Stratego-Rules
  Stratego-Modules
  Stratego-Signatures

exports
  sorts StrategyDef

  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}

  sorts Typedid
  context-free syntax
    ID 				  	  -> Typedid {cons("DefaultVarDec")}
    ID ":" Type 			  -> Typedid {cons("VarDec")}

  sorts StrategyParen Strategy SVar StrategyMid StrategyCurly StrategyAngle Mod
  context-free syntax
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "fail" 				  -> Strategy {cons("Fail")}
    "id" 				  -> Strategy {cons("Id")}

    %% Abstraction

    Id					  -> SVar {cons("SVar")}
    "let" Def* "in" Strategy "end"	  -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}
    SVar "(" {Strategy ","}* 
         "|" {Term ","}* ")" 	          -> Strategy {cons("CallT")}


    %% Match and build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}

     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}


    %% Combinators

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
    Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}
    "bagof" "(" Strategy ")" 		  -> Strategy {cons("Bagof")}


    %% Primitives

    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}
    "prim" "(" String "," {Strategy ","}* 
                      "|" {Term ","}*")"  -> Strategy {cons("PrimT")}

    %% Traversal

    Int Strategy 			  -> Strategy {cons("Path")}
    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
    "thread" "(" Strategy ")" 		  -> Strategy {cons("Thread")}

    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}
    Char 			 	  -> Strategy {cons("CharCong")}

    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}

    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
    "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

  %% Syntactic sugar sugar

  context-free syntax

    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
    "(" Rule ")" 			  -> Strategy {cons("SRule")}
    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}
    Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
    Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}
    "if" Strategy "then" Strategy "else" Strategy "end" -> Strategy {cons("CondChoice")}
    "switch" Strategy ("case" Strategy ":" Strategy)* "end" -> Strategy {cons("SwitchChoiceNoOtherwise")}
    "switch" Strategy ("case" Strategy ":" Strategy)*
                       "otherwise" ":" Strategy "end" -> Strategy {cons("SwitchChoice")}

    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}

  %% Priorities

  context-free priorities
    { Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
      Strategy "#" StrategyParen          -> Strategy {cons("ExplodeCong")}
    }
  > { "!" Term 				  -> Strategy {cons("Build")}
      "?" Term 				  -> Strategy {cons("Match")}
    }
  > StrategyAngle Term 		          -> Strategy {cons("BA")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
     Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
     Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

     Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
     Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
     Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}

     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

module Stratego-DynamicRules
imports
  Stratego-Identifiers
  Stratego-Strategies
  Stratego-Rules

exports
  context-free syntax

    "{|" {DynRuleScopeId ","}* ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}

  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
  context-free syntax

    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}

    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}

    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
    RuleDec                     -> DynRuleId {cons("DynRuleId")}

    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}

  context-free syntax

    Id                          -> RuleDec {cons("RDecNoArgs")}
    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}

  context-free syntax

    "/" {Id ","}* "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
    "\\" {Id ","}* "/*" Strategy          -> Strategy {cons("DynRuleUnionFix")}
    Strategy "/" {Id ","}* "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
    Strategy "\\" {Id ","}* "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}

  context-free priorities
    StrategyAngle Term 		          -> Strategy {cons("BA")}
  > {"/" {Id ","}* "\\*" Strategy         -> Strategy {cons("DynRuleIntersectFix")}
     "\\" {Id ","}* "/*" Strategy         -> Strategy {cons("DynRuleUnionFix")}
    }
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy "/" {Id ","}* "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
  > Strategy "\\" {Id ","}* "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}

  context-free syntax %% legacy Dynamic rules

    "override" "rules" "(" RuleDef* ")"		 -> Strategy {cons("OverrideDynamicRules")}
    "extend"   "rules" "(" RuleDef* ")"		 -> Strategy {cons("ExtendDynamicRules")}
    "extend" "override" "rules" "(" RuleDef* ")" -> Strategy {cons("ExtendOverrideDynamicRules")}

module Stratego-Rules
imports Stratego-Strategies
exports

%%  context-free syntax
%%    Id 			      ":" (Rule | Stratrule) -> RuleDef {cons("RDefNoArgs")}
%%    Id "(" {Typedid ","}* ")" ":" (Rule | Stratrule) -> RuleDef {cons("RDef")}

  sorts RuleDef
  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}

  context-free syntax
    Id "::" StratRule 				-> RuleDef {cons("SRDefNoArgs")}
    Id "(" {Typedid ","}* ")" "::" StratRule 	-> RuleDef {cons("SRDef")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}*")" "::" StratRule 	-> RuleDef {cons("SRDefT")}

  sorts Rule
  context-free syntax
    Term "->" Term 		    		-> Rule {cons("RuleNoCond")}
    Term "->" Term "where" Strategy 		-> Rule {cons("Rule")}

  sorts StratRule
  context-free syntax
    Strategy "-->" Strategy 			-> StratRule {cons("StratRuleNoCond")}
    Strategy "-->" Strategy "where" Strategy 	-> StratRule {cons("StratRule")}

module Stratego-Terms
imports
  Stratego-Identifiers
  Stratego-Strategies

exports
  sorts ID LID Var
  context-free syntax
    Id 				-> Var  {cons("Var")}
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    Id				-> ID
    LId				-> ID
    ":" Var                     -> Var  {cons("SeqVar")}

  sorts Term
  context-free syntax
    Int 			 -> Term {cons("Int")}
    Real 			 -> Term {cons("Real")}
    String 			 -> Term {cons("Str")}
    Char 			 -> Term {cons("Char")}
    "_" 			 -> Term {cons("Wld")}
    Var 			 -> Term 
    Id "(" {Term ","}* ")" 	 -> Term {cons("Op")}
    String "(" {Term ","}* ")" 	 -> Term {cons("OpQ")}
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
    Term "{" {Term ","}* "}"	 -> Term {cons("Anno")}

    "<" Strategy ">" Term 	 -> Term {cons("App")}
    StrategyAngle		 -> Term {cons("RootApp")}

    Var "@" Term 		 -> Term {cons("As")}
    "(" {Term ","}* ")" 	 -> Term {cons("Tuple")}
    "[" {Term ","}* "]" 	 -> Term {cons("List")}
    "[" {Term ","}* "|" Term "]" -> Term {cons("ListTail")}
    "_" Term 			 -> Term {cons("BuildDefault")}

    %% Var Context 		 -> Term {cons("Con")}
    %% Var "[" Term "]" "(" Id ")"  -> Term {cons("Con")}

    Var "[" Term "]" 				 -> Term {cons("Con1")}
    Var "[" Term "]" "(" Id ")" 		 -> Term {cons("Con")}
    Var "[" Term "where" Strategy "]"  		 -> Term {cons("Con3")}
    Var "[" Term "where" Strategy "]" "(" Id ")" -> Term {cons("Con4")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
  > Term "{" {Term ","}* "}"	 -> Term {cons("Anno")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Signatures
imports
  Stratego-Identifiers
  Stratego-Constants

exports

  sorts Sdecl
  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  sorts Sort
  context-free syntax
    LCID 			 -> Sort {cons("SortVar")}
    UCID 			 -> Sort {cons("SortNoArgs")}
    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}
    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}

  sorts Kind
  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

  sorts Opdecl
  context-free syntax
    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
           ":" Type 		-> Opdecl {cons("OpDeclInj")}

  sorts Type
  context-free syntax
    Sort			-> Type {cons("ConstType")}
    {Type "*"}+ "->" Type 	-> Type {cons("FunType")}
    "(" Type ")" 		-> Type {bracket}

module Stratego-Modules
imports
  Stratego-Identifiers
  Stratego-Overlays
  Stratego-Strategies
  Stratego-Rules
  Stratego-Signatures

exports 
  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}
    "specification" Decl*	 -> Module {cons("Specification")}

  sorts Decl Def
  context-free syntax
    "imports" ModName* 		-> Decl {cons("Imports")}
    "rules" Def* 		-> Decl {cons("Rules")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    StrategyDef 		-> Def 
    RuleDef 			-> Def 


module Stratego-Constants
imports Stratego-Identifiers
exports
  sorts Int Real String StrChar Char CharChar
  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\\] 			-> StrChar
    [\\] [\"tnr\\] 		-> StrChar
    "\'" CharChar "\'"		-> Char
    ~[\']			-> CharChar
    [\\] [\'ntr\ ]		-> CharChar
    Char		 	-> Id {reject}

module Stratego-Layout
exports
  sorts Ws ShortCom LongCom CommChar1 CommChar2 Asterisk1 Asterisk2
  lexical syntax
    [\t\ \n\r]		 -> Ws

    "//" ~[\n]* ([\n] | Eof) -> ShortCom
    "/*" CommChar1* "*/"  -> LongCom
    "(*" CommChar2* "*)"  -> LongCom

    ~[\*]      -> CommChar1
    ~[\*]      -> CommChar2

    "*"        -> Asterisk1
    "*"        -> Asterisk2
    Asterisk1  -> CommChar1
    Asterisk2  -> CommChar2

  lexical restrictions
    Asterisk1 -/- [\/]
    Asterisk2 -/- [\)]

  sorts VeryLongCom Eof VLCchar Backslash
  lexical syntax
    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
    "\\begin{code}" 			   -> VeryLongCom
    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
     					   -> Eof
    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
    ~[\\] 				   -> VLCchar
    Backslash 				   -> VLCchar
    [\\] 				   -> Backslash

  lexical restrictions
    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
    Eof -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    VeryLongCom -> LAYOUT
    Ws 		-> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]

module Stratego
imports
  Stratego-Layout
  Stratego-Identifiers
  Stratego-Constants 
  Stratego-Modules
  Stratego-Signatures
  Stratego-Terms
  Stratego-Rules
  Stratego-DynamicRules
  Stratego-Strategies
  Stratego-Overlays

hiddens
  context-free start-symbols Module

module StrategoRenamed
imports Stratego
          [ RuleDec        => StrategoRuleDec
            DynRuleScopeId => StrategoDynRuleScopeId
            DynRuleId      => StrategoDynRuleId
            DynRuleDef     => StrategoDynRuleDef
            Def            => StrategoDef
            Decl           => StrategoDecl
            Module         => StrategoModule
            Overlay        => StrategoOverlay
            ID             => StrategoID
            LID            => StrategoLID
            Var            => StrategoVar
            Mod            => StrategoMod
            StrategyCurly  => StrategoStrategyCurly
            StrategyMid    => StrategoStrategyMid
            StrategyAngle  => StrategoStrategyAngle
            SVar           => StrategoSVar
            StrategyParen  => StrategoStrategyParen
            Typedid        => StrategoTypedid
            StrategyDef    => StrategoStrategyDef
            Type           => StrategoType
            Opdecl         => StrategoOpdecl
            Kind           => StrategoKind
            Sort           => StrategoSort
            Sdecl          => StrategoSdecl
            StratRule      => StrategoStratRule
            Rule           => StrategoRule
            RuleDef        => StrategoRuleDef
            CharChar       => StrategoCharChar
            Char           => StrategoChar
            StrChar        => StrategoStrChar
            String         => StrategoString
            Real           => StrategoReal
            Int            => StrategoInt
            UCID           => StrategoUCID
            LCID           => StrategoLCID
            LId            => StrategoLId
            Id             => StrategoId
            ModName        => StrategoModName
            Backslash      => StrategoBackslash
            VLCchar        => StrategoVLCchar
            Eof            => StrategoEof
            VeryLongCom    => StrategoVeryLongCom
            Asterisk2      => StrategoAsterisk2
            Asterisk1      => StrategoAsterisk1
            CommChar2      => StrategoCommChar2
            CommChar1      => StrategoCommChar1
            LongCom        => StrategoLongCom
            ShortCom       => StrategoShortCom
            Ws             => StrategoWs
            Term           => StrategoTerm
            Strategy       => StrategoStrategy ]


module Stratego-Sugar-Overlays
imports
  Stratego-Identifiers
  Stratego-Sugar-Terms

exports
  sorts Overlay
  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module Stratego-DynamicRules
imports
  Stratego-Identifiers
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules

exports
  context-free syntax

    "{|" {DynRuleScopeId ","}* ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}

  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
  context-free syntax

    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}

    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}

    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
    RuleDec                     -> DynRuleId {cons("DynRuleId")}

    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}

  context-free syntax

    Id                          -> RuleDec {cons("RDecNoArgs")}
    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}

  context-free syntax

    "/" {Id ","}* "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
    "\\" {Id ","}* "/*" Strategy          -> Strategy {cons("DynRuleUnionFix")}
    Strategy "/" {Id ","}* "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
    Strategy "\\" {Id ","}* "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}

  context-free priorities
    StrategyAngle Term 		          -> Strategy {cons("BA")}
  > {"/" {Id ","}* "\\*" Strategy         -> Strategy {cons("DynRuleIntersectFix")}
     "\\" {Id ","}* "/*" Strategy         -> Strategy {cons("DynRuleUnionFix")}
    }
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy "/" {Id ","}* "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
  > Strategy "\\" {Id ","}* "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}

  context-free syntax %% legacy Dynamic rules

    "override" "rules" "(" RuleDef* ")"		 -> Strategy {cons("OverrideDynamicRules")}
    "extend"   "rules" "(" RuleDef* ")"		 -> Strategy {cons("ExtendDynamicRules")}
    "extend" "override" "rules" "(" RuleDef* ")" -> Strategy {cons("ExtendOverrideDynamicRules")}

module Stratego-Sugar-Rules
imports Stratego-Sugar-Strategies
exports

%%  context-free syntax
%%    Id 			      ":" (Rule | Stratrule) -> RuleDef {cons("RDefNoArgs")}
%%    Id "(" {Typedid ","}* ")" ":" (Rule | Stratrule) -> RuleDef {cons("RDef")}

  sorts RuleDef
  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}

  context-free syntax
    Id "::" StratRule 				-> RuleDef {cons("SRDefNoArgs")}
    Id "(" {Typedid ","}* ")" "::" StratRule 	-> RuleDef {cons("SRDef")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}*")" "::" StratRule 	-> RuleDef {cons("SRDefT")}

  sorts Rule
  context-free syntax
    Term "->" Term 		    		-> Rule {cons("RuleNoCond")}
    Term "->" Term "where" Strategy 		-> Rule {cons("Rule")}

  sorts StratRule
  context-free syntax
    Strategy "-->" Strategy 			-> StratRule {cons("StratRuleNoCond")}
    Strategy "-->" Strategy "where" Strategy 	-> StratRule {cons("StratRule")}

module Stratego-Sugar-Strategies
imports
  Stratego-Core-Strategies
  Stratego-Sugar-Terms
  Stratego-Sugar-Constants
  Stratego-Sugar-Signatures

exports
  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    ID 				  	  -> Typedid {cons("DefaultVarDec")}

  sorts StrategyParen StrategyCurly StrategyAngle Mod
  context-free syntax

    %% Abstraction

    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}

    %% Match and build

    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}

     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}

    %% Combinators

    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}

    %% Primitives

    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}

    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}
    Char 			 	  -> Strategy {cons("CharCong")}

    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}

    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
    "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

  %% Syntactic sugar sugar

  context-free syntax

    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
    "(" Rule ")" 			  -> Strategy {cons("SRule")}
    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}
    Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
    Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}
    "if" Strategy "then" Strategy "else" Strategy "end" -> Strategy {cons("CondChoice")}
    "switch" Strategy ("case" Strategy ":" Strategy)* "end" -> Strategy {cons("SwitchChoiceNoOtherwise")}
    "switch" Strategy ("case" Strategy ":" Strategy)*
                       "otherwise" ":" Strategy "end" -> Strategy {cons("SwitchChoice")}

    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}

  %% Priorities

  context-free priorities
    { Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
      Strategy "#" StrategyParen          -> Strategy {cons("ExplodeCong")}
    }
  > { "!" Term 				  -> Strategy {cons("Build")}
      "?" Term 				  -> Strategy {cons("Match")}
    }
  > StrategyAngle Term 		          -> Strategy {cons("BA")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
     Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
     Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

     Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
     Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
     Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}

     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

module Stratego-Sugar-Terms
imports
  Stratego-Core-Terms
  Stratego-Sugar-Strategies

exports
  sorts LID
  context-free syntax
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    LId				-> ID

  context-free syntax
    "_" Term 			 -> Term {cons("BuildDefault")}

    Char 			 -> PreTerm {cons("Char")}

    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
    PreTerm                      -> Term {cons("NoAnnoList")}

    "<" Strategy ">" Term 	 -> Term {cons("App")}
    StrategyAngle		 -> Term {cons("RootApp")}

    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}

    Var "[" Term "]" 				 -> Term {cons("Con1")}
    Var "[" Term "]" "(" Id ")" 		 -> Term {cons("Con")}
    Var "[" Term "where" Strategy "]"  		 -> Term {cons("Con3")}
    Var "[" Term "where" Strategy "]" "(" Id ")" -> Term {cons("Con4")}

module Stratego-Sugar-Signatures
imports
  Stratego-Core-Signatures
  Stratego-Sugar-Constants

exports

  sorts Sort
  context-free syntax
    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}

  sorts Kind
  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

module Stratego-Core-Signatures
imports
  Stratego-Identifiers
  Stratego-Core-Constants
exports
  sorts Sdecl
  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  sorts Sort
  context-free syntax
    LCID 			 -> Sort {cons("SortVar")}
    UCID 			 -> Sort {cons("SortNoArgs")}
    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}

  sorts Opdecl
  context-free syntax
    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
           ":" Type 		-> Opdecl {cons("OpDeclInj")}

  sorts Type
  context-free syntax
    Sort			-> Type {cons("ConstType")}
    {Type "*"}+ "->" Type 	-> Type {cons("FunType")}
    "(" Type ")" 		-> Type {bracket}

module Stratego-Core-Terms
imports
  Stratego-Identifiers
  Stratego-Core-Constants

exports
  sorts ID Var
  context-free syntax
    Id 				-> Var  {cons("Var")}
    Id				-> ID
    ":" Var                     -> Var  {cons("SeqVar")}

  sorts Term PreTerm
  context-free syntax
    "_" 			 -> Term {cons("Wld")}
    Var 			 -> Term 
    Var "@" Term 		 -> Term {cons("As")}

    Int 			 -> PreTerm {cons("Int")}
    Real 			 -> PreTerm {cons("Real")}
    String 			 -> PreTerm {cons("Str")}

    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}

    PreTerm "{^" Term "}"	 -> Term {cons("Anno")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("Anno")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Core-Strategies
imports
  Stratego-Core-Terms
  Stratego-Core-Constants
  Stratego-Core-Signatures

exports
  sorts Def
  context-free syntax
    StrategyDef					 -> Def 
    Id						 -> SVar {cons("SVar")}
    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}


  sorts StrategyDef
  context-free syntax
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}


  sorts Typedid
  context-free syntax
    ID ":" Type 			  -> Typedid {cons("VarDec")}


  sorts Strategy SVar StrategyParen StrategyMid 
  context-free syntax
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "fail" 				  -> Strategy {cons("Fail")}
    "id" 				  -> Strategy {cons("Id")}

    %% Match and build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}

    %% Combinators

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
    Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    "bagof" "(" Strategy ")" 		  -> Strategy {cons("Bagof")}

    %% Primitives

    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}

    %% Traversal

    Int Strategy 			  -> Strategy {cons("Path")}
    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
    "thread" "(" Strategy ")" 		  -> Strategy {cons("Thread")}

  %% Priorities

  context-free priorities
    { "!" Term 				  -> Strategy {cons("Build")}
      "?" Term 				  -> Strategy {cons("Match")}
    }
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

module Stratego-Core-Modules
imports
  Stratego-Identifiers
  Stratego-Core-Strategies
  Stratego-Core-Signatures

exports 
  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}
    "specification" Decl*	 -> Module {cons("Specification")}

  sorts Decl 
  context-free syntax
    "imports" ModName* 		-> Decl {cons("Imports")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}

module Stratego-Sugar-Modules
imports
  Stratego-Core-Modules
  Stratego-Sugar-Strategies
  Stratego-Sugar-Signatures
  Stratego-Sugar-Overlays
  Stratego-Sugar-Rules

exports 

  sorts Decl Def
  context-free syntax
    "rules" Def* 		-> Decl {cons("Rules")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    RuleDef 			-> Def 


module Stratego-Core-Constants
exports
  sorts Int Real String StrChar
  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\\] 			-> StrChar
    [\\] [\"tnr\\] 		-> StrChar

module Stratego-Sugar-Constants
imports Stratego-Identifiers Stratego-Core-Constants
exports
  sorts Char CharChar
  lexical syntax
    "\'" CharChar "\'"		-> Char
    ~[\']			-> CharChar
    [\\] [\'ntr\ ]		-> CharChar
    Char		 	-> Id {reject}

module Stratego-Identifiers
exports
  sorts ModName
  lexical syntax
    [a-zA-Z\'\.\-\_] [a-zA-Z0-9\'\.\-\_]* -> ModName
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}

  sorts Id LId LCID UCID
  lexical syntax
    [a-zA-Z\'\-\_] [a-zA-Z0-9\'\-\_]*     -> Id
    [a-zA-Z\'\-\_] [a-zA-Z0-9\'\-\_]* "*" -> LId

    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID
  lexical restrictions
    Id   -/- [a-zA-Z0-9\'\-\_\*]
    LId  -/- [a-zA-Z0-9\'\-\_]
    LCID -/- [a-zA-Z0-9\'\-\_]
    UCID -/- [a-zA-Z0-9\'\-\_]

  lexical syntax
    "all" 		-> Id {reject}
    "constructors" 	-> Id {reject}
    "fail" 		-> Id {reject}
    "id" 		-> Id {reject}
    "in" 		-> Id {reject}
    "let" 		-> Id {reject}
    "module" 		-> Id {reject}
    "not" 		-> Id {reject}
    "one" 		-> Id {reject}
    "overlays" 		-> Id {reject}
    "override" 		-> Id {reject}
    "prim" 		-> Id {reject}
    "rules" 		-> Id {reject}
    "script" 		-> Id {reject}
    "signature" 	-> Id {reject}
    "some" 		-> Id {reject}
    "sorts" 		-> Id {reject}
    "strategies" 	-> Id {reject}
    "stratego" 		-> Id {reject}
    "test" 		-> Id {reject}
    "thread" 		-> Id {reject}
    "where" 		-> Id {reject}
  lexical restrictions
    "all" "constructors" "fail" "id" "in" "let" "module" "not" "one"
    "overlays" "override" "prim" "rules" "script" "signature" "some"
    "sorts" "strategies" "stratego" "test" "thread" "where" 
    -/- [a-zA-Z0-9\'\-\_]

module Stratego-Core-Layout
exports
  sorts Ws ShortCom LongCom CommChar1 CommChar2 Asterisk1 Asterisk2 Eof 
  lexical syntax
    [\t\ \n\r]			-> Ws

    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
    "/*" CommChar1* "*/"	-> LongCom
    "(*" CommChar2* "*)"	-> LongCom
     					 
				-> Eof  

    ~[\*]      -> CommChar1
    ~[\*]      -> CommChar2

    "*"        -> Asterisk1
    "*"        -> Asterisk2
    Asterisk1  -> CommChar1
    Asterisk2  -> CommChar2

  lexical restrictions
    Asterisk1 -/- [\/]
    Asterisk2 -/- [\)]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    Ws 		-> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]

module Stratego-Sugar-Layout
imports Stratego-Core-Layout
exports
  sorts VeryLongCom Eof VLCchar Backslash
  lexical syntax
    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
    "\\begin{code}" 			   -> VeryLongCom
    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
    ~[\\] 				   -> VLCchar
    Backslash 				   -> VLCchar
    [\\] 				   -> Backslash

  lexical restrictions
    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
    Eof -/- ~[]

  lexical syntax
    VeryLongCom -> LAYOUT



module Stratego-Sugar
imports
  Stratego-Sugar-Layout
  Stratego-Identifiers
  Stratego-Sugar-Constants 
  Stratego-Sugar-Modules
  Stratego-Sugar-Signatures
  Stratego-Sugar-Terms
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules
  Stratego-Sugar-DynamicRules
  Stratego-Sugar-Overlays

hiddens
  context-free start-symbols Module

module Stratego-Sugar-in-Stratego
imports Stratego-Sugar StrategoRenamed
hiddens
  context-free start-symbols StrategoModule

exports

  context-free syntax

              "|[" Module "]|" -> StrategoTerm {cons("ToTerm"),prefer}
    "Module"  "|[" Module "]|" -> StrategoTerm {cons("ToTerm")}

              "|[" Decl   "]|" -> StrategoTerm {cons("ToTerm")}
              "|[" Sdecl  "]|" -> StrategoTerm {cons("ToTerm")}

              "|[" Opdecl "]|" -> StrategoTerm {cons("ToTerm")}
    "Constr"  "|[" Opdecl "]|" -> StrategoTerm {cons("ToTerm")}

              "|[" Type   "]|" -> StrategoTerm {cons("ToTerm")}
    "Type"    "|[" Type   "]|" -> StrategoTerm {cons("ToTerm")}

    "Sort"    "|[" Sort   "]|" -> StrategoTerm {cons("ToTerm")}

              "|[" Term   "]|" -> StrategoTerm {cons("ToTerm")}
    "Term"    "|[" Term   "]|" -> StrategoTerm {cons("ToTerm")}

              "|[" Def    "]|" -> StrategoTerm {cons("ToTerm")}
    "Def"     "|[" Def    "]|" -> StrategoTerm {cons("ToTerm")}

             "|[" Rule      "]|" -> StrategoTerm {cons("ToTerm")}
    "Rule"   "|[" Rule      "]|" -> StrategoTerm {cons("ToTerm")}
             "|[" StratRule "]|" -> StrategoTerm {cons("ToTerm")}

               "|[" Strategy "]|" -> StrategoTerm {cons("ToTerm")}
    "Strat"    "|[" Strategy "]|" -> StrategoTerm {cons("ToTerm")}
    "Strategy" "|[" Strategy "]|" -> StrategoTerm {cons("ToTerm")}

    "O"        "|[" Overlay  "]|" -> StrategoTerm {cons("ToTerm")}
    "Overlay"  "|[" Overlay  "]|" -> StrategoTerm {cons("ToTerm")}

    "Typedid" "|[" Typedid   "]|" -> StrategoTerm {cons("ToTerm")}
%%                 "|[" DynRuleDef   "]|" -> StrategoTerm {cons("ToTerm")}
    "DynRuleDef" "|[" DynRuleDef   "]|" -> StrategoTerm {cons("ToTerm")}

  context-free syntax

    %% From Term

    "~"         StrategoTerm -> ModName          {cons("FromTerm")}

    "~"         StrategoTerm -> Term             {cons("FromTerm")}
    "~term:"    StrategoTerm -> Term             {cons("FromTerm")}
    "~term*:"   StrategoTerm -> {Term ","}*      {cons("FromTerm")}
    "~term*:"   StrategoTerm -> {Term ","}+      {cons("FromTerm")}
    "~"         StrategoTerm -> {ID   ","}+      {cons("FromTerm")}

    "~"         StrategoTerm -> Strategy         {cons("FromTerm")}
    "~strat:"   StrategoTerm -> Strategy         {cons("FromTerm")}
    "~*"        StrategoTerm -> {Strategy ","}*  {cons("FromTerm")}
    "~strat*:"  StrategoTerm -> {Strategy ","}*  {cons("FromTerm")}

    "~srt:"     StrategoTerm -> Sort {cons("FromTerm")}
    "~srtvar:"  StrategoTerm -> LCID {cons("FromTerm")}
    "~srtid:"   StrategoTerm -> UCID {cons("FromTerm")}

    "~id:"    StrategoTerm -> Id        {cons("FromTerm")}
    "~int:"   StrategoTerm -> Int       {cons("FromTerm")}
    "~str:"   StrategoTerm -> String    {cons("FromTerm")}

    "~"   StrategoTerm -> Def       {cons("FromTerm")}
    "~*"  StrategoTerm -> Def*      {cons("FromTerm")}

    "~*"  StrategoTerm -> Opdecl*      {cons("FromTerm")}
    "~*"  StrategoTerm -> {Type "*"}+  {cons("FromTerm")}

    "~*"          StrategoTerm -> {Typedid ","}*   {cons("FromTerm")}
    "~typed-id*:" StrategoTerm -> {Typedid ","}*   {cons("FromTerm")}

  context-free syntax 

    %% Hacks

    "<" StrategoStrategy ">" -> StrategoStrategyAngle {bracket}
    "(" StrategoStrategy ")" -> StrategoStrategy {bracket,prefer}

  variables
    [xyzfglc][0-9\']*       -> Id       {prefer}
    [xyzfgl][0-9\']*  "*"   -> {Id ","}* {prefer}
    "xs"[0-9\']*            -> {Id ","}* {prefer}

    [xyzfgl][0-9\']*  "*"   -> {ID ","}* {prefer}

    "pt"[0-9\']*           -> PreTerm     {prefer}

    "t"[0-9\']*           -> Term     {prefer}
    "t"[0-9\']*   "*"     -> {Term ","}*     {prefer}
    "ts"[0-9\']*          -> {Term ","}*     {prefer}  

    "str"[0-9\']*         -> String {prefer}

    "s"[0-9\']*           -> Strategy {prefer}
    "ss"[0-9\']*          -> {Strategy ","}* {prefer}
    "s"[0-9\']*   "*"     -> {Strategy ","}* {prefer}

    "r"[0-9\']*           -> Rule {prefer}

    "rd"[0-9\']*          -> RuleDef {prefer}
    "rd"[0-9\']*  "*"     -> RuleDef* {prefer}

    "a"[0-9\']*           -> Typedid        {prefer}
    "a"[0-9\']*   "*"     -> {Typedid ","}+ {prefer}
    "as"[0-9\']*          -> {Typedid ","}+ {prefer} 

    "tp"[0-9\']*          -> Type 
    "tp"[0-9\']*  "*"     -> {Type "*"}+  

    "srt" [0-9\']*        -> Sort         {prefer}
    "srt" [0-9\']* "*"    -> {Sort ","}*  {prefer}
    "srt" [xyz] [0-9\']*  -> UCID         {prefer}

    "M"   [0-9\']*        -> ModName {prefer}

  variables
    "sc" [0-9\']*         -> DynRuleScopeId        {prefer}
    "sc" [0-9\']* "*"     -> {DynRuleScopeId ","}* {prefer}

    "dr" [0-9\']*         -> DynRuleId {prefer}

    "drd"[0-9\']*         -> DynRuleDef {prefer}
    "drd"[0-9\']*  "*"    -> DynRuleDef+ {prefer}

  lexical syntax
    "xs"[0-9\']*          -> Id  {reject}

    [t][0-9\']*           -> Id  {reject}
    "ts"[0-9\']*          -> Id  {reject}  

    [s][0-9\']*           -> Id  {reject}
    "ss"[0-9\']*          -> Id  {reject}

    [r][0-9\']*           -> Id  {reject}
 
    "a"[0-9\']*           -> Id  {reject}
    "as"[0-9\']*          -> Id  {reject} 

  lexical syntax
    StrategoShortCom 	-> LAYOUT {prefer}
    StrategoLongCom 	-> LAYOUT {prefer}
    StrategoVeryLongCom -> LAYOUT {prefer}
    StrategoWs 		-> LAYOUT {prefer}