module Stratego
exports
  lexical syntax
    [a-zA-Z\'\.\-\_] [a-zA-Z0-9\'\.\-\_]* -> Id
  lexical restrictions
    Id -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "all" 		-> Id {reject}
    "constructors" 	-> Id {reject}
    "fail" 		-> Id {reject}
    "id" 		-> Id {reject}
    "in" 		-> Id {reject}
    "let" 		-> Id {reject}
    "module" 		-> Id {reject}
    "not" 		-> Id {reject}
    "one" 		-> Id {reject}
    "overlays" 		-> Id {reject}
    "override" 		-> Id {reject}
    "prim" 		-> Id {reject}
    "rules" 		-> Id {reject}
    "script" 		-> Id {reject}
    "signature" 	-> Id {reject}
    "some" 		-> Id {reject}
    "sorts" 		-> Id {reject}
    "strategies" 	-> Id {reject}
    "stratego" 		-> Id {reject}
    "test" 		-> Id {reject}
    "thread" 		-> Id {reject}
    "where" 		-> Id {reject}

  lexical syntax
    [a-zA-Z\'\.\-\_] [a-zA-Z0-9\'\.\-\_]* -> ModName
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}

  lexical syntax
    [\t\ \n] 		-> Ws
    "//" ~[\n]* [\n] 	-> ShortCom
    "/*" CommChar* "*/" -> LongCom
    "(*" CommChar* "*)" -> LongCom
    "*" 		-> Asterisk
    ~[\*] 		-> CommChar
    Asterisk 		-> CommChar
  lexical restrictions
    Asterisk -/- [\/\)]

  lexical syntax
    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
    "\\begin{code}" 			   -> VeryLongCom
    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
     					   -> Eof
    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
    ~[\\] 				   -> VLCchar
    Backslash 				   -> VLCchar
    [\\] 				   -> Backslash
  lexical restrictions
    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
    Eof -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    VeryLongCom -> LAYOUT
    Ws 		-> LAYOUT
  context-free restrictions
    LAYOUT? -/- [\ \t\n]

  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\n\\] 			-> StrChar
    [\\] [\"tn\\] 		-> StrChar

  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}

    "specification" Decl*	 -> Module {cons("Specification")}

  sorts Script
  context-free syntax
    "stratego" "script" Command* -> Script {cons("Script")}
    Decl 			-> Command {cons("Command")}
    ":dump" String 		-> Command {cons("Dump")}
    ":load" String 		-> Command {cons("Load")}
    ">" Strategy 		-> Command {cons("Eval")}

    %%"<" Strategy ">" Term 	 -> Start {cons("TopApply")}
    %%Strategy 			 -> Start {cons("TopStrategy")}

  context-free syntax
    "imports" ModName* 		-> Decl {cons("Imports")}
    "rules" Def* 		-> Decl {cons("Rules")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    StrategyDef 		-> Def 
    RuleDef 			-> Def 

  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  context-free syntax
    Id 			   	-> Sort {cons("SortNoArgs")}
    Id "(" {Term ","}* ")" 	-> Sort {cons("Sort")}

  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

  context-free syntax
    Id ":" Type 		-> Opdecl {cons("OpDecl")}

  context-free syntax
    Term 			-> Type {cons("ConstType")}
    {Type "*"}+ "->" Type 	-> Type {cons("FunType")}
    "(" Type ")" 		-> Type {bracket}

  context-free syntax
    Id 				-> Var  {cons("Var")}

  context-free syntax
    "_" 			 -> Term {cons("Wld")}
    Int 			 -> Term {cons("Int")}
    Real 			 -> Term {cons("Real")}
    String 			 -> Term {cons("Str")}
    "_" Term 			 -> Term {cons("BuildDefault")}
    Var 			 -> Term %% {cons("Inj")}
    Var Context 		 -> Term {cons("Con")}

%%    Var "[" Term "]" "(" Id ")"  -> Term {cons("Con")}

    Id "(" {Term ","}* ")" 	 -> Term {cons("Op")}
    Var "@" Term 		 -> Term {cons("As")}
    "(" {Term ","}* ")" 	 -> Term {cons("Tuple")}
    "<" Strategy ">" Term 	 -> Term {cons("App")}
    "[" {Term ","}* "]" 	 -> Term {cons("List")}
    "[" {Term ","}* "|" Term "]" -> Term {cons("ListTail")}
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
    StrategyAngle		 -> Term {cons("RootApp")}
    Term "{" Term "}"		 -> Term {cons("Anno")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> Term {cons("Explode")}
  > Var "@" Term 		 -> Term {cons("As")}

  context-free syntax
    "[" Term "]" 				-> Context {cons("Con1")}
    "[" Term "]" "(" Id ")" 			-> Context {cons("Con2")}
    "[" Term "where" Strategy "]"  		-> Context {cons("Con3")}
    "[" Term "where" Strategy "]" "(" Id ")" 	-> Context {cons("Con4")}

%%  context-free syntax
%%    Id 			      ":" (Rule | Stratrule) -> RuleDef {cons("RDefNoArgs")}
%%    Id "(" {Typedid ","}* ")" ":" (Rule | Stratrule) -> RuleDef {cons("RDef")}

  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}

  context-free syntax
    Id "::" StratRule 				-> RuleDef {cons("SRDefNoArgs")}
    Id "(" {Typedid ","}* ")" "::" StratRule 	-> RuleDef {cons("SRDef")} 

  context-free syntax
    Term "->" Term 		    		-> Rule {cons("RuleNoCond")}
    Term "->" Term "where" Strategy 		-> Rule {cons("Rule")}

  context-free syntax
    Strategy "-->" Strategy 			-> StratRule {cons("StratRuleNoCond")}
    Strategy "-->" Strategy "where" Strategy 	-> StratRule {cons("StratRule")}

  context-free syntax
    "fail" 				  	-> Strategy {cons("Fail")}
    "id" 				  	-> Strategy {cons("Id")}
 
    %% Abstraction

    Id					  -> SVar {cons("SVar")}

    "let" ( StrategyDef | RuleDef )* 
     "in" Strategy 			  -> Strategy {cons("Let")}
    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}

    %% Match and Build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}
    "{" {Id ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     Strategy "=>" Term 		  -> Strategy {cons("AM")}

    "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}

    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

    Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
    Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
    Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}

    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not" "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "test" "(" Strategy ")" 		  -> Strategy {cons("Test")}
    "bagof" "(" Strategy ")" 		  -> Strategy {cons("Bagof")}

  context-free priorities
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}
  >
    {"!" Term 				  -> Strategy {cons("Build")}
     "?" Term 				  -> Strategy {cons("Match")}
    }
  > StrategyAngle Term 		          -> Strategy {cons("BA")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
     Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
     Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

     Strategy "++" Strategy 		  -> Strategy {cons("GChoice"),right}
     Strategy "<++" Strategy 		  -> Strategy {cons("LGChoice"),right}
     Strategy "++>" Strategy 		  -> Strategy {cons("RGChoice"),right}

     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

  context-free syntax

    %% Primitives

    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}

    %% Traversal

    Int Strategy 			  -> Strategy {cons("Path")}
    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
    "thread" "(" Strategy ")" 		  -> Strategy {cons("Thread")}

    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    "("  ")" 		  		  -> Strategy {cons("TupleCong")}
    "(" Strategy  ")" 		  -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")" 		  -> Strategy {cons("TupleCong")}

    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

    %% Dynamic rules

    "rules" "(" RuleDef* ")" 		  -> Strategy {cons("DynamicRules")}
    "override" "rules" "(" RuleDef* ")"   -> Strategy {cons("OverrideDynamicRules")}
    "{|" {Id ","}* ":" Strategy "|}" 	  -> Strategy {cons("DynRuleScope")}

  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    Id 					-> Typedid {cons("DefaultVarDec")}
    Id ":" Type 			-> Typedid {cons("VarDec")}

  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}
