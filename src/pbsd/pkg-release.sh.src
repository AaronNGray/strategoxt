#! /bin/sh

AUTOBUNDLE=__AUTOBUNDLE__
GPP=__GPP__

. `dirname $0`/pbsd-lib.sh

# set of packages to release
pkgs=$*

# release a package by
# -increasing version number
# -creating a distribution
# -copying distribution to /tmp
# -creating new package definition with new version number and /tmp as
#   location field
release() {
   pkg=$1
   version=$2
   new_version=$3
  
   (cd $pkg
    make dist >/dev/null || exit 1
    cp ${pkg}-${new_version}.tar.gz /tmp
   ) || exit 1

   locaf=`pkg-find -p ${pkg}-${version} ${DEPLOY_REPO}`
   dir=`dirname ${locaf}`
   
   pkg-set \
      -i ${locaf} \
      -o ${dir}/${pkg}-${new_version}.pkg.af \
      --location file:///tmp \
      --version ${new_version}
   
   ${GPP}/bin/ast2abox \
      -p ${AUTOBUNDLE}/share/autobundle/Autobundle.pp \
      -i ${locaf} \
   | ${GPP}/bin/abox2text \
      -o ${dir}/${pkg}-${new_version}.pkg
}

# update all package requirements to ${pkg} in the package in a bundle
# to reflect the new version number of the package
update_deps() {
   pkg=$1
   new_version=$2
   # Change all dependencies in current bundle to ${pkg} to newwest version
   for p in ${bundled_pkgs}
   do
      locaf=`pkg-find -p ${p} ${DEPLOY_REPO}`
      loc=`echo ${locaf} | sed 's/.af$//'`

      pkg-set \
         -i ${locaf} \
         -o ${locaf} \
         --dependency ${pkg}-${new_version}

      ${GPP}/bin/ast2abox \
         -p ${AUTOBUNDLE}/share/autobundle/Autobundle.pp \
         -i ${locaf} \
      | ${GPP}/bin/abox2text \
         -o ${loc}
   done
}

# Check if uncommitted changes exist in a package's source tree
has_uncommitted_changed() {
   pkg=$1
   pkg_version=$2
   
   uncommitted=""
   if [ -d ${pkg}/CVS ]; then
      uncommitted="`cvs -n update ${pkg}/ |grep '^[MDAC] '`"
   elif [ -d ${pkg}/.svn ]; then
      echo -n ""
   fi
   
   if [ "a${uncommitted}" = "a" ]; then
      return 1
   else
      return 0
   fi
}


# sequentially release all packages as specified on the command line
for pkg in ${pkgs}
do  
   # determine version
   pkg_version=`grep "^${pkg}," pkg-list | cut -d, -f2`

   # check whether package is in development mode
   pkg_dev_loc=`pkg-find -I ${DEVEL_REPO} -p ${pkg}-${pkg_version}`
   if [ "a${pkg_dev_loc}" = "a" ]; then
      echo "Package ${pkg} not in development mode." >&2 
      exit 1
   fi
   

   # determine new package version
   new_pkg_version=`get_version ${pkg}/configure.ac`

   # check whether package already exists
   pkg_loc=`pkg-find ${DEPLOY_REPO} -p ${pkg}-${new_pkg_version}`
   if [ "a${pkg_loc}" != "a" ]; then
      echo "Package ${pkg} with version ${new_pkg_version} already exists." >&2 
      exit 1
   fi

   # Check if everything has been committed
   if has_uncommitted_changed ${pkg} ${pkg_version} ;
   then
#      echo "Uncommitted changes in ${pkg}. First commit." >&2
#      exit 1

      # Issue a warning messgae
      echo "Uncommitted changes exits; checking out fresh version. Changes are saved." >&2
      
      # Save a copy of checked-out version
      mv ${pkg} ${pkg}-dist-saved
      
      # Check a fresh version out
      ./collect.sh ${pkg}

      # copy configuration status information
      cp -p ${pkg}-dist-saved/config.status ${pkg}
      
      # Create Makefiles from previous generated configuration information
      ( cd ${pkg} && ./config.status )
      
      # indicate that after building the distribution, the CM repository
      # needs to be restored.      
      RESTORE_CM=true
   fi

   # release the package
   release ${pkg} ${pkg_version} ${new_pkg_version}

   # updtae dependencie to the package
   update_deps ${pkg} ${new_pkg_version}
   
   # add new package to set of packages to be bundled
   new_to_bundle="${new_to_bundle} ${pkg}-${new_pkg_version}"

   # Package has been released, so we remove its package definition from
   # development repository
   rm -f ${pkg_dev_loc}

   # Restore saved CM version
   if [ "a$RESTORE_CM" = "atrue" ]; then
      rm -fr ${pkg}
      mv ${pkg}-dist-saved ${pkg}
      RESTORE_CM=""
   fi
done

create_a_bundle ${bundled_pkgs} ${new_to_bundle}

