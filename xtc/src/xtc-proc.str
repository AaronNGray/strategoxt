module xtc-proc
imports xtc-rep config scoped-finite-map options io exec dir

signature
  constructors
    FILE : String -> File
    DIR  : String -> File
    TEMP : XtcKey

    TempFiles : Table
    TempDirs : Table

strategies

  // renaming files

  rename-to(name) :
    FILE(oldname) -> FILE(oldname)
    where name => oldname

  rename-to(name) :
    FILE(oldname) -> FILE(newname)
    where name => newname
	; not(stdout + ?oldname)
        ; <rename-file>(oldname, newname)

  rename-to(name) :
    FILE(oldname) -> stdout
    where name => stdout
	; <copy-file> (oldname, stdout)
	; <remove-file> oldname

  // copying files

  copy-to(name) :
    FILE(oldname) -> FILE(oldname)
    where name => oldname

  copy-to(name) :
    FILE(oldname) -> FILE(oldname)
    where name => newname
	; not(stdout + stderr + ?oldname)
        ; <copy-file>(oldname, newname)

  copy-to(name) :
    FILE(oldname) -> FILE(oldname)
    where name => file
        ; (stdout + stderr)
	; <copy-file> (oldname, file)

  // read term from file

  read-from :
    FILE(name) -> t
    where <file-exists; ReadFromFile> name => t

  read-from :
    stdin -> t
    where <ReadFromFile> stdin => t

  // write term to file

  write-to :
    t -> FILE(name)
    where xtc-new-file => name
        ; <WriteToBinaryFile> (name, t)

  write-to-text :
    t -> FILE(name)
    where xtc-new-file => name
        ; <WriteToTextFile> (name, t)

  /**
   * @type  List(String) -> FILE
   */
  print-to :
    strings -> FILE(name)
      where xtc-new-file => name
          ; <open-file> (name, "w")
          ; <print> (name, strings)
          ; <close-file> name

  xtc-find-file = 
    !FILE(<xtc-find>)

  // XTC-TEMP-FILES : scoped temporary files

  /**
   * Creates a new and unique scoped temporary file.
   *
   * @type _ -> String
   */
  xtc-new-file =
    new-temp-file => (f, fd)
  ; where(
      <assert(!TempFiles)> (f, ())
    )
  ; <close> fd
  ; !f

  xtc-remove-temporaries =
    where(
      <table-get>(XTC, TEMP) => fs
      ; map(try(remove-file))
    )

  xtc-temp-files(s) = 
    begin-scope(!TempFiles)
    ; restore-always(s,
        where((<table-get>(TempFiles, Scopes) <+ ![[]]) => [scope | scopes]
            ; <map(try(remove-file))> scope)
        ; end-scope(!TempFiles)
      )

  // exit after removing temp files

  xtc-exit =
    ?status
    ; repeat( 
        where(<table-get>(TempFiles, Scopes) => [scope | scopes]
            ; <map(try(remove-file))> scope)
        ; end-scope(!TempFiles)
      )
    ; exit


  // XTC-IO : 'read' input file, transform, and 'write' to output file

  xtc-io(s) =
    xtc-temp-files( 
        (!FILE(<get-config> "-i") <+ !stdin)
      ; s
      ; xtc-write-output
    )

  // stop in the middle of a transformation pipeline, copying the
  // current file to the output file.

  xtc-io-exit =
    xtc-write-output
    ; <xtc-exit> 0

  xtc-write-output =
    ?FILE(_); copy-to(<get-config> "-o" <+ !stdout())

  xtc-write-output =
    ?stdin(); <copy-file> (stdin(), <get-config <+ !stdout()> "-o")

  xtc-ensure-file =
    ?FILE(_)

  xtc-ensure-file =
      ?stdin()
    ; where(<xtc-new-file> () => f)
    ; <copy-file> (stdin(), f)
    ; !FILE(f)

  // XTC-OUTPUT : transform, and 'write' to output file

  xtc-output(s) =
    xtc-temp-files(
        s
      ; copy-to(<get-config> "-o" <+ !stdout)
    )

  // XTC-INPUT : 'read' input file, transform

  xtc-input(s) =
    xtc-temp-files(
        (!FILE(<get-config> "-i") <+ !stdin)
      ; s
    )


  // io-wrap for xtc tools: 'read' -i option, transform, and 'write' to -o option

  xtc-io-wrap(s) = 
    xtc-io-wrap(fail, s)

  xtc-io-wrap(extra-opts, s) = 
    option-wrap(extra-opts <+ io-options, xtc-io(s))

  xtc-io-wrap(extra-opts, deps, s) = 
    option-wrap(extra-opts <+ io-options <+ check-options(deps), 
      xtc-check-dependencies
      ; xtc-io(s)
    )

  xtc-iowrap(s) = 
    xtc-io-wrap(s)

  xtc-iowrap(extra-opts, s) = 
    xtc-io-wrap(extra-opts, s)

  xtc-input-wrap(s) =
    xtc-input-wrap(fail,s)

  xtc-input-wrap(extra-options, s) = 
      option-wrap(extra-options <+ input-options, xtc-input(s))



  // check tools upon which this tool depends 

  check-options(deps) = 
    Option("--check"
    , where(<set-config>("--check", <deps>))
    , !"--check        check tool dependencies"
    )

  xtc-check-dependencies =
    if(<get-config> "--check"
      , filter(not(xtc-find-silent))
        ; if(not([])
            , debug(!"No XTC registration found for: "); <exit> 1
	    , <echo> "All tools available"; <exit> 0)
      )

  // XTC-COMMAND
  // Executing an external process
  // a -> String :: List(String) -> List(String)

  xtc-command(tool) = 
    where(tool; xtc-find-warning => loc)
    ; where(<call> (loc, <id>))

  // Transparent transformation of terms and files by external processes

  xtc-transform(tool) =
    xtc-transform(tool, ![])

  xtc-transform(tool, args) =
    (FILE(id) + stdin)
    < xtc-transform-file(tool, args)
    + xtc-transform-term(tool, args)


/**
 * Transforms a file with an external process
 */
strategies

  xtc-transform-file =
    ?(tool, args, file)

  xtc-transform-file(tool) =
    xtc-transform-file(tool, ![])

  xtc-transform-file(tool, args) :
    FILE(f) -> FILE(g)
    where <xtc-new-file> f => g
        ; <conc; xtc-command(tool)> (<args>, ["-i", f, "-o", g])

  xtc-transform-file(tool, args) :
    stdin -> FILE(g)
    where xtc-new-file => g
        ; <conc; xtc-command(tool)> (<args>, ["-o", g])

  /**
   * Transforms a term with an external process
   */
  xtc-transform-term(tool, args) = 
    write-to
    ; xtc-transform-file(tool, args)
    ; read-from

  /**
   * Transforms a file with an internal strategy
   *
   * @type  File -> File
   */
  xtc-io-transform(s) =
    read-from; s; write-to

  // Transforming a file (containing an ATerm) to text with an internal strategy
  xtc-io-transform-text(s) =
      read-from; s; print-to

  // Generating a file with an external process
  xtc-generate(tool) =
    xtc-generate(tool, ![])

  xtc-generate(tool, args) :
    _ -> FILE(g)
    where <xtc-new-file> () => g
        ; <conc; xtc-command(tool)> (<args>, ["-o", g])


strategies

  /**
   * xtc-cat concatenates the content of a list 
   * of Files (FILE or stdin) and stores the result 
   * in a fresh File
   *
   * :: [File] -> File
   */
  xtc-cat:
    in-files -> file
      where xtc-new-file-name => file
          ; <xtc-open-fd> file => fdout
          ; <map(File-as-fd(<fdcopy> (<id>, fdout)))> in-files
          ; <xtc-close-fd> fdout

  /**
   * Transform character chunks in text file.
   *
   * See filter-text-file in char-io module.
   */

  xtc-filter-text-file(more, done) :
    FILE(f) -> FILE(g)
    where <xtc-new-file> f => g
	; <filter-text-file(more, done)> (f, g)

  /**
   * File-as-fd applies the specified strategy to
   * the openend file descriptor of the specified File.
   * The fd is closed in all cases, also when s fails.
   *
   * Int -> b :: File -> b
   */
  File-as-fd(s) =
      xtc-open-fd => fd
    ; finally(s, where(try(<xtc-close-fd> fd)))

  /**
   * xtc-new-file-name is like xtc-new-file but doesn't open the file.
   */
  // :: _ -> File
  xtc-new-file-name =
      new-file => f
    ; where(<assert(!TempFiles)> (f, ()))
    ; !FILE(f)

  // :: File -> Int
  xtc-open-fd =
      \ FILE(s)  -> <open> s \
    + \ stdin()  -> < STDIN_FILENO> () \
    + \ stdout() -> <STDOUT_FILENO> () \
    + \ stderr() -> <STDERR_FILENO> () \

  // :: Int -> ()
  xtc-close-fd = 
    finally(
      ( where(<eq> (<id>, < STDIN_FILENO> ()))
      + where(<eq> (<id>, <STDOUT_FILENO> ()))
      + where(<eq> (<id>, <STDERR_FILENO> ()))
      ) <+ close
    , !())

