The basis of RhoStratego's type system is the Hindley-Milner type
system \cite{typepolymorphism}.  This system consists of the
first-order typed \lcalc{} extended with rank-1 parametric
polymorphism.

We extend the Hindley-Milner system with algebraic data types, typing
rules to support application pattern matches, and runtime type checks
to support genericity.


\paragraph{The Hindley-Milner type system}

In the first-order typed \lcalc{}, types are generated by the grammar
$t ::= var \alt t \ra t$.  For example, the type of \code{id = x \ra x}
is $\alpha \ra \alpha$.  This is a monotype, however: any application
of \code{id} will fix the type.  The expression \code{id 3} will cause
$\alpha$ to be substituted by the base type \code{Int}, giving
\code{id} the type \code{Int \ra Int}, and a subsequent expression
\code{id "Foo"} will be rejected.

In order to obtain polymorphism, the second-order \lcalc{} adds
universal quantification, i.e., $t ::= var \alt t \ra t \alt \forall
var . t$.  Unfortunately, while the second-order \lcalc{} is quite
powerful, type inferencing is undecidable \cite{fundecidable} --- a
serious drawback for practical use.

The Hindley-Milner type system, which we take as the basis of our type
system, reduces the power of the second-order \lcalc{} by generalising
types only at the level of let-bindings, and specialising at each use
of an identifier.  Because of this all types are rank-1\footnote{The
  {\em rank} of a type is the maximum number $n + 1$ such that there
  is a universal quantifier that is contained in $n$ left branches of
  function types.  For example, $\forall \alpha . (\alpha \ra (\forall
  \beta . (\beta \ra \alpha)))$ is a rank-1 type, and $(\forall \alpha
  . ((\forall \beta . (\beta \ra \beta)) \ra \alpha)) \ra
  \text{\code{Int}}$ is a rank-3 type.}.  Type inferencing in this
system {\em is} decidable.


\paragraph{Algebraic data types}

RhoStratego has algebraic data types, just like Haskell, with the
important difference that data types and their constructors are
declared separately.  This gives us the ability to {\em extend} data
types with new constructors, possibly in other modules, without losing
type safety.

\begin{example}
  Here are some examples of algebraic data types.  Data types are
  declared using the keyword \code{data}.  Data types can be
  parameterised with zero or more type variables.  A constructors is
  declared by writing its type signature (the result of the type
  should be a declared data type).
\begin{verbatim}
data Bool; 
True, False :: Bool;

data Point;
Point :: Int -> Int -> Point;

data Fork a;
Fork :: a -> a -> Fork a;

data Tup a b;
Tup :: a -> b -> Tup a b;

data List a;
Nil :: List a;
Cons :: a -> List a -> List a;
\end{verbatim}
  Note that specifying type variables in the data type declarations is
  a bit silly; we only need to know the {\em number} of type
  variables.  Therefore, an alternative syntax would be to write
  \code{data Bool 0}, \code{data List 1}, \code{data Tup 2}, etc.
\end{example}


\paragraph{Type synonyms}

\begin{sloppypar}
  RhoStratego supports type synonyms, the equivalent of Haskell's
  \code{type} declarations.  A type synonym is just syntactic sugar:
  all uses of a type synonym are replaced by its definition before
  typechecking commences.  An example of a type synonym is:
\end{sloppypar}
\begin{verbatim}
syn IntList = List Int;
\end{verbatim}
Note that the keyword \code{syn} is used instead of Haskell's
keyword \code{type} to prevent confusion with data type declarations
(\code{data}).


\paragraph{Application pattern matches}

Certain generic traversal functions such as \code{all} and \code{one}
are implemented using application pattern matches.  How do we type
this language construct?

We should first consider what the intended type of a function such as
\code{all} is; we can then try to find typing rules to obtain the
desired types.  \code{all} applies a function to all subterms of a
term; since the subterms can have any type, the type of the function
should be $\forall \alpha . \alpha \ra \alpha$.  Therefore \code{all}
should have type $\forall \beta . (\forall \alpha . \alpha \ra \alpha)
\ra \beta \ra \beta$.  This is a rank-2 type and hence not supported
by the Hindley-Milner type system, which universally quantifies type
variables only at the `top' of a type.  As a result RhoStratego
needs a rank-$n$ (where $n \ge 2$) type system.

Recall that the definition of \code{all} reads:
\begin{verbatim}
all = f -> (c x -> ^(st (all f c) (f x)) <+ id);
\end{verbatim}
The type of the right-hand alternative, \code{id}, is of course
$\alpha \ra \alpha$ (after instantiation).  We define that the left
and right arguments of a choice must have the same types.  The
left-hand choice, \code{c x \ra \cut{}(st (all f c) (f x))}, must
therefore also have this type.

In order to derive the type of this expression, we must assign types
to the variables \code{c} and \code{x}.  Since the pattern match only
succeeds for a pattern match against a constructed value of some type
$\tau_1$\footnote{The $\tau_i$ denote freshly instantiated type
  variables.}, \code{c} must be a constructor function which expects
an argument of some type $\tau_2$ and returns a value of type
$\tau_1$, i.e., has type $\tau_2 \ra \tau_1$; and \code{x} has type
$\tau_2$.  Hence, the type of \code{c x} is $\tau_1$.  (Things are
actually more complicated than that; the exact typing rules for
application pattern matches are given in the next section).

Now we can assign a type to the body of the rule, \code{\cut{}(st (all
  f c) (f x))}.  Cuts are irrelevant to the type and \code{st} (strict
application) has the uninteresting type $\forall \alpha . \forall
\beta . (\alpha \ra \beta) \ra \alpha \ra \beta$, so we are left with
\code{all f c (f x)}.  We now have the following types:
\[
\begin{array}{lcl}
  \text{\code{all}} & \text{\code{::}} &
  \forall \beta . (\forall \alpha . \alpha \ra \alpha)
  \ra \beta \ra \beta
  \\
  \text{\code{f}} & \text{\code{::}} &
  \forall \alpha . \alpha \ra \alpha
  \\
  \text{\code{c}} & \text{\code{::}} &
  \tau_2 \ra \tau_1
  \\
  \text{\code{x}} & \text{\code{::}} &
  \tau_2
\end{array}
\]
From this we can derive:
\[
\begin{array}{lcll}
  \text{\code{all f}} & \text{\code{::}} &
  \tau_3 \ra \tau_3
  & \text{(after instantiating $\forall \beta$ with $\tau_3$)}
  \\
  \text{\code{all f c}} & \text{\code{::}} &
  \tau_2 \ra \tau_1
  & 
  \\
  \text{\code{f x}} & \text{\code{::}} &
  \tau_4
  & \text{(after instantiating $\forall \alpha$ with $\tau_4$)}
  \\
  \text{\code{all f c (f x)}} & \text{\code{::}} &
  \tau_1
  &
\end{array}
\]

We conclude that the type of the left choice argument is $\tau_1 \ra
\tau_1$, which matches neatly with the right argument.


\paragraph{Genericity}

We have now seen that \code{all} can be typed, and that it has the
type $\forall \beta . (\forall \alpha . \alpha \ra \alpha) \ra \beta
\ra \beta$, and so applies a function of type $\forall \alpha . \alpha
\ra \alpha$ to the subterms.  Unfortunately, in most pure languages
essentially the only function with that type is \code{id} (i.e.,
$\lambda x .  x$).  Hence, we cannot write the following:
\begin{verbatim}
rename = all (try (Var "x" -> Var "y"));
\end{verbatim}
which attempts to rename direct subterms, since the argument to
\code{all} has type \code{Exp \ra Exp} which is not polymorphic.
Therefore RhoStratego provides a {\em runtime type check mechanism}.
We write:
\begin{verbatim}
rename = all (try (Exp?Var "x" -> Var "y"));
\end{verbatim}
The meaning of a pattern $t?p$ (where $t$ is a type and $p$ a pattern)
is that the argument is first checked --- at runtime --- to be of type
$t$.  If it is, we proceed as usual, matching against $p$. Otherwise,
the result is \code{fail}.

We type a pattern $t?p$ by adding {\em guarded types}.  A guarded type
is a type prefixed by a question mark, e.g., \code{?Exp}.  We also
define the type of a runtime type check pattern $t?p$ to be $?t$.  The
type of \code{Exp?Var "x" \ra Var "y"} therefore is \code{?Exp \ra
  Exp} (i.e., \code{(?Exp) \ra Exp}).  The trick is that a type match
between a function type $\alpha \ra \tau_1$ and $?\tau_2 \ra \tau_3$
is performed by matching $\alpha \ra \tau_1$ against $\tau_2 \ra
\tau_3$, but all substitutions found for $\alpha$ are filtered out and
are not applied to the type environment.  The rationale is that a
function with a runtime type check pattern really does match anything
(i.e., the pattern $?\tau_2$ should match with $\alpha$ without a
substitution $\alpha := \tau_2$ taking place), but since the body of
the function is only reached when the argument is of type $\tau_2$,
the type of the body $\tau_3$ is irrelevant when the argument is {\em
  not} of type $\tau_2$, and we can just pretend that it is
polymorphic.

In the example above, then, we can successfully match $\alpha \ra
\alpha$ against \code{?Exp \ra Exp} (with the substitution $\alpha :=
\text{\code{Exp}}$ filtered out), which can be generalized so that it
is a valid argument to \code{all}.  On the other hand $\alpha \ra
\alpha$ does not match against \code{?Exp \ra String}.

The function \code{all} is an example of a {\em type preserving}
function, in which the type of the output is the same as the type of
the input.  We also encounter {\em type unifying} functions, which map
everything to the same type.  An example is the function
\code{collect} (defined in appendix \ref{ch:stdlib}, which returns a
{\em set} of subterms for which a certain function succeeds.  For
example, \code{varNames} collects the set of variables occuring in a
term:
\begin{verbatim}
varNames = collect (Exp?Var x -> x);
\end{verbatim}
Applied to the term
\begin{verbatim}
App (App (Var "f") (App (Var "g") (Var "x"))) (Var "x")
\end{verbatim}
(i.e., the representation of the program fragment \code{f (g x) x}),
it will return the list \code{[f, g, x]}.  The type of \code{collect}
is $\forall \alpha . \forall \beta . (\forall \gamma .  \gamma \ra
\beta) \ra \alpha \ra [\beta]$ (the argument function maps everything
to some $\beta$).  The type of \code{Exp?Var x -> x}, \code{?Exp \ra
  String}, is an instance of $\forall \gamma . \gamma \ra \beta$, with
\code{String} substituted for $\beta$.

The RhoStratego type system restricts guarded types to constructed
types only; they cannot be functions.  Furthermore, the types must be
general (\code{[Int]} is not allowed; \code{[a]} is).  The reason for
this is that we do not want to carry runtime type information for all
values.  For constructed values, this information must be carried
around in any case, since we must be able to distinguish between
constructors.


\paragraph{Sum types}

The RhoStratego type system originally supported sum types, and
each constructor had its own data type.  For example, lists could be
represented as:
\begin{verbatim}
Nil :: Nil;
Cons :: a -> List a -> Cons a;
syn List a = Nil + Cons a;
\end{verbatim}
Then the expression \code{Nil} has not only type \code{Nil}, but
also \code{Nil + Cons a}; in other words, a type \code{A} can be
injected into \code{A + B}.  

The problem with this approach is that the concept of
type-preservation, which is essential for ensuring the type-safety of
functions like \code{all}, becomes inexpressible.  For example, is
\code{A + B \ra A + B} a type-preserving function (and therefore, can
it be given as an argument to \code{all})?  The answer must be `no',
since otherwise we can transform a value of type \code{A} into a value
of type \code{B}.

For this reason we have opted for a more conventional, Haskell-like,
system for data types, with the additional feature that it is
extensible.


\begin{comment}
\item A function with type $A + B \ra A + B$ is {\em not}
  type-preserving, since we can give it an $A$ and get a $B$.
  Therefore we cannot allow such a function to be injected into
  $\forall \alpha . \alpha \ra \alpha$.  The consequences of this are
  significant.  For example, if we have defined lists as \code{Nil +
    Cons a} (see above), then a generic function cannot transform
  \code{Nil} to \code{Cons} or vice versa.  The solution is to define
  lists as follows:
\begin{verbatim}
data Nil;
data Cons a = a, List a;
data List a = Nil + Cons a;
\end{verbatim}
  Defining lists as data types instead of type synonyms causes
  functions that transform lists to have type \code{List $\alpha$ \ra
    List $\alpha$}, which {\em is} type-preserving.
\end{itemize}
\end{comment}

