The question is what the choice operator gains us, apart from nicer
strategic programming.  It is well known that regular pattern matching
is not perfect \cite{firstclasspatterns, patternguards}.
It turns out that the choice operator
eliminates the need for many of the proposals to extends Haskell's
pattern matching, such as {\em views}, {\em pattern guards}, and {\em
  transformational patterns}.
Furthermore, it makes Haskell's ``equational style'' (writing a
function definition as a number of pattern-guarded equations which
must be tried one after another) unnecessary, as well as
\ve{case}-expressions.


\paragraph{Equational style unnecessary.}

Haskell allows us to write patterns not just in $\lambda$-abstractors
but also in function definitions: 
\[
\begin{array}{l}
\ve{f $p_{11}$ \ldots\ $p_{1n}$ = $e_1$} \\
\ve{f $p_{21}$ \ldots\ $p_{2n}$ = $e_2$} \\
\ve{\ldots} \\
\ve{f $p_{m1}$ \ldots\ $p_{mn}$ = $e_m$}
\end{array}
\]
The semantics here are different than in $\lambda$-abstractions: if a
pattern match fails, the program does not diverge, but instead the
next equation is tried.  This is an {\em ad hoc} mechanism that
becomes redundant if we have a choice operator:
\[
\begin{array}{l}
\ve{f = } \\
\quad \ve{$\lambda p_{11}$ \ldots\ $p_{1n}$ \ra $e_1$ <+} \\
\quad \ve{$\lambda p_{21}$ \ldots\ $p_{2n}$ \ra $e_2$ <+} \\
\quad \ve{\ldots} \\
\quad \ve{$\lambda p_{m1}$ \ldots\ $p_{mn}$ \ra $e_m$}
\end{array}
\]

In fact, a major advantage is that pattern matching
$\lambda$-abstractors are now first class, so we can write:
\[
\begin{array}{l}
\ve{$\ve{f}_1$ = $\lambda p_{11}$ \ldots\ $p_{1n}$ \ra $e_1$} \\
\ve{$\ve{f}_2$ = $\lambda p_{21}$ \ldots\ $p_{2n}$ \ra $e_2$} \\
\ve{\ldots} \\
\ve{$\ve{f}_m$ = $\lambda p_{m1}$ \ldots\ $p_{mn}$ \ra $e_m$} \\
\ve{f = $\ve{f}_1$ <+ $\ve{f}_2$ <+ \ldots\ <+ $\ve{f}_m$}
\end{array}
\]
and we can combine the $f_i$ arbitrarily.

Case-expressions can be eliminated from the language in a similar way.


\paragraph{Views.}  

Views \cite{views87} were proposed to address the problem that regular
pattern matching is rather limited since we can only match with actual
constructors.  As a consequence we cannot match against e.g. the end
of a list instead of the head, nor can we match against abstract data
types since there is simply nothing to match against.  For example,
using the proposed views for Haskell \cite{views96} we can write the
following view to match against the end of a list:
\[
\begin{array}{l}
\ve{view Tsil a of [a] = Lin | Snoc y ys where} \\
\ve{\quad tsil xs =} \\
\ve{\quad \quad case reverse xs of} \\
\ve{\quad \quad \quad [] \ra Lin} \\
\ve{\quad \quad \quad (y:ys) \ra Snoc y ys}
\end{array}
\]
where matching against a \ve{Snoc}-constructor causes the function
\ve{tsil} to be applied to the value:
\[
\begin{array}{l}
\ve{f (Snoc y \_) = y} \\
\ve{f Lin = 0}
\end{array}
\]

It is worth pointing out why views (and transformational
patterns) are useful.  The reason is that the equational style can
only be used if the non-applicability of an equation can be discovered
in the pattern.  When that is not possible, the equational style falls
apart, and we have to explicitly write the traversal through the
alternatives (the equations) as a series of ever deeper nested
\ve{case}-expressions.
The choice operator liberates us from this regime, hence the main
motivation for views and transformational patterns disappears.  With
it, the
previous example becomes:
\[
\begin{array}{l}
\ve{f = ($\lambda$(y:\_) \ra y <+ $\lambda$[] \ra 0) . reverse}
\end{array}
\]

Views still have the advantage that the transformation to be applied
(e.g. \ve{tsil}) is implicit in the name of the patterns
(e.g. \ve{Snoc}), but this seems only a minor advantage.


\paragraph{Pattern guards.}

In Haskell's equational notation, we can use boolean guards to further
restrict the applicability of an equation, e.g. \ve{f x | x > 3 =
  123}.  However, there is a disparity between patterns and guards:
patterns can bind variables, whereas guards cannot.  For example, if
we want to return a variable from an environment, or 0 if it is
undefined, we would write:
\[
\begin{array}{lll}
\ve{f env var} & \ve{|} & \ve{isJust (lookup env var)} \\
               & \ve{=} & \ve{fromJust (lookup env var)} \\
\ve{f env var} & \ve{=} & \ve{0}
\end{array}
\]
where \ve{lookup} has type \ve{[($\alpha$, $\beta$)] \ra $\alpha$ \ra
  Maybe $\beta$}.
This is awkward because we now inspect the result of \ve{lookup}
twice.  Pattern guards \cite{patternguards} redefine a guard as a
list of qualifiers, just like in a list comprehension, so that binding
can occur:
\begin{equation}
\label{ex:lookuppg}
\begin{array}{l}
\ve{f env var | Just x $\leftarrow$ lookup env var = x} \\
\ve{f env var = 0}
\end{array}
\end{equation}
But when we have a choice operator, we can just write:
\[
\begin{array}{l}
\ve{f env var = let (Just x) = lookup env var in x <+ 0} \\
\end{array}
\]
Alternatively, we could just get rid of the \ve{Maybe} result of \ve{lookup}
altogether, making it of type 
\ve{[($\alpha$, $\beta$)] \ra $\alpha$ \ra $\beta$}, and then we
get:
\[
\begin{array}{l}
\ve{f env var = lookup env var <+ 0} \\
\end{array}
\]


\paragraph{Transformational patterns.}

Transformational patterns \cite{patternguards} provide a cheap
alternative to views, allowing us to write example \ref{ex:lookuppg} as:
\[
\begin{array}{l}
\ve{f env (Just x)!(lookup env) = x} \\
\ve{f env var = 0}
\end{array}
\]
Hence, transformational patterns are just view transformations made
explicit.  
The choice operator allows a similar notation:
\[
\begin{array}{l}
\ve{f env = ($\lambda$(Just x) \ra x) . (lookup env)} \\
\quad \ve{<+ $\lambda$\_ \ra 0}
\end{array}
\]
In general, a definition \ve{f pat!fun = e} can be written as \vve{f =
  ($\lambda$pat \ra e) . fun}.


%\paragraph{First class patterns.}

%In \cite{firstclasspatterns} patterns are sugar for functions of type 
%\ve{$\alpha$ -> Maybe $\beta$}.


