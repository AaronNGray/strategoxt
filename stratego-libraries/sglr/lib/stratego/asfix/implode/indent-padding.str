/**
 * Indent-padding annotation.
 *
 * @author Lennart Kats
 */
module stratego/asfix/implode/indent-padding
imports
  stratego/concrete-syntax/markers

signature constructors

  AddPadding     : Term -> AddPadding
  PaddingContext : Term -> PaddingContext
  PaddingId      : Term -> PaddingId
  PaddingStart   : PaddingStart
  indentpadding  : Attr
  parse-tree     : Term * Term -> parse-tree

strategies
    
  /**
   * Add an annotation uniquely identifying each {indentpadding} lexical.
   */
  AddPaddedLexicalAnno :
    appl(prod(_, _, attrs([term(indentpadding())])), _) -> <id> {PaddingId(<new>)}
    
  ImplodePaddedLexical :
    appl(prod(_, _, attrs([term(indentpadding())])), _) -> AddPadding(imploded) {PaddingContext(<id>)}
    with
      imploded := <asfix-yield-appl>

  AddIndentPadding(|asfix) :
    AddPadding(t) -> t'
    with
      if !asfix => appl(_, _) then
        if !asfix => _{PaddingId(_)} then
          t' := <id> // keep constructor (add padding later)
        else
          where(
              asfix'       := <strip-tree-before(?_{PaddingId(_)})> asfix
            ; with(padding := <asfix-yield-appl-chars> asfix')
            //; <debug(!"  padding1: ")> <write-to-string> <implode-string> <asfix-yield-appl-chars> asfix
            //; <debug(!"  padding2: ")> <write-to-string> <implode-string> padding
            )
        ; if not(<one('\n')> padding) then
            t' := <id> // keep constructor (add padding later)
          else
            t' := <add-indent-padding-string(|asfix)> t
          end
        end
      else
        t' := <id> // keep constructor (add padding later)
      end

  /**
   * The yield of an AsFixTerm are the characters at the leaves of the tree.
   */
  asfix-yield-appl-chars =
    let yield(|chars) =
            asfix-yield-acc(yield | chars)

     in ?appl(_, <id>)
      ; yield(|[])
    end
  
  add-indent-padding-string(|asfix) =
    topdown(try(AddIndentPaddingString(|asfix)))
  ; conc-to-cons
  
  AddIndentPaddingString(|asfix) :
    AddPadding(s){a*} -> s'
    with
      if !a* => [PaddingContext(context)] then
        asfix'   := <strip-tree-before(?context)> asfix
      ; <with(padding := <asfix-yield-appl-chars; chars-after-newlines>)> asfix'
      ; padding' := <chars-to-whitespace> padding
      ; s'       := <conc; implode-string> (padding', <explode-string> s)
      else
        s' := s
      end
  
  /**
   * Strips the tail of a parse tree starting from the point where <s> succeeds.
   */
  strip-tree-before(s):
    tree -> tree'
    with
      try(?parse-tree(<id>, _));
      tree' := <strip-appl-before(s)>
  
  strip-appl-before(s) =
    if ?appl @ appl(prod @ prod(_, rhs, _), list) then
      if not(!rhs => lit(_) + !rhs => lex(_)) then
	      list' := <strip-appl-list-before(s)> list;
	      if !list' => list then
	        !appl
	      else
	        !appl(prod, list')
	      end
	    <+
	      !list => []; !appl
	  end
	else
	  // Shouldn't happen, or maybe with kernel syntax
	  all(strip-appl-before(s))
	end
  
  strip-appl-list-before(s) :
    [i | i*] -> stripped*
    where
      <s> i
    ; stripped* := []
    <+
      <one(oncetd(s))> i
    ; stripped* := [<strip-appl-before(s)> i]
    <+
      stripped* := [i | <strip-appl-list-before(s)> i*]
  
  chars-to-whitespace :
    [c | c*] -> c'*
    where
      if !c => '\t' then
        c'* := ['\t' | <chars-to-whitespace> c*]
      else
        c'* := [' '  | <chars-to-whitespace> c*]
      end
    
  chars-to-whitespace :
    [] -> []
  
  chars-after-newlines :
    input @ [c | c*] -> c''*
    where
      if !c => '\n' + !c => '\r' then
        c''* := <chars-after-newlines> c*
      else
        c'* := <chars-after-newlines> c*
      ; if !c'* => c* then
          c''* := input
        else
          c''* := c'*
        end
      end
  
  chars-after-newlines :
    [] -> []

