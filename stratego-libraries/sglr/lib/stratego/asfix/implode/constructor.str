/**
 * Implosion of productions that result in constructor applications.
 *
 * An application of a context-free production is transformed
 * into an actual application of a constructor name to the list
 * of children. The Stratego primitive \verb|mkterm| takes a pair
 * of a string \verb|c| and a list of terms \verb|ts| and turns
 * it into the term \verb|c(ts)|. The constructor \verb|c| is
 * derived from the production. If it has a \verb|cons(c)|
 * attribute that attribute is taken. Otherwise the production
 * should be some derived production for regular expressions.
 */
module stratego/asfix/implode/constructor
strategies

  ReplCons(impl) =
       ReplNamedCons(impl)
    <+ ReplAstPattern(impl)
    <+ ReplConsNil(impl)
    <+ ReplConsNone(impl)
    <+ ReplConsIns(impl)
    <+ ReplConsSome(impl)
    <+ ReplConsConc(impl)

rules

  ReplNamedCons(impl) : 
    appl(p, ts){a*} -> c#(<map(impl)>ts){a*}
    where
      <get-cons> p => c

  get-cons : 
    prod(_, _, as) -> x
    where
      <oncetd(?cons(x))> as

rules

  ReplAstPattern(impl) : 
    appl(p, ts){a*} -> term{a*}
    where
      <get-ast-pattern> p => pattern 
    ; <map(impl)>ts => is
    ; {| ReplacePlaceholder: 
        <map-with-index({ ?(i, t) ; rules( ReplacePlaceholder : i -> t ) })>is
      ; <rec rec(
           alltd({ ph:
             is-placeholder
           < get-placeholder => ph
             ; (  ReplacePlaceholder
               <+ "conc"#([rec, rec])
                  ; if "conc"#([is-list, is-list]) then
                      \ "conc"#([xs, ys]) -> <conc> (xs, ys) \
                    end
               <+ log(| Error()
                      , <concat-strings>[ "Could not replace placeholder <",<write-to-string>ph,"> in pattern "
                                        , <write-to-string>pattern]) ; <exit> 1 )
           + fail
           })
         )>pattern => term
      |}

  /**
   * @todo Cache the parsed placeholders.
   */
  get-ast-pattern : 
    prod(_, _, as) -> <read-from-string>x
    where <oncetd(?ast(x))> as

/**
 * @todo Find a more appropiate place for this.
 */
signature
  constructors
    ast : Term -> Term

rules

  ReplConsNil(impl) : 
    appl(p, []) -> []
    where
      <is-nil> p

  ReplConsNone(impl) : 
    appl(p, []) -> None
    where
      <is-none> p

  ReplConsIns(impl) : 
    appl(p, [t]) -> [<impl>t]
    where
      <is-ins> p
      
/**
 * Iter-sep-n, which is normalized to a cons/nil construction.
 */
rules

  /**
   * iter-sep-n with a separator that is ignored.
   */
  ReplConsIns(impl) :
    appl(p, [t1, t2]) -> t
    where
      <is-cons-tail> p
      ; t1' := <impl> t1
      ; t2' := <impl> t2
      ; if <[] + ?[_| _]> t2' then
          ![t1' | t2']
        else
          !"Conc"#([[t1'], t2'])
        end
      ; ?t
      
  /**
   * iter-sep-n with a separator that is not ignored.
   */
  ReplConsIns(impl) :
    appl(p, [t1, t2, t3]) -> t
    where
      <is-cons-tail> p
      ; t1' := <impl> t1
      ; t2' := <impl> t2
      ; t3' := <impl> t3
      ; if <[] + ?[_| _]> t3' then
          ![t1', t2' | t3']
        else
          !"Conc"#([[t1', t2'], t3'])
        end
      ; ?t
      
rules

  ReplConsSome(impl) : 
    appl(p, [t]) -> Some(<impl>t)
    where
      <is-some> p

  ReplConsConc(impl) : 
    appl(p, [t1,t2]) -> t
    where
      <is-conc> p
      ; <impl>t1 => ts1
      ; <impl>t2 => ts2
      ; (<[] + [id|id]> ts2; <conc>(ts1, ts2)
          <+ !"Conc"#([ts1, ts2])) => t

  /**
   * Note: the separator of this concatenation operator is
   * made into an element of the list. Does this make sense?
   */
  ReplConsConc(impl) : 
    appl(p, [t1,t2,t3]) -> <conc>(<impl>t1, [<impl>t2 | <impl>t3])
    where
      <is-conc> p

strategies

  is-nil  = ?prod([], cf(iter-star-sep(_, _)), _)
  is-nil  = ?prod([], cf(iter-star(_)), _)
  is-nil  = ?prod([], iter-star-sep(_, _), _)
  is-nil  = ?prod([], iter-star(_), _)

  is-ins  = ?prod([cf(x)], cf(iter-sep(x,_)), _)
  is-ins  = ?prod([cf(x)], cf(iter(x)), _)
  is-ins  = ?prod([x], iter-sep(x,_), _)
  is-ins  = ?prod([x], iter(x), _)

  is-conc = ?prod([_, _, _], cf(iter(_)), _)
  is-conc = ?prod([_,    _],    iter(_), _)
  is-conc = ?prod([_, _, _], cf(iter-star(_)), _)
  is-conc = ?prod([_, _, _],    iter-star(_), _)
  is-conc = ?prod([_, _, _, _, _], cf(iter-sep(_, _)), _)
  is-conc = ?prod([_,    _,    _], iter-sep(_, _), _)
  is-conc = ?prod([_, _, _, _, _], cf(iter-star-sep(_, _)), _)
  is-conc = ?prod([_,    _,    _], cf(iter-star-sep(_, _)), _)

  is-cons-tail = ?prod([_, _, _, _, _], cf(iter-sep-n(_, _, _)), _)
  is-cons-tail = ?prod([_,    _,    _], cf(iter-n(_, _)), _)

  /**
   * @todo Not sure what this case is for.
   */
  is-conc = ?prod([_, _], cf(iter-star-sep(_, _)), _)

  is-none = ?prod([], cf(opt(_)), _)
  is-none = ?prod([], opt(_), _)

  is-some = ?prod([cf(x)], cf(opt(x)), _)
  is-some = ?prod([x], opt(x), _)

strategies

  Cns = CnsNil <+ CnsGeneric

rules

  CnsNil : 
    appl(p, ts) -> []
    where
      <ConstrNil> p => c 

  ConstrNil : prod([],cf(iter-star-sep(_,_)),_)     -> "Nil"
  ConstrNil : prod([],cf(iter-star(_)),_)           -> "Nil"
  ConstrNil : prod([],iter-star-sep(_,_),_)         -> "Nil"
  ConstrNil : prod([],iter-star(_),_)               -> "Nil"

  CnsGeneric : 
    appl(p, ts) -> c#(ts)
    where <Constr0 <+ Constr1> p => c 

  /**
   * @todo Optimize the oncetd
   */
  Constr0 : 
    prod(_, _, as) -> x
    where
      <oncetd(?cons(x))> as

  Constr1 : prod([cf(x)], cf(iter-sep(x,_)), _)   -> "Ins"
  Constr1 : prod([cf(x)], cf(iter(x)), _)         -> "Ins"
  Constr1 : prod([x], iter-sep(x,_), _)           -> "Ins"
  Constr1 : prod([x], iter(x), _)                 -> "Ins"

  Constr1 : prod([_,_,_,_,_],cf(iter-sep(_,_)),_) -> "Conc"
  Constr1 : prod([_,_,_],    cf(iter-sep(_,_)),_) -> "Conc" // after layout removal
  Constr1 : prod([_,_,_],    cf(iter(_)),_)       -> "Conc"
  Constr1 : prod([_,_],      cf(iter(_)),_)       -> "Conc" // after layout removal
  Constr1 : prod([_,_,_],    iter-sep(_,_),_)	  -> "Conc"
  Constr1 : prod([_,_],      iter(_),_)           -> "Conc"

  Constr1 : prod([_,_,_,_,_], cf(iter-star-sep(_,_)),_) -> "Conc"
  Constr1 : prod([_,_,_],     cf(iter-star-sep(_,_)),_) -> "Conc"

  Constr1 : prod([], cf(opt(_)), _)		  -> "None"
  Constr1 : prod([], opt(_), _)			  -> "None"

  Constr1 : prod([cf(x)], cf(opt(x)), _)          -> "Some"
  Constr1 : prod([x], opt(x), _)                  -> "Some"

  Constr23 : 
    prod(args, cf(iter-sep(x, y)), _) -> c
    where <(?[cf(x)]; !"Ins" <+ ?[_,_,_,_,_]; !"Conc")> args => c
