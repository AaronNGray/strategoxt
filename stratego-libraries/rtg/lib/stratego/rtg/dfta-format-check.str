/**
 * Checks if the input term is accepted by the given Deterministic Finite 
 * Tree Automaton (DFTA).
 *
 * @author Martin Bravenboer
 */
module rtg-format-check
imports
  libstratego-lib libstratego-rtg

signature
  constructors
    Failure : Failure

strategies

  main =
    input-wrap(fc-options, dfta-format-check(true, true |<get-config; open-dfta> "--dfta"))

  fc-options =
    ArgOption("--dfta"
    , <set-config> ("--dfta", <ReadFromFile>)
    , !"--dfta <file>    Format check using dfta in <file>"
    )

strategies

  /**
   * Checks that the current term has the format of the given DFTA.
   *
   * Fails if the current term has an incorrect format.
   * Does not report errors.
   *
   * @param DFTA
   * @type a -> a
   */
  dfta-format-check(|dfta) =
    dfta-format-check(false, true | dfta)
  
  /**
   * Checks that the current term has the format of the given DFTA.
   *
   * @param Report errors (true/false)
   * @param Fail if incorrect format (true/false)
   * @param DFTA
   * @type a -> a
   */
  dfta-format-check(report-errors, fail-on-error | dfta) =
    where(
        if report-errors then 
            dfta-accept(dftafc-report-failure | dfta)
          ; dftafc-report-start(|dfta)
        else
          dfta-accept(id | dfta)
        end
      ; if fail-on-error then
          dftafc-error-start(|dfta)
        end
    )

/**
 * Reporting
 */
strategies

  /**
   * Fails if the state is not one of the allowed start states.
   *
   * @param DFTA
   * @type State -> State
   */    
  dftafc-error-start(|dfta) =
    ?state
    ; where(
        DFTA(starts, _) := dfta
      ; <fetch(?state)> starts
      )

  /**
   * TODO: the start symbol might be a member of the set.
   */
  dftafc-report-start(|dfta) =
    ?state
    ; where(
        DFTA(starts, _) := dfta
      ; if Failure() := state then
          !1  // already reported
        else
          if <fetch(?state)> starts then
            if-verbose2(
              <dftafc-state-to-string; debug(!"info: term typed as ")> state
            )
            ; !0
          else
            <fprintnl> (<stderr-stream>,
              ["error: term typed as ", <dftafc-state-to-string> state, 
               " but expected ", <dftafc-states-to-string> starts])
            ; !1
          end
        end
      ; <set-config> ("--exit-code", <id>)
      )

  dftafc-report-failure(|t) =
    ?Appl(_, arg-states)
    ; where(
        if not(<fetch(?Failure())> arg-states) then
          <fprintnl> (<stderr-stream>, ["error: cannot type ", <write-to-string> t])
          ; if not([] := arg-states) then
              <fprintnl> (<stderr-stream>, ["    inferred types of subterms: "])
              ; args := <dftafc-get-arguments> t
              ; <zip> (args, arg-states)
              ; map({arg,state:
                  ?(arg, state)
                  ; <fprintnl> (<stderr-stream>, [
                        "    typed "
                      , <write-to-string> arg
                      , " as "
                      , <dftafc-state-to-string> state
                      ])
                })
          end
        end
      )

  dftafc-state-to-string =
    ?Set(<dftafc-states-to-string>) <+ rtg-to-string
    

  dftafc-states-to-string =
    map(dftafc-state-to-string); separate-by(!", "); concat-strings

rules

  rtg-to-string :
    Nonterm(s) -> s

  rtg-to-string :
    Set(args) -> <concat-strings> [
        "{"
      , <map(rtg-to-string); separate-by(!", "); concat-strings> args
      , "}"
      ]

  rtg-to-string :
    Generated(t) -> <rtg-to-string> t

  rtg-to-string :
    Appl(t, args) -> <concat-strings> [
        <rtg-to-string> t
      , "("
      , <map(rtg-to-string); separate-by(!", "); concat-strings> args
      , ")"
      ]

  rtg-to-string :
    Ref(nt) -> <rtg-to-string> nt

  rtg-to-string :
    Term(s) -> s

  rtg-to-string :
    ConcTerm() -> "<conc>"

  rtg-to-string :
    SomeTerm() -> "<some>"

  rtg-to-string :
    NoneTerm() -> "<none>"

  rtg-to-string :
    StringTerm() -> "<string>"

  rtg-to-string :
    IntTerm() -> "<int>"

  rtg-to-string :
    TupleTerm(x) -> <conc-strings> ("<(", <int-to-string> x, ")>")

strategies

  /**
   * The result of dtfa-accept is a state. The strategy does not check
   * if this state is one of the start states of the DFTA.
   */
  dfta-accept(fail-hook : t * Appl -> a | dfta) =
    where(!dfta => DFTA(set, tbl))
    ; let transition(|t) = dfta-accept-transition(fail-hook | tbl, t)
       in bottomup-reconstruct(transition, dfta-accept-reconstruct)
      end

  dfta-accept-transition(fail-hook : t * Appl -> a | tbl, t) = id
    ; ?a
    ; <hashtable-get(|a)> tbl
    <+ fail-hook(|t)
       ; !Failure()

/**
 * Explode determines the next transition.
 */
strategies

  dfta-accept-reconstruct(|args) =
       dfta-accept-explode-int(|args)
    <+ dfta-accept-explode-string(|args)
    <+ dfta-accept-explode-nil(|args)
    <+ dfta-accept-explode-cons(|args)
    <+ dfta-accept-explode-conc(|args)
    <+ dfta-accept-explode-some(|args)
    <+ dfta-accept-explode-none(|args)
    <+ dfta-accept-explode-appl(|args)

  dfta-accept-explode-nil(|args) =
    ?[]
    ; !Appl(NilTerm(), [])

  dfta-accept-explode-cons(|args) =
    ?[_ | _]
    ; !Appl(ConsTerm(), args)

  dfta-accept-explode-conc(|args) =
    ?Conc(_, _)
    ; !Appl(ConcTerm(), args)

  dfta-accept-explode-none(|args) =
    ?None()
    ; !Appl(NoneTerm(), [])

  dfta-accept-explode-some(|args) =
    ?Some(_)
    ; !Appl(SomeTerm(), args)

  dfta-accept-explode-appl(|args) = id
    ; where(f := <get-constructor>)
    ; if f := "" then
        !Appl(TupleTerm(<length> args), args)
      else
        !Appl(Term(f), args)
      end

  dfta-accept-explode-int(|args) =
    is-int
    ; !Appl(IntTerm(), [])

  dfta-accept-explode-string(|args) =
    is-string
    ; !Appl(StringTerm(), [])

/**
 * Open an RTG to a simple representation of a tree automata.
 */
strategies

  is-dfta =
    ?DFTA(_, _)

  /**
   * @todo We really need garbage collection for hashtables.
   */
  open-dfta =
    ?RTG(Start(start-states), ProdRules(<id>))
    ; where(
          tbl := <new-hashtable>
      )
    ; map({a, q:
        ?ProdRule(q, [a@Appl(_, _)])
        ; <hashtable-put(|a, q)> tbl
        <+ debug(!"internal error: cannot create type rule for ")
           ; fail
      })
    ; !DFTA(start-states, tbl)

  dfta-destroy =
    DFTA(id, hashtable-destroy)

signature
  constructors
    DFTA : List(State) * Hashtable -> DFTA

strategies

  /**
   * Bottom traversal where the current term is reconstructed
   * from the arguments using a custom strategy.
   */
  bottomup-reconstruct(s, reconstruct : List(b) * a -> c) =
    ?t
    ; ( ?[x | xs]
      < ![<bottomup-reconstruct(s, reconstruct)> x, <bottomup-reconstruct(s, reconstruct)> xs]
      + ?[]
      < ![]
      + is-int
      < ![]
      + is-string
      < ![]
      + get-appl-arguments(bottomup-reconstruct(s, reconstruct))
      )
    ; ?args
    ; <reconstruct(|args)> t
    ; s(|t)

  dftafc-get-arguments =
    ( ?[x | xs]
    < ![x, xs]
    + ?[]
    < ![]
    + is-int
    < ![]
    + is-string
    < ![]
    + get-appl-arguments
    )
