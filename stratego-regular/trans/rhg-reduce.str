/**
 * Removes non-terminals that are not productive or reachable.
 *
 * @see     TATA section 2.1.1
 * @author  Martin Bravenboer <martin@cs.uu.nl>
 */
module rhg-reduce
imports options collect list rhg rhg-util relational-calculus logging

strategies

  main-rhg-reduce =
    io-wrap(rhg-reduce)

  /**
   * @type RHG -> RHG
   */
  rhg-reduce =
      log(|Debug(), "Ungroup productions")
    ; ungroup-productions

    ; log(|Debug(), "Determine productive non terminals")
    ; where(productive-nonterms => productive)

    ; log(|Debug(), "Removing not productive non terminals")
    ; RHG(
        Start(filter(where(<elem> (<id>, productive))))
      , ProdRules(filter(all-nonterms-in(|productive)))
      )

    ; log(|Debug(), "Determine reachable non terminals")
    ; where(reachable-nonterms  => reachable)

    ; log(|Debug(), "Removing not reachable non terminals")
    ; RHG(id, ProdRules(filter(all-nonterms-in(|reachable))))

    ; rhg-check-result

  /**
   * Exits when the result doesn't contain any productions or start symbols.
   *
   * @type RHG -> RHG
   */
  rhg-check-result =
      try(
        ?RHG(Start([]), ProdRules(_))
      ; fatal-err(|"No productive start symbols left in rhg")
      )
    ; try(
        ?RHG(Start(_), ProdRules([]))
      ; fatal-err(|"No productions left in rhg")
      )

strategies

  /**
   * Succeeds if all non-terminals in the production are in the specified
   * set of non-terminals.
   *
   * @type ProdRule -> ProdRule
   */
  all-nonterms-in(|nts) =
    where(collect-nonterms; all(<elem> (<id>, nts)))

/**
 * Productive
 */
strategies

  /**
   * Returns the set of productive non terminals in the rhg.
   *
   * @type RHG -> Set(NonTerm)
   */
  productive-nonterms =
    ?rhg
    ; <collect-nonterms> rhg => nts
    ; let 
          prod-0 = ![]
    
          prod-n = {productive: ?productive;
                  <union> (productive, <filter(can-be-produced(|<id>, productive, rhg))> nts)
            }

       in prod-0; set-inc-repeat(prod-n)
      end

  /**
   * Succeeds if the non-terminal can be produced by the rhg given the set of productive non-terminals.
   */
  can-be-produced(|nt : NonTerm, productive : Set(NonTerm), rhg : RHG) =
    where(
      <productions-of(|nt)> rhg
    ; one(collect-nonterms; all(<elem> (<id>, productive)))
    )

/**
 * Reachable
 */
strategies

  /**
   * Returns the set of reachable non terminals in the rhg.
   *
   * @type RHG -> Set(NonTerm)
   */
  reachable-nonterms =
    ?RHG(Start(starts), ProdRules(prods))
    ; let
          reach-0 = !starts // TODO: collect non terminals in Start regexp

          reach-n = {reach: ?reach;
              <unions> [reach | <filter(\
                  ProdRule(nt, rhs*) -> <collect-nonterms> rhs*
                    where <elem> (nt, reach)
                \)> prods]
            }

       in reach-0; set-inc-repeat(reach-n)
      end

strategies

  /**
   * Repeats s until the current set is no longer being extended.
   *
   * @type  Set(a) -> Set(a)
   */
  set-inc-repeat(s : Set(a) -> Set(a)) =
    rec x( {l:
        where(length => l)
      ; s
      ; (where(<gt> (<length>, l)) < x + id)
    })

  /**
   * Collect all (not build in) non-terminals in a rhg (or anything else).
   *
   * @type RHG -> Set(NonTerm)
   */
  collect-nonterms =
    collect(?Nonterm(_))
