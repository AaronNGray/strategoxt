/**
 * Implodes AsFix2 and AsFix2ME to IRTG.
 *
 * AsFix is a language for parse trees.
 * IRTG is a language for abstract syntax trees.
 *
 * @author  Martin Bravenboer <martin@cs.uu.nl>
 */
module asfix2irtg
imports options irtg logging tuple-cons asfix

strategies

  main-asfix2irtg =
    io-wrap(asfix-to-irtg)

  asfix-to-irtg =
      ?parsetree(<id>, 0)
    ; tree-to-tree
    ; remove-start-prod

  remove-start-prod =
    ?Prod(Nonterm("<START>"), <id>)

strategies

  /**
   * Injection
   *
   * @type  AsFix Tree -> AnnoTreeFN
   */
  tree-to-tree :
    appl(prod(syms, sort(s), attrs), ts)
      ->
    Prod(Nonterm(s), t)
      where <not(lookup-cons)> attrs
          ; <prod-to-trees> (syms, ts) => [t]

  /**
   * Constructor application
   */
  tree-to-tree :
    appl(prod(syms, sort(s), attrs), ts)
      ->
    Prod(Nonterm(s), Appl(Term(c), ts'))
      where <lookup-cons> attrs => c
          ; <prod-to-trees> (syms, ts) => ts'

  /**
   * AsFix2ME list application of characters
   */
  tree-to-tree :
    appl(list(iter-star(char-class(_))), cs) -> String(<implode-string> cs)

  tree-to-tree =
    !List(<tree-to-trees>)

  /**
   * Empty list production
   * -> {S sep}*
   */
  tree-to-trees :
    appl(prod([], cf(iter-star-sep(_, _)), no-attrs()), []) -> []

  /**
   * {S sep}+ -> {S sep}*
   */
  tree-to-trees :
    appl(prod([cf(iter-sep(_, _))], cf(iter-star-sep(_, _)), no-attrs()), [t]) -> <tree-to-trees> t

  /**
   * S -> {S sep}*
   */
  tree-to-trees :
    appl(prod([cf(sym)], cf(iter-star-sep(sym, _)), no-attrs()), [t]) -> [<tree-to-tree> t]

  /**
   * {S sep}+ sep {S sep}+ ->  {S sep}+
   */
  tree-to-trees :
    appl(prod(syms, cf(iter-sep(sym, sep)), attrs), ts) -> <map(is-list <+ ?List(<id>) <+ ![<id>]); concat> ts'
      where <not(lookup-cons)> attrs      
          ; <prod-to-trees> (syms, ts) => ts'

  /**
   * S -> {S sep}+
  tree-to-trees :
    appl(prod([cf(sym)], cf(iter-sep(sym, _)), no-attrs()), [t]) -> [<tree-to-tree> t]
   */

  tree-to-tree :
    appl(list(cf(sym@iter-star-sep(_, _))), ts) -> List(ts')
      where <filter(not(tree-is-layout))> ts
          ; where(<iter-star-sep-to-syms> (sym, <id>) => syms)
          ;  <prod-to-trees> (syms, <id>) => ts'

  /**
    * Given a list of trees, produces a list of symbols for these trees. 
    *
    * @type  Symbol * List(AnnoTreeFN) -> List(Symbols)
    */
   iter-star-sep-to-syms :
     (iter-star-sep(sym, sep), ts) -> syms
       where let nextsep = [!sep | nextsym] + []
                 nextsym = [!sym | nextsep] + []
              in <nextsym> ts => syms
             end

  /**
   * lexical production without constructor
   */
  tree-to-tree :
    appl(prod(_, lex(_), attrs), ts) -> String(<trees-to-string> ts)
      where <not(lookup-cons)> attrs
  
  /**
   * context-free production
   */
  tree-to-tree =
    appl(prod(id, ?cf(<id>), id), id); tree-to-tree

  try-tree-to-tree =
    tree-to-tree
      <+ log(|Error(), "Cannot implode tree", <id>); fail

strategies

  trees-to-string =
      map(tree-to-chars)
    ; flatten-list
    ; implode-string

  tree-to-chars =
    ?appl(_, <map(tree-to-chars)>) <+ ![<is-int>]

strategies

  /**
   * Succeeds if the symbol represents layout.
   *
   * @type  Symbol -> Symbol
   */
  sym-is-layout = cf(sym-is-layout)
  sym-is-layout = opt(sym-is-layout)
  sym-is-layout = layout()
  sym-is-literal = lit(id)

  sym-is-not-abstract =
    sym-is-layout + sym-is-literal

  /**
   * Succeeds if the tree represents layout.
   */
  tree-is-layout = appl(prod(id, sym-is-layout, id), id)

strategies

  /**
   * @type  List(Symbol) * List(Tree) -> List(AnnoTreeFN)
   */
  prod-to-trees =
      zip
    ; filter((not(sym-is-not-abstract), id))
    ; map(?(_, <try-tree-to-tree>)) => ts'

  /**
   * @type  Attributes -> String
   */
  lookup-cons =
    ?attrs(
       <fetch-elem(?term(cons(<id>)))>
     )
