/**
 * Operations on relations
 *
 * A relation is represented as a set of tuples:
 *   [(a1, b1), (a2, b2), ....]
 *
 * In the examples the following relations are used:
 *   calls = [(main, a), (main, b), (a, b), (a, c), (a, d), (b, d)]
 *
 * Examples and ideas are taken from the presentation "Using Relational Calculus 
 * for Program Querying" by Paul Klint.
 *
 * @author Martin Bravenboer
 */
module relational-calculus
imports list-set

strategies

  /**
   * Returns the inverse of a relation.
   *
   * e.g.
   *   <rel-inverse> [(a, b), (c, d)] => [(b, a), (d, c)]
   *
   * @type Relation(a, b) -> Relation(b, a)
   */
  rel-invert =
    map(Swap)

  /**
   * Returns the transitive closure of a relation.
   *
   * @type  Relation(a, a) -> Relation(a, a)
   */
  rel-trans-closure =
    rel-trans-closure(rel-compose-cond-eq)

  rel-trans-closure(cond) =
    <foldl(<rel-union> (<Snd>, <rel-compose(cond)>))> (<copy(|<length>)>, <id>)

  /**
   * @type n  Int
   * @type    a -> [a]
   */
  copy(|n : Int) =
    <copy> (n, <id>)

  /**
   * @type Relation(a, b) * Relation(a * b) -> Relation(a, b)
   */
  rel-union =
    union

  /**
   * @type Relation(a, b) * Relation(a * b) -> Relation(a, b)
   */
  rel-diff =
    diff

  /**
   * @type Relation(a, b) * Relation(b * c) -> Relation(a, c)
   */
  rel-compose =
    rel-compose(rel-compose-cond-eq)

  /**
   * Composes two relations given a composition condition strategy
   *
   * @type cond (a * b) * (b * c) ->? _
   * @type      Relation(a, b) * Relation(b * c) -> Relation(a, c)
   */
  rel-compose(cond) =
    cart(id)
    ; filter( \
        t@((a, _), (_, b)) -> (a, b)
          where <cond> t
      \)

  /**
   * Default composition condition that succeeds when a -> b and b -> c .
   * 
   * @type (a * b) * (b * c) ->? (a * b) * (b * c)
   */
  rel-compose-cond-eq =
    ?((_, x), (x, _))

  /**
   * @type Relation(a, b) -> [a or b]
   */
  rel-carrier =
    <union> (<rel-domain>, <rel-range>)

  /**
   * @type Relation(a, b) -> [a]
   */
  rel-top = 
    <diff> (<rel-domain>, <rel-range>)

  /**
   * @type Relation(a, b) -> [b]
   */
  rel-bottom = 
    <diff> (<rel-range>, <rel-domain>)

  /**
   * @type Relation(a, b) -> [a]
   */
  rel-domain =
    map(Fst); make-set

  /**
   * @type Relation(a, b) -> [b]
   */
  rel-range =
    map(Snd); make-set

  /**
   * Removes all pairs where the lhs is not in the specified domain.
   *
   * e.g.
   * <rel-restrict-domain(|[main])> calls => [(main, a), (main, b)]
   *
   * @type domain Set(a)
   * @type        Relation(a, b) -> Relation(a, b)
   */
  rel-restrict-domain(|domain) =
    filter(where(<elem> (<Fst>, domain)))

  /**
   * @type x a
   * @type   Relation(a, b) -> Set(b)
   */
  rel-right-image(|x) =
    filter(?(x, <id>))

  /**
   * Removes all pairs where the rhs is not in the specified range.
   *
   * e.g.
   * <rel-restrict-range(|[d])> calls => [(a, d), (b, d)]
   *
   * @type range Set(b)
   * @type       Relation(a, b) -> Relation(a, b)
   */
  rel-restrict-range(|range) =
    filter(where(<elem> (<Snd>, range)))

  /**
   * @type  (a * b) * Relation(a, b) -> fail?
   */
  rel-in =
    where(elem)

strategies

  /*
   * Port of imperative algorithm "Transitive-Closure" on page 563 of 
   * "Introduction to Algorithms", Thomas Cormen.

  transitive-closure =
    ?rel
    ; rel-carrier => elems
    ; <map(!(<id>, <id>))> elems => self-rel
    ; <cart(id)> (elems, elems) => matrix
    ; <foldl(
        \ (k, last) -> 
            <filter(
                test(<in-relation> (<id>, last))
              +   test(<in-relation> ((<Fst>, k), last))
                ; test(<in-relation> ((k, <Snd>), last))
            )> matrix \
      )> (elems, <union> (rel, self-rel))
  */
  