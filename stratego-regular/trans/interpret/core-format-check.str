/**
 * @todo  Support nested trees or extend normalizer to remove them.
 *
 * @author  Martin Bravenboer <martin@cs.uu.nl>
 */
module core-format-check
imports liblib logging regular-options rtg rtg-util

strategies

  main-core-format-check =
    io-wrap(core-fc-options,
      main-format-check
    ; where(output(id))
    ; <get-config> "--exit-code"
    ; exit
    )

  main-format-check =
      where(
        read-rtg-nf-config => rtg@RTG(Start(starts), _)
      ; generate-type-rules
      )
    ; format-check
    ; format-check-report(|<get-start-nonterms(!starts)>)

  format-check-init =
    where(
      read-rtg-nf-config => rtg@RTG(Start(starts), _)
    ; generate-type-rules
    )

  core-fc-options =
      rtg-nf-option(|"Check against normalized RTG in file")
    + start-nonterm-option(|"Term must be of type s (default: start non-terms of rtg)")

  get-start-nonterms(default) =
    get-start-nonterm; ![Nonterm(<id>)] <+ default

strategies

  /**
   * Main format check traversal.
   *
   * The first alternatives reuses the result of previous
   * type checking. The size of the traversal is therefore the
   * size of the maximal shared tree.
   *
   * The second alternative tries to infer as many types
   * as possible, but at least one.
   *
   * If this fails, then the term is not in the right format.
   *
   * @type  starts  List(NonTerm)
   */
  format-check =
    where(<set-config> ("typetable", <new-hashtable> ()))
  ; where(<repeat(Type)> "")
  ; bottomup-consnil(
       where(get-types)

    <+ type-string

    <+ repeat1(Type)
       ; report-types

    <+ one-consnil(not(is-typed))

    <+ report-type-failure(id)
    )

  type-string =
    is-string
    ; ?s
    ; where(
        <get-types> "" => set
      ; <get-config> "typetable"
      ; hashtable-put(|s, set)
      )

  is-typed =
    where(get-types; iset-elements => [_ | _])

/**
 * Define type rules for the productions of an RTG.
 *
 * Type rules are defined in a dynamic rule 'UserType'.
 */
strategies

  /**
   * Generate format checking dynamic rules for an RTG
   *
   * @type  RTG -> _
   */
  generate-type-rules =
      ungroup-productions
    ; ?RTG(Start(_), ProdRules(<id>))
    ; map(generate-type-rule)

  /**
   * Injection
   */
  generate-type-rule =
    ?ProdRule(b, [Ref(a)])
    ; rules(
        UserType :+ t -> t
          where <has-type(|a)> t
              ; <new-type(|b)> t
      )
    <+ debug(!"internal error: cannot create type rule for "); fail

  /**
   * Cons application
   */
  generate-type-rule =
    ?ProdRule(c, [Appl(ConsTerm(), [Ref(a), Ref(b)])])
    ; rules(
        UserType :+ t@[hd | tl] -> t
          where <not(has-type(|c))> t
              ; <has-type(|b)> tl
              ; <has-type(|a)> hd
              ; <set-type(|c)> t
      )

  /**
   * Conc application
   */
  generate-type-rule =
    ?ProdRule(c, [Appl(ConcTerm(), [Ref(a), Ref(b)])])
    ; rules(
        UserType :+ t@Conc(t1, t2) -> t
          where <has-type(|a)> t1
              ; <has-type(|b)> t2
              ; <new-type(|c)> t
      )

  /**
   * Nil application
   */
  generate-type-rule =
    ?ProdRule(a, [Appl(NilTerm(), [])])
    ; rules(
        UserType :+ t@[] -> t
          where !t => []
              ; <new-type(|a)> []
      )

  /**
   * Some application
   */
  generate-type-rule =
    ?ProdRule(b, [Appl(SomeTerm(), [Ref(a)])])
    ; rules(
        UserType :+ Some(t) -> Some(t)
          where <has-type(|a)> t
              ; <new-type(|b)> Some(t)
      )

  /**
   * None application
   */
  generate-type-rule =
    ?ProdRule(a, [Appl(NoneTerm(), [])])
    ; rules(
        UserType :+ None() -> None()
          where <new-type(|a)> None()
      )

  /**
   * Tuple application
   */
  generate-type-rule =
    ?ProdRule(a, [Appl(TupleTerm(_), as)])
    ; rules(
        UserType :+ t@""#(args) -> t
          where <not(has-type(|a))> t
              ; <list-has-type(|<map(?Ref(<id>))> as)> args
              ; <set-type(|a)> t
      )

  /**
   * User-defined terminal application
   */
  generate-type-rule =
    ?ProdRule(a, [Appl(Term(f), as)])
    ; rules(
        UserType :+ t@f#(args) -> t
          where <not(has-type(|a))> t
              ; <list-has-type(|<map(?Ref(<id>))> as)> args
              ; <set-type(|a)> t
      )

  /**
   * @type  List(_) -> _
   * @type  as  List(NonTerm)
   */
  list-has-type(|as) =
    where(
      where(!as => [a | bs])
    ; [has-type(|a) | list-has-type(|bs)]
    <+ ?[]
     ; !as => []
    )

/**
 * Type types a term.
 */
strategies

  Type =
    where(StandardType + UserType)

  StandardType =
    is-int; new-type(|Int())

  StandardType =
    is-string; new-type(|String())

strategies

  /**
   * Fails if t already has type nt
   *
   * @type  t -> t
   */
  new-type(|a) =
    where(
      retrieve-types
    ; not(iset-contains(|a))
    ; iset-add(|a)
    )

  set-type(|a) =
    where(
      retrieve-types
    ; iset-add(|a)
    )

  /**
   * Succeeds if t has type nt
   *
   * @type  t -> t
   */
  has-type(|a) =
    where(
      retrieve-types
    ; iset-contains(|a)
    )

  /**
   * Returns an IndexedSet of types for a term.
   *
   * A new set is created if this hasn't been done yet.
   */
  retrieve-types =
    get-types
    <+ ?t
       ; new-iset(|8, 75) => set
       ; where(
           <get-config> "typetable"
         ; hashtable-put(|t, set)
         )

  get-types =
    ?t
    ; <get-config> "typetable"
    ; hashtable-get(|t)

/**
 * Reporting
 */
strategies

 format-check-report(|starts) =
    where(
     (get-types; iset-elements <+ ![]) => types
    ; if !types => [] then
        !1 // already reported <fatal-error> ["error: term cannot be typed."]
      else
          <isect> (starts, <id>)
        ; if ?[] then
              <printnl>
                ["error: term typed as ", <types-to-string> types, 
                 " but expected ", <types-to-string> starts]
            ; !1
          else
            if-verbose1(<types-to-string; debug(!"info: term typed as ")> types)
            ; !0
          end
      end
    ; <set-config> ("--exit-code", <id>)
    )

  report-types = if-verbose2(
    ?term
    ; where(
        get-types
      ; iset-elements
      ; switch id
          case ?[] :
            !["  Cannot type ", term]
          case ?[t] :
            !["  Typed ", <write-to-string> term, " as ", <nonterm-to-string> t]
          otherwise:
            !["  Typed ", <write-to-string> term, " as one of ", <types-to-string>]
        end
     ; <fprintnl> (<stderr-stream>, <id>)
     )
   )
  
  report-type-failure(finally) =
    ?t
    ; where(
        <fprintnl> (<stderr-stream>, ["error: cannot type ", <write-to-string>])
      )
    ; if <one-consnil(id)> t then
        <fprintnl> (<stderr-stream>, ["    inferred types of subterms: "])
      ; <all-consnil(
          where(
            <fprintnl> (<stderr-stream>, ["    typed ", <write-to-string>, " as ", <retrieve-types; iset-elements; types-to-string>])
          )
        )> t
      else id end
    ; finally

  types-to-string =
    map(nonterm-to-string); separate-by(!", "); concat-strings

  nonterm-to-string :
    Int() -> "<int>"

  nonterm-to-string :
    String() -> "<string>"

  nonterm-to-string :
    Nonterm(s) -> s


strategies

  /**
   * @type  List(a) -> List(b)
   * @type  s List(a) -> b
   */
  map-consnil(s) =
    rec x({tail:
      ?[_ | tail]
    ; s
    ; ![<id> | <x> tail]
    <+ []
    })

  /**
   * bttomup variant that traverses lists as cons/nil.
   */
  bottomup-consnil(s) =
    rec x(all-consnil(x); s)

  /**
   * all variant that traverses lists as cons/nil.
   */
  all-consnil(s) = 
    is-list < ([s | s] + []) + all(s)

  /**
   * one variant that traverses lists as cons/nil.
   */
  one-consnil(s) = 
    is-list < ([s | id] + [id | s]) + one(s)
