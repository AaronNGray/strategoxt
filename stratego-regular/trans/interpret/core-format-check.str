/**
 * @todo  Support nested trees or extend normalizer to remove them.
 * @author  Martin Bravenboer <martin@cs.uu.nl>
 */
module core-format-check
imports liblib regular-options rtg rtg-util

strategies

  main-core-format-check =
    filter(not(?"-at-verbose"));
    io-wrap(core-fc-options,
        where(new-hashtable => tbl)
      ; where(new-iset => set)
      ; main-format-check(|tbl, set)
      ; where(output(id))
      ; <get-config> "--exit-code"
      ; exit
    )

  main-format-check(|tbl, set) =
      where(
        read-rtg-nf-config => rtg@RTG(Start(starts), _)
      ; generate-type-rules
      )
    ; format-check(|tbl, set)
    ; format-check-report(|<get-start-nonterms(!starts)>, tbl ,set)

  format-check-init =
    where(
      read-rtg-nf-config => rtg@RTG(Start(starts), _)
    ; generate-type-rules
    )

  core-fc-options =
      rtg-nf-option(|"Check against normalized RTG in file")
    + start-nonterm-option(|"Term must be of type s (default: start non-terms of rtg)")
    + fast-option(|"Run as fast as possible. Might reduce quality of error messages.")

  get-start-nonterms(default) =
    get-start-nonterm; ![Nonterm(<id>)] <+ default

strategies

  /**
   * Main format check traversal.
   *
   * The first alternatives reuses the result of previous
   * type checking. The size of the traversal is therefore the
   * size of the maximal shared tree.
   *
   * The second alternative tries to infer as many types
   * as possible, but at least one.
   *
   * If this fails, then the term is not in the right format.
   *
   * @type  starts  List(NonTerm)
   */
  format-check(|tbl, set) =
    where(
      <repeat(Type(|tbl, set))> ""
    ; <repeat(Type(|tbl, set))> 0
    )

    ; if-fast-mode(
        topdown(
          try(is-string; !"")
        ; try(is-int; !0)
        )
      )

    ; bottomup-consnil(
         where(get-types(|tbl, set))

      <+ repeat1(Type(|tbl, set))
         ; report-types(|tbl, set)

      <+ one-consnil(not(is-typed(|tbl, set)))

      <+ report-type-failure(id | tbl, set)
      )

  type-string(|tbl, set) =
    is-string; type-special(|"", tbl, set)

  type-int(|tbl, set) =
    is-int; type-special(|0, tbl, set)

  type-special(|special, tbl, set) =
    ?t
    ; where(
        <get-types(|tbl, set)> special => types
      ; <hashtable-put(|t, types)> tbl
      ; <map({type:
          ?type
        ; <iset-add(|(t, type))> set
        })> types
      )

  is-typed(|tbl, set) =
    where(get-types(|tbl, set) => [_ | _])

/**
 * Define type rules for the productions of an RTG.
 *
 * Type rules are defined in a dynamic rule 'UserType'.
 */
strategies

  /**
   * Generate format checking dynamic rules for an RTG
   *
   * @type  RTG -> _
   */
  generate-type-rules =
      ungroup-productions
    ; ?RTG(Start(_), ProdRules(<id>))
    ; map(generate-type-rule <+ debug(!"internal error: cannot create type rule for "); fail)

  /**
   * Injection
   */
  generate-type-rule =
    ?ProdRule(b, [Ref(a)])
    ; rules(
        InjUserType(|tbl, set) :+ t -> t
        where
            <has-type(|a, tbl, set)> t
          ; <not(has-type(|b, tbl, set))> t
          ; <set-type(|b, tbl, set)> t
      )

  /**
   * Cons application
   */
  generate-type-rule =
    ?ProdRule(c, [Appl(ConsTerm(), [Ref(a), Ref(b)])])
    ; rules(
        ListUserType(|tbl, set) :+ t@[hd | tl] -> t
        where
            <has-type(|b, tbl, set)> tl
          ; <not(has-type(|c, tbl, set))> t
          ; <has-type(|a, tbl, set)> hd
          ; <set-type(|c, tbl, set)> t
      )

  /**
   * Conc application
   */
  generate-type-rule =
    ?ProdRule(c, [Appl(ConcTerm(), [Ref(a), Ref(b)])])
    ; rules(
        ListUserType(|tbl, set) :+ t@Conc(t1, t2) -> t
        where
            <has-type(|a, tbl, set)> t1
          ; <has-type(|b, tbl, set)> t2
          ; <new-type(|c, tbl, set)> t
      )

  /**
   * Nil application
   */
  generate-type-rule =
    ?ProdRule(a, [Appl(NilTerm(), [])])
    ; rules(
        ListUserType(|tbl, set) :+ [] -> []
        where
          <new-type(|a, tbl, set)> []
      )

  /**
   * Some application
   */
  generate-type-rule =
    ?ProdRule(b, [Appl(SomeTerm(), [Ref(a)])])
    ; rules(
        OptUserType(|tbl, set) :+ Some(t) -> Some(t)
        where
            <has-type(|a, tbl, set)> t
          ; <new-type(|b, tbl, set)> Some(t)
      )

  /**
   * None application
   */
  generate-type-rule =
    ?ProdRule(a, [Appl(NoneTerm(), [])])
    ; rules(
        OptUserType(|tbl, set) :+ None() -> None()
        where
          <new-type(|a, tbl, set)> None()
      )

  /**
   * Tuple application
   */
  generate-type-rule =
    ?ProdRule(a, [Appl(TupleTerm(_), as)])
    ; where(<map(?Ref(<id>))> as => arg-types)
    ; rules(
        TupleUserType(|tbl, set) :+ t@""#(args) -> t
        where
          <not(has-type(|a, tbl, set))> t
          ; <list-has-type(|arg-types, tbl, set)> args
          ; <set-type(|a, tbl, set)> t
      )

  /**
   * User-defined terminal application
   */
  generate-type-rule =
    ?ProdRule(a, [Appl(Term(f), as)])
    ; where(<map(?Ref(<id>))> as => arg-types)
    ; rules(
        ApplUserType(|tbl, set) :+ t@f#(args) -> t
        where
            <not(has-type(|a, tbl, set))> t
          ; <list-has-type(|arg-types, tbl, set)> args
          ; <set-type(|a, tbl, set)> t
      )

  /**
   * @type  List(_) -> _
   * @type  as  List(NonTerm)
   */
  list-has-type(|as, tbl, set) =
    if ?[] then
      !as => []
    else
      ?[hd | tl]
    ; where(
        !as => [a | bs]
      ; <has-type(|a, tbl, set)> hd
      ; <list-has-type(|bs, tbl, set)> tl
      )
    end

/**
 * Type types a term.
 */
strategies

  Type(|tbl, set) =
    where(
      StandardType(|tbl, set)
    + InjUserType(|tbl, set)
    + ApplUserType(|tbl, set)
    + TupleUserType(|tbl, set)
    + ListUserType(|tbl, set)
    + OptUserType(|tbl, set)
    )

  StandardType(|tbl, set) =
    is-int
    ; new-type(|Int(), tbl, set)

  StandardType(|tbl, set) =
    is-string
    ; new-type(|String(), tbl, set)

strategies

  /**
   * Fails if t already has type nt
   *
   * @type  t -> t
   */
  new-type(|nt, tbl, set) =
    ?term
    ; where(
        not(has-type(|nt, tbl, set))
      ; <hashtable-push(|term, nt)> tbl
      ; <iset-add(|(term, nt))> set
      )

  set-type(|nt, tbl, set) =
    ?term
    ; where(
        <hashtable-push(|term, nt)> tbl
      ; <iset-add(|(term, nt))> set
      )
    
  /**
   * Succeeds if t has type nt
   *
   * @type  t -> t
   */
  has-type(|nt, tbl, set) =
    ?term
    ; not(is-string + is-int)
    ; where(
        <iset-contains(|(term, nt))> set
      )

  has-type(|nt, tbl, set) =
    is-int
    ; where(<iset-contains(|(0, nt))> set)

  has-type(|nt, tbl, set) =
    is-string
    ; where(<iset-contains(|("", nt))> set)

  retrieve-types(|tbl, set) =
    get-types(|tbl, set)
    <+ ?t
       ; where(
           <hashtable-put(|t, [])> tbl
         )
       ; ![]

  get-types(|tbl, set) =
    ?t
    ; not(is-string + is-int)
    ; <hashtable-get(|t)> tbl

  get-types(|tbl, set) =
    is-int
    ; <hashtable-get(|0)> tbl

  get-types(|tbl, set) =
    is-string
    ; <hashtable-get(|"")> tbl

/**
 * Reporting
 */
strategies

 format-check-report(|starts, tbl, set) =
    where(
     (get-types(|tbl, set) <+ ![]) => types
    ; if !types => [] then
        !1 // already reported <fatal-error> ["error: term cannot be typed."]
      else
          <isect> (starts, <id>)
        ; if ?[] then
	    if-verbose1(
              <fprintnl> (<stderr-stream>,
                ["error: term typed as ", <types-to-string> types, 
                 " but expected ", <types-to-string> starts])
            )
            ; !1
          else
            if-verbose2(
              <types-to-string; debug(!"info: term typed as ")> types
            )
            ; !0
          end
      end
    ; <set-config> ("--exit-code", <id>)
    )

  report-types(|tbl, set) = if-verbose2(
    ?term
    ; where(
        get-types(|tbl, set)
      ; switch id
          case ?[] :
            !["  Cannot type ", term]
          case ?[t] :
            !["  Typed ", <write-to-string> term, " as ", <nonterm-to-string> t]
          otherwise:
            !["  Typed ", <write-to-string> term, " as one of ", <types-to-string>]
        end
     ; <fprintnl> (<stderr-stream>, <id>)
     )
   )
  
  report-type-failure(finally | tbl, set) =
    ?t
    ; where(
        <fprintnl> (<stderr-stream>, ["error: cannot type ", <write-to-string>])
      )
    ; if <one-consnil(id)> t then
        <fprintnl> (<stderr-stream>, ["    inferred types of subterms: "])
      ; <all-consnil(
          where(
            <fprintnl> (<stderr-stream>, ["    typed ", <write-to-string>, " as ", <retrieve-types(|tbl, set); types-to-string>])
          )
        )> t
      else id end
    ; finally

  types-to-string =
    map(nonterm-to-string); separate-by(!", "); concat-strings

  nonterm-to-string :
    Int() -> "<int>"

  nonterm-to-string :
    String() -> "<string>"

  nonterm-to-string :
    Nonterm(s) -> s


strategies

  /**
   * @type  List(a) -> List(b)
   * @type  s List(a) -> b
   */
  map-consnil(s) =
    rec x({tail:
      ?[_ | tail]
    ; s
    ; ![<id> | <x> tail]
    <+ []
    })

  /**
   * bttomup variant that traverses lists as cons/nil.
   */
  bottomup-consnil(s) =
    rec x(all-consnil(x); s)

  /**
   * all variant that traverses lists as cons/nil.
   */
  all-consnil(s) = 
    is-list < ([s | s] + []) + all(s)

  /**
   * one variant that traverses lists as cons/nil.
   */
  one-consnil(s) = 
    is-list < ([s | id] + [id | s]) + one(s)
