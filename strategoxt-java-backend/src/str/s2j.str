/**
 * Java backend for the Stratego compiler
 *
 * @author Karl Trygve Kalleberg
 * @author Lennart Kats
 * @author Eelco Visser
 */
module s2j

imports
  libstrc
  libstratego-xtc
  libstratego-rtg
  libstratego-lib

  java-postprocess
  variable-lifting
  variable-access
  
  Java-EBlock

signature
  constructors 
    Next  : Term
    Match : Term * Exp -> Exp
    Filename : Str -> Term
    Offset: Int -> Term
    Frames: List(Term) -> Term

overlays

  MAX_STATIC_TARGS = 5
  MAX_STATIC_SARGS = 3
    
strategies

  io-s2j = io-wrap(java-backend)
 
rules
 
  fc =
    id
    /*
    with(
      verbosity => oldverbosity
    ; <set-verbosity> 1
    )
  ; with(
      rtg-format-check(true, true|<JavaRTG>)
    ; <set-verbosity> oldverbosity
    | "Internal error: resulting term is not well-formed"
    )
    */
    
  java-backend = 
      rules(JavaRTG := <import-term(Java-15.rtg.af)>)
    ; extract-meta
    ; java-compile-spec
    ; java-simplify
    ; java-relabel
     
  extract-meta = 
     ?_{Meta(metas)}
    ; rules(Metas := metas)
  
  meta-filename = 
      Metas
    ; getfirst(?Filename(<id>))

  compute-classname = 
      meta-filename 
    ; base-filename
    ; jify
    ; remove-extension
  
  jify =
    string-replace(|"-", "_")
  ; string-replace(|"'", "_q_")
    
  java-compile-spec :
    Specification([Signature([Constructors(ops)]), Strategies(defs)]) -> 
     |[ 
     package pkgname;
     
     import org.strategoxt.lang._Id; 
     import org.strategoxt.lang._Fail; 
     import org.strategoxt.lang.SRTS_all; 
     import org.strategoxt.lang.SRTS_one; 
     import org.strategoxt.lang.SRTS_some; 
     import org.strategoxt.lang.Strategy; 
     import org.strategoxt.lang.IStrategy;
     import org.strategoxt.lang.TermReference; 
     import org.strategoxt.lang.ITermReference; 
     import org.strategoxt.lang.Context;
     import org.spoofax.interpreter.terms.*;
         
     import static org.strategoxt.lang.Term.checkTermList;
     
     // TODO: Use static imports for libraries
     //       e.g., import static org.strategoxt.strategolib.*;
         
     @SuppressWarnings({"unused", "cast"})
     public class x_name {

     static ITermFactory constantFactory;
     ~*cnst-decls
     ~*cnstr-decls
     ~*lifted-defs
     
     // TODO: Add a switch to always enable stack traces
     private static boolean TRACES_ENABLED = x_name.class.desiredAssertionStatus();
     
     public static void preInit(ITermFactory termFactory) {
       constantFactory = termFactory;
       ~*cnstr-inits
       ~*cnst-inits
     }

     public static String testMain(String input) {
        Context context = new Context();
        preInit(context.getFactory());
        IStrategoTerm result = main_0_0.instance.invoke(context, context.getFactory().parseFromString(input));
        return result == null ? null : result.toString();
     }
        
     public static void main(String args[]) {
        Context context = new Context();
        preInit(context.getFactory());
        IStrategoTerm result = context.invokeStrategyCLI(main_0_0.instance, "~x_name", args);
        if (result == null) {
          System.err.println("~x_name" + (TRACES_ENABLED ? ": rewriting failed, trace:" : ": rewriting failed"));
          context.getStackTracer().printStackTrace();
          System.exit(1); 
        } else {
          System.out.println(result);
        }
     }
     
     private static IStrategoTerm getConstant(ITermFactory factory, IStrategoTerm constant) {
         if (factory == constantFactory) {
           return constant;
         } else if (factory != null) {
           return new TermConverter(factory).convert(constant);
         } else {
           throw new IllegalStateException("Component not initialized; please call preinit() first");
         }
     }

     ~*function-defs

     }
     ]|
  with 
      alltd(JavaTranslate)
    ; x_name        := <compute-classname> ()
    ; pkgname       := PackageName([Id("org.strategoxt.compiler.tests.cases")])
    ; function-defs := <map(translate-outer-definition)> defs
    ; lifted-defs   := <bagof-Fragment> "LiftedDef"
    ; cnstr-decls   := <bagof-Fragment> "ConstructorDecl"
    ; cnstr-inits   := <bagof-Fragment; concat> "ConstructorInit"
    ; cnst-decls    := <bagof-Fragment> "ConstDecl"
    ; cnst-inits    := <bagof-Fragment; concat; reverse> "ConstInit"

rules
  
  translate-outer-definition :
    SDefT(x, strats*, terms*, s) -> type-dec |[
       public static class x extends Strategy {
         public static x instance = new x();
         
         ~body
         
         // TODO: Implement invokeDynamic() as necessary
         //
         //  public IStrategoTerm invokeDynamic(Context context, IStrategoTerm term, IStrategy[] sargs,
         //    IStrategoTerm[] targs) {
       }
    ]|
    with
      body := <translate-definition-body>

  translate-inner-definition :
    SDefT(x, strats*, terms*, s) -> type-dec |[
       private static final class x extends Strategy {
         ~instance-field*
         ~lifted-tfield*
         ~lifted-sfield*
         
         ~constructor*
         
         ~body
       }
    ]|
    with
      lifted-tvar*   := <collect-lifted-tvars>
    with
      lifted-svar*   := <collect-lifted-svars>
    ; lifted-tfield* := <map(\x -> |[ private final ITermReference x; ]|\)> lifted-tvar*
    ; lifted-sfield* := <map(\x -> |[ private final IStrategy x;      ]|\)> lifted-svar*
    ; lifted-args    := <conc> (lifted-svar*, lifted-tvar*)
    ; x'             := x{}
    ; rules(LiftedArgs: x' -> lifted-args)
    with
      if !lifted-tvar* => lifted-svar* => [] then
        instance-field* := class-body-dec* |[ public static final x instance = new x(); ]|
      ; constructor*    := []
      else
        instance-field* := []
      ; constructor*    := [<lifted-vars-to-constructor(|x)> (lifted-svar*, lifted-tvar*)]
      end
    with
      body := <translate-definition-body>
  
  translate-definition-body :
    SDefT(x, strats*, terms*, s) ->
    |[ mod_override*
       public IStrategoTerm invoke(Context context, IStrategoTerm term, param*) {
           ITermFactory termFactory = context.getFactory();
           if (TRACES_ENABLED) context.getStackTracer().push("~x");
           Fail: {
             bstm
             if (TRACES_ENABLED) context.getStackTracer().popOnSuccess();
             if (true) // (avoid unreachable stm error)
               return term;
           };
           if (TRACES_ENABLED) context.getStackTracer().popOnFailure();
           return null;
       }
    ]|
    with
      bstm    := <translate-body> s   
    ; strats' := <map(translate-parameter)> strats*
    ; terms'  := <map(translate-parameter)> terms*
    ; param*  := <conc> (strats', terms')   
    ; if is-dynamic-signature(|strats*, terms*) then
        mod_override* := []
      else
        mod_override* := [ anno |[ @Override ]| ]
      end
  
  translate-outer-definition :
    ExtSDef(_, _, _) -> Semicolon()

  translate-parameter :
    VarDec(x, ConstType(_)) -> param |[ IStrategoTerm x ]|
  
  translate-parameter : 
    VarDec(x, FunType(_, _)) -> param |[ IStrategy x ]|
  
strategies
  
  /** @type Strategy -> Stm */
  translate-body = 
    translate-strategy

  translation-failed = ?x#(_) ; log(|Error(), [ "Unknown constructor type ", x ]) ; fail
  
  translate-Scope : 
    Scope(vars, body) -> bstm |[ { bstm_decl* bstm_body } ]|
    with
      bstm_decl* := <map(to-java-vardecl)> vars
    ; bstm_body  := <translate-strategy> body
    
  /** @type Id -> Stm */
  translate-Id :
    Id() -> Empty()
    
  /** @type Id -> Stm */
  translate-Fail :
    Fail() -> |[ if (true) break Fail; ]| // (avoid unreachable stm error)

  /** @type Seq -> Stm */
  translate-Seq :
    Seq(s1, s2) -> 
    bstm |[
      { 
        ~stm:<translate-strategy> s1 
        ~stm:<translate-strategy> s2 
      } 
    ]|

  /** @type GuardedLChoice -> Block */  
  translate-UnguardedLChoice :
    GuardedLChoice(s1, Id(), s2) ->
    Block(bstm* |[
      IStrategoTerm x_termcopy = term;
      Success: {
        Fail: {
           stm_s1
           break Success;
        }
        term = x_termcopy;
        stm_s2
      }
    ]|)
   with x_termcopy := <newname> "term"
     ; stm_s1 := <translate-strategy> s1
     ; stm_s2 := <translate-strategy> s2

  /** @type GuardedLChoice -> Block */  
  translate-GuardedLChoice :
    GuardedLChoice(s1, s2, s3) ->
    Block(bstm* |[
      IStrategoTerm x_termcopy = term;
      Success: {
        Fail: {
           stm_s1
           OuterFail: {
             stm_s2
             if (true) break Success; // (avoid unreachable stm error)
           }
        }
        term = x_termcopy;
        stm_s3
      }
    ]|)
   with x_termcopy := <newname> "term"
     ; stm_s1 := <translate-strategy> s1
     ; stm_s2 := <translate-strategy> s2
     ; stm_s3 := <translate-strategy> s3

  translate-strategy = 
       ( 
       translate-CallT-tail-call ; fc
    <+ translate-CallT ; fc
    <+ translate-Build ; fc
    <+ translate-Seq ; fc
    <+ translate-PrimT ; fc
    <+ translate-Id ; fc
    <+ translate-Fail ; fc
    <+ translate-UnguardedLChoice ; fc
    <+ translate-GuardedLChoice ; fc
    <+ translate-Scope ; fc
    <+ translate-Match ; fc
    <+ translate-Let; fc
    <+ say(!"translate-strategy failed "); fail // ensures stack trace is cut off
       )

  translate-Let : 
    Let(defs, body) -> Block([body'])
    with
      <map(fragment(translate-inner-definition | "LiftedDef"))> defs
    ; body' := <translate-strategy> body

  translate-CallT:
    CallT(SVar(x), s*, t*) -> bstm |[
      { term = e_instance.invoke(context, term, e_s*, e_t*);
        if (term == null) 
          break Fail;
      }
    ]|
    with
      e_instance := <lifted-call-to-instance>
    ; e_s*       := <map(lifted-strategy-to-instance)> s*
    ; e_t*       := <map(java-construct-term)> t*

  translate-CallT-tail-call :
    CallT(SVar(x), s*, t*) -> bstm |[
      { term = invoke(context, term, e_s*, e_t*);
        if (term == null) 
          break Fail;
      }
    ]|
    where
      <is-tail-call> x
    with
      e_s*  := <map(lifted-strategy-to-instance)> s*
    ; e_t*  := <map(java-construct-term)> t*
  
  lifted-strategy-to-instance =
    if ?CallT(_, _, _) then
      // Pass (potentially parameterizable) svar calls as-is
      lifted-call-to-instance
    else
      // Lift definition and produce call
      with(
        !SDefT(<newname => x> "jlifted", [], [], <id>)
      ; fragment(translate-inner-definition | "LiftedDef")
      //; debug(!"LIFTED: ")
      )
    ; <lifted-call-to-instance> CallT(SVar(x), [], [])
    end
  
  lifted-call-to-instance =
    lifted-call-to-instance-with-args
  <+
    lifted-call-to-instance-tail-call
  <+
    debug;
    lifted-call-to-instance-instance
  <+
    lifted-call-to-instance-direct
  
  lifted-call-to-instance-with-args :
    CallT(SVar(x), _, _) ->  |[ new x(e_arg*) ]|
    where
      lifted-arg* := <LiftedArgs> x{} // set for local defs
    ; !lifted-arg* => [_ | _]         // local def with lifting
    with
      e_arg* := <map(\x -> expr |[ x ]|\)> lifted-arg*
  
  lifted-call-to-instance-tail-call :
    CallT(SVar(x{}), _, _) -> expr |[ this ]|
    where
      fail // TODO
  
  // /*
  lifted-call-to-instance-direct :
    CallT(SVar(x{}), _, _) -> expr |[ x.instance ]|
  
  lifted-call-to-instance-direct :
    CallT(SVar(x{Frames([])}), _, _) ->  expr |[ x ]| // local def
  
  lifted-call-to-instance-direct :
    CallT(SVar(x{Offset(_), Frames([])}), _, _) ->  expr |[ x ]|
  
  lifted-call-to-instance-direct :
    CallT(SVar(x{Frames([_ | _])}), _, _) ->  expr |[ x.instance ]| // global def
  
  lifted-call-to-instance-direct :
    CallT(SVar(x{Frames([]), ApplyClosure()}), _, _) ->  expr |[ x ]| // local def
  
  lifted-call-to-instance-direct :
    CallT(SVar(x{Offset(_), Closure(c), Frames(_)}), _, _) ->  expr |[ x ]|
    where
      <eq> (x{}, c)
  
  lifted-call-to-instance-direct :
    CallT(SVar(x{Offset(_), Closure(c), Frames(_)}), _, _) ->  expr |[ x.instance ]|
    where
      not(<eq> (x{}, c))
  
  lifted-call-to-instance-direct :
    CallT(SVar(x{Closure(c), Frames(_)}), _, _) ->  expr |[ x ]|
    where
      <eq> (x{}, c)
  
  lifted-call-to-instance-direct :
    CallT(SVar(x{Closure(c), Frames(_)}), _, _) ->  expr |[ x.instance ]|
    where
      not(<eq> (x{}, c))
  
  lifted-call-to-instance-instance :
    CallT(SVar(x{Offset(_), Frames(_), ApplyClosure()}), _, _) -> |[ x ]| // local def
  // */

  /*
  lifted-call-to-instance-instance :
    CallT(SVar(x{a*}), _, _) -> expr |[ x.instance ]|
    where
      !a*
    ; one(?Frames([_ | _]))
    ; not(one(?ApplyClosure()))
    <+
      !a*
    ; one(?Closure(_))

  lifted-call-to-instance-direct :
    CallT(SVar(x), _, _) -> expr |[ x ]|
  */
  
  is-dynamic-signature(|s*, t*) =
    where(
      <gt> (<length> s*, MAX_STATIC_SARGS());
      <gt> (<length> t*, MAX_STATIC_TARGS())
    )

  translate-PrimT :
    PrimT(f, s*, t*) -> 
    <java-check-unbound-args(|t*)>  
    Block(bstm* |[ 
      term = context.invokePrimitive("~f", term, new IStrategy[] { e_s* }, new IStrategoTerm[] { e_t* });
      if (term == null) break Fail;
    ]|)
  with
    e_s*  := <map(lifted-strategy-to-instance)> s*
  ; e_t*  := <map(java-construct-term)> t*
  
/* ================================ Build  */

  translate-Build:
    Build(t) -> 
    <java-check-unbound-args(|t)> 
    Block(bstm*|[
               ~*decs
               ~*stms
               term = e;
               ]|)
  where {| java-CheckList :
         <java-construct-term> t => e
       ; bagof-java-CheckList; unzip; (id, reverse; concat) => (decs, stms)
      |} 

  java-check-unbound-args(|t) =
    try(java-CheckUnboundArgs(|t))

  java-CheckUnboundArgs(|t) :
    stm -> 
    stm|[ {
      if (e)
        break Fail;
      stm
    } ]|
    where
      <collect({?Var(_){t*}; where(<not(["bound"])> t* )})> t
    ; not([])
    ; foldr1(!expr|[ ~expr:<Hd; java-ConstructVar> == null ]|
            ,!expr|[ ~expr:<Fst; java-ConstructVar> == null || ~expr:<Snd> ]|) => e

/**
 * Term construction with constant term caching
 */
rules 

  /*
  java-init-term-caching =
    where(
         t1 := Op("Nil", [])
       ; t2 := Anno(Op("Nil", []), Op("Nil", []))
       ; e  := expr|[ termFactory.makeList() ]|
    )
    ; rules( java-Cache : t1 -> e )
    ; rules( java-Cache : t2 -> e )
  */

  /** @type Term -> Exp */
  java-construct-term =
       java-Cache 
    <+ java-ConstructAnnoVar
    <+ java-ConstructVar
    <+ !(<id>, <java-ConstructTerm>)
       ; (java-CacheConstant <+ Snd)

  java-CacheConstant :
    (t, e1) -> |[ getConstant(termFactory, e2) ]|
  where
      <(Op(id, map(java-Cache)); java-proper-list 
            + Anno(java-Cache, java-Cache) 
            + Int(id) + Str(id) + Real(id) )> t
  with
        x  := <newname> "constant"
      ; e2 := ExprName(Id(x))
      ; rules( java-Cache : t -> |[ getConstant(termFactory, e2) ]| )
      ; !(x, e1)
      ; fragment(java-DeclareTermId|"ConstDecl")
      ; fragment(java-InitTermId|"ConstInit")

 java-proper-list =
    Op("Nil", [])
    + Op("Cons", [id, java-proper-list + ExprName(id)])
    + Op(id, id)
      ; not(is-ListOp)

// helpers

strategies
    
  is-TupleOp = ?Op("", _)

  java-DeclareTermId :
    (x, e) ->
    class-body-dec|[ static IStrategoTerm ~<!Id(x)>; ]|

  java-InitTermId :
    (x, e) -> bstm*|[ x = e; ]|

  java-mk-int-const =
    !Lit(Deci(<try(int-to-string)>))

rules

  java-ConstructTerm :
    Int(i) -> 
    expr|[ 
      termFactory.makeInt(~expr:<java-mk-int-const> i)
    ]|

  java-ConstructTerm :
    Real(x) -> 
    expr|[ 
      termFactory.makeReal(~expr:Lit(Float(<try(real-to-string)> x)))
    ]|

  java-ConstructTerm :
    Str(x) -> 
    expr|[ 
      termFactory.makeString(~expr:Lit(String([Chars(<escape> x)])))
    ]|

  java-ConstructVar :
    x@Var(_) -> e
  with 
      e := <java-VarToReadRef> x

  java-ConstructAnnoVar :
    Anno(Var(x), pt2) -> 
    expr|[ 
      termFactory.annotateTerm(e, ~expr:<java-construct-term> pt2)
    ]|
  where
      <java-ConstructVar> Var(x) => e

  java-ConstructTerm :
    Anno(pt1, Op("Nil", [])) -> <java-construct-term> pt1
  where 
      <not(?Var(_))> pt1

  java-ConstructTerm :
    Anno(pt1, pt2) -> 
    expr|[ 
      termFactory.annotateTerm(~expr:<java-construct-term> pt1, (IStrategoList) ~expr:<java-construct-term> pt2)
    ]|
  where 
      <not(?Op("Nil", []))> pt2
    ; <not(?Var(_))> pt1

//  java-ConstructTerm :
//    |[ _ t ]| -> <java-construct-term> t

  java-ConstructTerm :
    Op(c, t*) -> expr|[ termFactory.makeAppl(~*[cn | args]) ]|
  where
      not(is-ListOp + is-TupleOp)
  with
      cn   := ExprName(Id(<java-ConstructorName> (c, <length> t*)))
    ; args := <map(java-construct-term)> t*
    
  java-ConstructTerm :
    Explode(t1, t2) -> 
    expr|[
      context.invokePrimitive("SSL_mkterm", term,
                              new IStrategy[] {},
                              new IStrategoTerm[] { e_t1, e_t2 })
    ]|
    with
      e_t1 := <java-construct-term> t1
    ; e_t2 := <java-construct-term> t2

  java-ConstructTerm : 
    Op("", args) -> expr|[ termFactory.makeTuple(~*args') ]|
    with
      args' := <map(java-construct-term)> args
    
  java-ConstructTerm :
    Op("Nil", []) -> expr|[ termFactory.makeList() ]|

  java-ConstructTerm :
    Op("Cons", [t1, t2]) -> 
    expr|[ 
      termFactory.makeList(~expr:<java-construct-term> t1, (IStrategoList) e)
    ]|
  with
      <java-construct-term> t2
        ; if <not(Anno(is-ListOp,id))> t2 then 
            java-check-aterm-list 
          else
              if ?Id(_) then
                !|[ (IStrategoList) ~expr:<id> ]|
              else
                try(java-UncastATerm)
              end
              ; try(java-CastATermListSetAnnotations)
            end => e

  java-check-aterm-list :
    e -> expr|[ (IStrategoList) x ]|
  where 
      x := <newname> "list"
    ; stms := 
         ( bstm |[ IStrategoList x; ]|
         , bstm*|[
             x = checkTermList(e);
             if (x == null) break Fail;
           ]|)
    ; rules( java-CheckList :+ _ -> stms )

  java-CastATerm :
    e -> expr|[ (IStrategoTerm) ~expr:e ]|

  java-CastATermListSetAnnotations :
    expr|[                 termFactory.annotateTerm(~expr:e1, (IStrategoList) ~expr:e2) ]| ->
    expr|[ (IStrategoList) termFactory.annotateTerm(~expr:e1, (IStrategoList) ~expr:e2) ]|

  java-UncastATerm :
    expr|[ (IStrategoTerm)~expr:e ]| -> e
    
/**
 * Signatures
 */
strategies

  JavaTranslate =
      fragment(JavaDeclareConstructor|"ConstructorDecl")
    ; fragment(JavaInitConstructorQ <+ JavaInitConstructor|"ConstructorInit")

  JavaDeclareConstructor :
    OpDecl(c, t) -> class-body-dec|[ static IStrategoConstructor ~id:Id(csym); ]|
  where
    <not("" + "Cons" + "Nil")> c
  with 
      n    := <Arity> t
    ; csym := <concat-strings> ["sym_", <cify> c, "_", <int-to-string> n]
    ; rules(java-ConstructorName : (c, n) -> csym)

  JavaInitConstructorQ :
    OpDecl(c, t) ->
    bstm*|[
      ~id:csym = ATmakeSymbol(~expr:Lit(String([Chars(<double-quote> c')])), 
                              ~expr:<java-mk-int-const> ar,
                              ATtrue);
    ]|
  where 
      <string-as-chars(unescape-chars; un-double-quote-chars)> c => c' 
    ; ar   := <Arity> t
    ; csym := <java-ConstructorName> (c, ar)

  JavaInitConstructor :
    OpDecl(c, t) ->
    bstm*|[
      ~id:csym = termFactory.makeConstructor(~expr:Lit(String([Chars(c)])), 
                                             ~expr:<java-mk-int-const> ar);
    ]|
  where 
      ar   := <Arity> t
    ; csym := Id(<java-ConstructorName> (c, ar))

/* ================================ Match */
strategies

  translate-Match :
    Match(t) -> result
    with
      result := <translate-Match> Match(t, ExprName(Id("term")))

  translate-Match :
    Match(Wld(), trm) -> Empty()

  translate-Match :
    Match(As(t1,t2), trm) ->
    stm|[ 
      { 
        stm_match1
        stm_match2
      }
    ]|
  with stm_match1 := <translate-Match> Match(t1,trm)
     ; stm_match2 := <translate-Match> Match(t2,trm)

  translate-Match :
    Match(Var(x){"unbound"}, trm) -> stm_assign
    with
      stm_assign := <java-VarToWrite> (x, trm)

  translate-Match :
    Match(Var(x){"bound"}, trm) ->
    stm|[ 
      if(!e.equals(~expr:trm)) 
        break Fail;
     ]|
    with
      e := <java-VarToReadRef> Var(x)

  translate-Match :
    Match(Var(x){"(un)bound"}, e) ->
    stm|[ 
      if (e_x == null)
        stm_assign
      else if (!e_x.equals(e))
        break Fail;
    ]|
    with 
      e_x := <java-VarToReadRef> Var(x)
    ; stm_assign := <java-VarToWrite> (x, e)

  translate-Match :
    Match(Var(x){}, trm) -> <translate-Match> Match(Var(x){"(un)bound"}, trm)

  translate-Match :
    Match(Explode(t1, t2), e) ->
    stm|[ 
    {
      IStrategoTerm x_cons = context.invokePrimitive("SSL_get_constructor", term,
                                                      new IStrategy[] {},
                                                      new IStrategoTerm[] { e });
      ~stm:(<translate-Match> Match(t1, ExprName(Id(x_cons))))
      IStrategoTerm x_args = context.invokePrimitive("SSL_get_arguments", term,
                                                     new IStrategy[] {},
                                                     new IStrategoTerm[] { e });
      ~stm:(<translate-Match> Match(t2, ExprName(Id(x_cons))))
     } ]|
  with
      !e => ExprName(Id(_))
    ; x_cons := <newname> "cons"
    ; x_args := <newname> "args"

  translate-Match =
       ( translate-MatchNoAnno
      <+ translate-MatchAnno )

  translate-MatchNoAnno :
    Match(Anno(pt1, Wld()), e) -> result
    with result := <translate-Match> Match(pt1, e)

  translate-MatchAnno :
    Match(Anno(pt1, pt2), e) -> 
    stm|[ 
      { 
        stm0
        IStrategoList x = e.getAnnotations();
        stm1
      } 
    ]|
  where 
      <not(Wld)> pt2
  with
      x    := <newname> "annos"
    ; stm0 := <translate-Match> Match(pt1, e)
    ; stm1 := <translate-Match> Match(pt2, ExprName(Id(x)))

  /**
   * @todo  String constants should probably be cached, just like constructor names
   */
  translate-Match :
    Match(Str(str), e) -> 
    stm|[
      if (e.getTermType() != IStrategoTerm.STRING
         || !e_str.equals(((IStrategoString) e).stringValue()))
        break Fail;
    ]|
  with
      !e => ExprName(Id(_))
    ; e_str := Lit(String([Chars(<escape> str)]))

  translate-Match :
    Match(Int(i), e) -> 
    stm|[
      if (e.getTermType() != IStrategoTerm.INT
         || e_int != ((IStrategoInt) e).intValue())
        break Fail;
    ]|
  with
      !e => ExprName(Id(_))
    ; e_int := <java-mk-int-const> i

  translate-Match :
    Match(Real(r), e) -> 
    stm|[
      if (e.getTermType() != IStrategoTerm.REAL 
          || e_real != ((IStrategoReal) e).realValue())
        break Fail;
    ]|
  with
      !e => ExprName(Id(_))
    ; e_real := Lit(Float(<try(real-to-string)> r))

  /**
   * Translate a match of an Op, but not a Cons/2 , Nil/0, or tuple.
   */
  translate-Match :
    Match(op@Op(c, ts), e) ->
    stm|[ {
      if (e.getTermType() != IStrategoTerm.APPL || !((IStrategoAppl) e).getConstructor().equals(x_cons))
        break Fail;
      ~bstm*:match-args
    } ]|
  where
    <not(is-ListOp + is-TupleOp)> op
  with
    x_cons := <java-ConstructorName> (c, <length> ts)
  <+
    <fatal-err(|"Undeclared constructor")> (c, <length> ts)
  with
    match-args := <translate-Match-args> (e, ts)

  /**
   * Translate a match of an Op, but not a Cons/2 or Nil/0.
   */
  translate-Match :
    Match(op@Op(c, ts), e) ->
    stm|[ {
      if (e.getTermType() != IStrategoTerm.TUPLE || e.getSubtermCount() != i)
        break Fail;
      ~bstm*:match-args
    } ]|
  where
    <is-TupleOp> op
  with
    i:= <write-to-string> <length> ts
  ; match-args := <translate-Match-args> (e, ts)
  
  translate-Match-args :
    (e, terms) -> bstm_matcharg*
    with
      (bstm_matcharg*, _) :=
        <thread-map(\ (t,i) -> (
               <java-MatchArg1 <+ java-MatchArg2> 
                  (t, expr|[ e.getSubterm(~expr:<java-mk-int-const> i) ]|)
             , <add>(i, 1)
             )
           \ )> (terms,0)

  java-MatchArg1 : 
    (Var(x){t*}, e) -> result
  with 
      result := <translate-Match> Match(Var(x){t*}, e)

  java-MatchArg2 : 
    (t, e) -> 
    stm|[ 
      { 
         IStrategoTerm x = e; 
         stm
      } 
    ]|
  with
      x   := <newname> "arg"
    ; stm := <translate-Match> Match(t, ExprName(Id(x)))

  translate-Match :
    Match(Op("Nil", []), e) ->
    stm|[
      if (e.getTermType() != IStrategoTerm.LIST || !((IStrategoList) e).isEmpty())
        break Fail;
    ]|

  translate-Match :
    Match(Op("Cons", [hd, tl]), e) ->
    stm|[ {
      if (e.getTermType() != IStrategoTerm.LIST || ((IStrategoList) e).isEmpty())
          break Fail;
      ~bstm*:match-args
    } ]|
  with 
    <map(java-MatchArg1 <+ java-MatchArg2)> 
       [ (hd, expr|[ ((IStrategoList) e).head() ]|)
       , (tl, expr|[ ((IStrategoList) e).tail() ]|) ] => match-args
