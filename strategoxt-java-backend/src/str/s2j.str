/**
 * Java backend for the Stratego compiler
 *
 * @author Karl Trygve Kalleberg
 */
module s2j
imports 
  Stratego-Core 
  libstratego-lib
  Java-15 
  Java-EBlock 

signature
  constructors 
    Match : a * a -> a
    Next : Term
    
strategies

  io-s2j = io-wrap(compile-spec)
 
rules
 
  compile-spec :
    Specification([Signature([Constructors(ops)]), Strategies(defs)]) -> 
     |[ 
     import aterm.ATerm;
	 import aterm.AFun;
     
     import org.strategoxt.core.Runtime;
     import org.strategoxt.core.Strategy; 
     import org.strategoxt.core.Failure;
         
     import static org.strategoxt.core.Runtime.atermFactory;
     import static org.strategoxt.core.Term.nonNull;
     		
     public class Main {

	 public static void main(String args[]) {
        ATerm term = main_0_0.instance.apply(Runtime.prepareCLIArgs(args));
        if(term == null) { 
          System.err.println("Rewriting failed!"); 
          System.exit(1); 
        }
        else { System.out.println(term); }
	 }

     ~*function-defs

     }
     ]|
     where 
       <map(translate-definition)> defs => function-defs

rules
  translate-definition:
    SDefT(x, strats*, terms*, s) -> type-dec |[ 
            public static class x extends Strategy {
              public final static x instance = new x();
              public ATerm apply(param*, ATerm term) {
                int nextState = 1;
                Root:
                while(true)
                  switch(nextState) {
                  case 0: return null;
                  case 1: ~bstm:blocks
                  }
                return term;
              }
            }
         ]|
    where
      prelude(|"translate-definition")
    ; <map(translate-parameter)> strats* => strats'
    ; <map(translate-parameter)> terms* => terms'
    ; <conc> (strats', terms') => param*
    ; !Block(<translate-body(|Next(), (Id("Root"), Lit(Deci("0"))))> s) => blocks


  // XXX: add Strategy parameter
  translate-parameter :
  VarDec(x, ConstType(_)) -> param |[ final ATerm x ]|
  where prelude(|"translate-parameter - term")
  
  translate-parameter : 
  VarDec(x, FunType(_, _)) -> param |[ final Strategy x ]|
  where prelude(|"translate-parameter - strategy")
  
strategies
  prelude(|msg) = log(|Debug(), msg)
  
  verify-SwitchGroup(|stratname) = ?SwitchGroup(_, _) <+ log(|Error(), [ stratname, ": not a SwitchGroup!" ])
  
  /** @type Strategy -> List(SwitchGroup) */
  translate-body(|S,F) = 
    prelude(|"translate-body") 
    ; topdown(repeat(translate-strategy(|S,F)))
    ; //verify-SwitchGroup(|"translate-body")
      debug(!"after translate-body :")

  translation-failed = ?x#(_) ; log(|Error(), [ "Unknown constructor type ", x ]) ; fail
  
  translate-Scope : 
  Scope(vars, e) -> Block(<conc> (vars', [e]))
  where
    <map(\ x -> bstm |[ ATerm x ; ]| \)> vars => vars'
    
  /** @type Id -> Stm */
  translate-Id(|S,F) :
    Id() -> <Goto> S
  where prelude(|"translate-Id")
    
  /** @type Id -> Stm */
  translate-Fail(|S,F) :
    Fail() -> <Goto> F
  where prelude(|"translate-Fail")

  /** @type Seq -> Stm */
  translate-Seq(|S, F) :
    Seq(s1, s2) -> 
    bstm |[ 
      { 
        ~stm:<translate-strategy(|Next(), F)> s1 
        ~stm:<translate-strategy(|Next(), F)> s2 
      } 
    ]|
  where prelude(|"translate-Seq")
  
  translate-GuardedLChoice(|S,F) :
    GuardedLChoice(s1, s2, s3) ->
      bstm* |[
      nextState = ~n0;
      ~id:label:
      while(true)
      switch(nextState) {
          case ~n0: 
            ATerm ~x = term ; 
            ~stm:<translate-strategy(|n1, n2)> s1 ;
          case ~n1: 
            ~stm:<translate-strategy(|S, F)> s2 ;
            ~stm:<Goto> S
          case ~n2: 
            term = ~<!ExprName(x)>; 
            ~stm:<translate-strategy(|S, F)> s2 ; 
            ~stm:<Goto> S
      }
    ]|
   where prelude(|"translate-GuardedLChoice")
       ; <not(Next())> S
       ; !Id(<newname> "trm") => x
       ; newlabel => label
       ; !(label, <newcase>) => n0
       ; !(label, <newcase>) => n1
       ; !(label, <newcase>) => n2

  translate-GuardedLChoice(|S,F) :
    GuardedLChoice(s1, s2, s3) ->
    bstm* |[ {
      nextState = 0;
      ~id:label:
      while(true)
      switch(nextState) {
        case 0: 
          ATerm ~x = term ; 
          ~stm:<translate-strategy(|Next(), (label, Lit(Deci("2"))))> s1
        case 1: 
          ~stm:<translate-strategy(|S, F)> s2 ;
           break;
        case 2: term = ~<!ExprName(x)>; 
           ~stm:<translate-strategy(|S, F)> s2 ; 
           break;
       }
       }
    ]|
  where prelude(|"translate-GuardedLChoice") 
      ; !S => Next()
      ; !Id(<newname> "trm") => x
      ; newlabel => label

  /** @type -> Lit(Deci(String))) */
  newcase = !Lit(Deci("1001"))
  newlabel = !Id(<newname> "label")

  goto(|label) = <Goto> label 
  
  Goto: Next() -> Empty()
  Goto: (scopeLabel, caseNumber) -> bstm |[ { ns = ~caseNumber; break ~scopeLabel; } ]|
  
  translate-strategy(|S,F) = 
    translate-CallT 
    <+ translate-Build
    <+ translate-Seq(|S,F)
    <+ translate-PrimT
    <+ translate-Id(|S,F)
    <+ translate-Fail(|S,F)
    <+ translate-GuardedLChoice(|S,F) ; debug(!"after guarded choice: ")
    <+ translate-Scope
    <+ translate-Match
    <+ translate-Let
  
  translate-Let: 
  Let(defs, body) -> Block(<conc> (defs', [body]))
  where
      prelude(|"translate-Let")
    ; <map(translate-definition)> defs => defs'
 
  
  translate-CallT = 
    prelude(|"translate-CallT")
    ; do-translate-CallT 
    <+ \ CallT(_, _, _) -> stm |[ CallT(); ]| \
  
  make-strategy-class : 
  (x, s) -> bstm |[ 
        static final class x extends Strategy { 
          public final static x instance = new x();
          public ATerm apply(ATerm term) { 
            try { ~bstm:s } catch(Failure f) { return null; } return term; 
          }
        } 
    ]|
  
  do-translate-CallT:
    CallT(SVar(x), s*, t*) ->
      Block( <conc> (bodies, [ stm |[ term = x.instance.apply(e*,term) ; ]| ]) )
      where
        // FIXME do actual lifting
        <map(\ x -> (<new>(), <translate-strategy(|0,1)> x) \)> s* => args1 // FIXME correct S,F
      ; <map(make-strategy-class)> args1 => bodies
      ; <map(construct-term)>t* => args2
      ; <conc> (<map(!ExprName(Id(<Fst>)))> args1, args2) => e*

  translate-PrimT :
    PrimT(_, _, _) -> stm |[ PrimT(); ]|
    
  translate-Match:
    Match(_, _) -> stm |[ Match(); ]|
    
  translate-Build = 
    do-translate-Build 
    <+ \ Build(t) -> stm |[ Build(); ]| \
  
  do-translate-Build:
    Build(t) -> Block(<conc> (be, [ bstm |[ term = x; ]| ] ))
    where 
      <construct-term> t => (Block(be), x)
    ; debug(!"do-translate-Build")

  
strategies
  
  construct-term =
    ?Anno(<construct-list <+ construct-preterm <+ debug(!"construct-term failed")> ,_)

rules
  construct-list :
  Op("Nil",[]) -> (bstm |[ ATerm x = atermFactory.makeList(); ]|, x)
  where
    x := <new>
  
  construct-list :
  Op("Cons",[head,Anno(tail,_)]) -> |[ e2.insert(e1) ]|
  where
    e1 := <construct-term> head
  ; e2 := <construct-list> tail
  ; x := <new>

rules
  construct-preterm :
  Int(i) -> (bstm |[ ATerm x = atermFactory.makeInt(i); ]|, x)
  where
    x := <new>

  construct-preterm :
  Str(s) -> (bstm |[ ATerm x = atermFactory.makeAppl(atermFactory.makeAFun("~s",0,true)); ]|, x)
  where
    x := <new>

  construct-preterm :
  Real(s) -> (bstm |[ ATerm x = atermFactory.makeReal(~float:f); ]|, x)
  where
    f := Float(s)
  ; x := <new>

  construct-preterm =
    ?Var(x){b}
  ; if !b => "bound" then
      !(stm |[ x; ]|, x)
    else
      !(stm |[ not_null(x); ]|, x)
    end

  construct-preterm :
  Op(c,t*) -> (Block( 
       <conc> (be, 
       [ bstm |[ ATerm x1 = atermFactory.makeAppl(atermFactory.makeAFun("~c",i,false), x); ]| ]))
      , x1)
  where 
    <length ; int-to-string> t* => i
  ; x1 := <new>
  ; <list-to-term-array> t* => (Block(be), x)

strategies
  list-to-term-array =
    where( new => x )
  ; map-with-index(
      {i,j,t,s,x1:
        ?(i,t)
      ; <dec ; int-to-string> i => j
      ; <construct-term> t => (s, x1)
      ; !bstm |[ { ~stm:s x[j] = x1; } ]|
      }
    ) => bstmts*
  ; length ; int-to-string => n
  ; !(Block([ bstm |[ ATerm[] x = new ATerm[~deci:n]; ]| | bstmts* ]), x)


// matching
strategies

  do-translate-Match :
    Match(t) -> Match(t,expr |[ term ]| )

  do-translate-Match :
    Match(pattern, e1)
      -> switch-group |[
        case 0: 
             ATerm x1 = e1;
             bstm
         ]|
    where
      <newname> "term" => x1
    ; <newname> "result" => y
    ; <remove-Anno ; Pattern2Stm(|x1)> pattern => bstm

  remove-Anno = topdown(try(?Anno(<id>,_)))

strategies

  Pattern2Stm(|z) :
    Int(i) -> 
      stm |[ { if(z.getType() != ATerm.INT || ((ATermInt)z).getInt() != i )
	         throw new Failure();
             }
          ]|

  Pattern2Stm(|z) :
    Real(i) -> 
      stm |[ { if(z.getType() != ATerm.REAL || ((ATermReal)z).getReal() != ~float:f )
	         throw new Failure();
             }
          ]|
      where !Float(i) => f

  Pattern2Stm(|z) :
    Wld() -> stm |[ Wld(); ]|

  Pattern2Stm(|z) :
    Var(x) -> stm |[ x = z; ]|

  Pattern2Stm(|z) :
    Explode(x, p) ->
    stm |[ 
      {
        if(z.getType() != ATerm.APPL)
          throw new Failure();

        x = ((ATermAppl) z).getName();

        ATerm y = ((ATermAppl) z).getArguments();
        stm1
      }
    ]|
    where
      <newname> "list" => y
    ; <Pattern2Stm(|y)> p => stm1

  Pattern2Stm(|z) :
    Op(sym,ps)
      ->
    stm |[
      {
        if(z.getType() != ATerm.APPL)
          throw new Failure();

        ATermAppl x = (ATermAppl) z;

        if(!x.getName().equals("~sym") || x.getArity() != i)
          throw new Failure();

        bstm*
      }
    ]|
    where
      <length; int-to-string> ps => i
    ; <newname> "appl" => x
    ; <map-with-index({y,i,j,stm2:
        ?(i, <id>)
      ; where(
          <newname> "term" => y
        ; <dec; int-to-string> i => j
        )
      ; Pattern2Stm(|y) => stm2
      ; ![ bstm |[  ATerm y = x.getArgument(j); ]|, bstm |[  stm2 ]| ]
      })> ps
    ; concat => bstm*


