/**
 * Java backend for the Stratego compiler
 *
 * @author Karl Trygve Kalleberg
 * @author Eelco Visser
 */
module s2j
imports
  Stratego-Core 
  libstratego-lib
  Java-15 
  Java-EBlock 
  libstrc
  libstratego-xtc
  libstratego-rtg

signature
  constructors 
    Next  : Term
    Match : Term * Exp -> Exp
    Filename : Str -> Term
    
strategies

  io-s2j = io-wrap(java-backend)
 
rules
 
  fc = rtg-format-check(true, true|<java-rtg>()) <+ ?x ; where(err(|["Bad term : ", x])) ; fail
  
  with(s) = 
    s 
  <+ 
      frames  := [ "With-expression failed:" | 
                   <prim("SSL_stacktrace_get_all_frame_names") ; reverse> ]
    ; spacing := <length ; dec ; upto ; map(!"\n\t")> frames
    ; s       := <zip(conc-strings)> (frames,spacing)
    ; <fprint> (stderr(), s)
    ; <exit> 1
  
  java-backend = 
      where(<xtc-find ; parse-rtg-file> "Java-15.rtg" => rtg)
    ; rules( java-rtg := rtg )
    ; extract-meta
    ; java-compile-spec
      
  extract-meta = 
     ?_{Meta(metas)}
    ; where(rules(metas := metas))
  
  meta-filename = 
      <metas>()
    ; filter(\ Filename(n) -> n \)
    ; Hd

  compute-classname = 
      meta-filename 
    ; base-filename 
    ; remove-extension 
    ; !Id(<id>)
    
  java-compile-spec :
    Specification([Signature([Constructors(ops)]), Strategies(defs)]) -> 
     |[ 
     package org.strategoxt.compiler.tests.cases;
     
     import org.strategoxt.lang.Runtime;
     import org.strategoxt.lang.Strategy; 
     import org.strategoxt.lang.Failure;
     import org.strategoxt.lang.terms.*;
     import org.strategoxt.runtime.ssl.SSL;

     import static org.strategoxt.runtime.ssl.SRTS.*;
         
     import static org.strategoxt.lang.Runtime.termFactory;
     import static org.strategoxt.lang.Term.nonNull;
     import static org.strategoxt.lang.Term.checkTermList;
     import static org.strategoxt.lang.Term.matchConstructor;
     		
     public class ~id:name {

     ~*cnst-decls
     ~*cnstr-decls
     ~*lifted-defs
     
     private static void preInit() {
       ~*cnst-inits
       ~*cnstr-inits
     }

	 public static String testMain(String input) {
	    preInit();
        final IStrategoTerm result = main_0_0.instance.apply(Runtime.termFactory.parseFromString(input));
        return result == null ? null : result.toString();
     }
        
	 public static void main(String args[]) {
	    preInit();
	    IStrategoTerm zz = Runtime.prepareCLIArgs(args);
	    System.out.println(zz);
        IStrategoTerm term = main_0_0.instance.apply(zz);
        if(term == null) { 
          System.err.println("Rewriting failed!"); 
          System.exit(1); 
        }
        else { System.out.println(term); }
	 }

     ~*function-defs

     }
     ]|
  where 
      alltd(JavaTranslate)
    ; with(name          := <compute-classname> ())
    ; with(function-defs := <map(translate-outer-definition)> defs)
    ; with(lifted-defs   := <bagof-Fragment> "LiftedDef")
    ; with(cnstr-decls   := <bagof-Fragment> "ConstructorDecl")
    ; with(cnstr-inits   := <bagof-Fragment; concat> "ConstructorInit")
    ; with(cnst-decls    := <bagof-Fragment> "ConstDecl")
    ; with(cnst-inits    := <bagof-Fragment; concat; reverse> "ConstInit")
    

rules
  translate-inner-definition = translate-any-definition(|[Final(), Static()])
  translate-outer-definition = translate-any-definition(|[Public(), Static()])
  
  translate-any-definition(|modifiers):
    SDefT(x, strats*, terms*, s) -> type-dec |[ 
            mod* class x extends Strategy {
              public final static x instance = new x();
              public IStrategoTerm apply(param*, IStrategoTerm term) {
                int nextState = 1;
                Root:
                while(true)
                  switch(nextState) {
                  case 0: return null;
                  case 1: ~stm:body; break Root;
                  }
                return term;
              }
            }
         ]|
    where
      prelude(|"translate-any-definition")
    ; with(mod*    := modifiers) 
    ; with(strats' := <map(translate-parameter)> strats*)
    ; with(terms'  := <map(translate-parameter)> terms*)
    ; with(param*  := <conc> (strats', terms'))
    ; with(body    := <translate-body(|Next(), (Id("Root"), Lit(Deci("0"))))> s)

  // XXX: add Strategy parameter
  translate-parameter :
  VarDec(x, ConstType(_)) -> param |[ final IStrategoTerm x ]|
  where prelude(|"translate-parameter - term")
  
  translate-parameter : 
  VarDec(x, FunType(_, _)) -> param |[ final Strategy x ]|
  where prelude(|"translate-parameter - strategy")
  
strategies
  prelude(|msg) = where(?x#(_) ; log(|Debug(), [ msg, " : ", x ]))
  
  verify-SwitchGroup(|stratname) = ?SwitchGroup(_, _) <+ log(|Error(), [ stratname, ": not a SwitchGroup!" ])
  
  /** @type Strategy -> List(SwitchGroup) */
  translate-body(|S,F) = 
    prelude(|"translate-body") 
    ; translate-strategy(|S,F)
    //; //verify-SwitchGroup(|"translate-body")
      //debug(!"after translate-body :")

  translation-failed = ?x#(_) ; log(|Error(), [ "Unknown constructor type ", x ]) ; fail
  
  translate-Scope(|S, F) : 
  Scope(vars, e) -> Block(<conc> (vars', [<translate-strategy(|S,F)> e]))
  where prelude(|"translate-Scope") ;
    <map(\ x -> bstm |[ IStrategoTerm x = null; ]| \)> vars => vars'
    
  /** @type Id -> Stm */
  translate-Id(|S,F) :
    Id() -> <Goto> S
  where prelude(|"translate-Id")
    
  /** @type Id -> Stm */
  translate-Fail(|S,F) :
    Fail() -> <Goto> F
  where prelude(|"translate-Fail")

  /** @type Seq -> Stm */
  translate-Seq(|S, F) :
    Seq(s1, s2) -> 
    bstm |[ 
      { 
        ~stm:<translate-strategy(|Next(), F)> s1 
        ~stm:<translate-strategy(|Next(), F)> s2 
      } 
    ]|
  where prelude(|"translate-Seq")

  /** @type GuardedLChoice -> Block */  
  translate-GuardedLChoice(|S,F) :
    GuardedLChoice(s1, s2, s3) ->
      Block(bstm* |[
      nextState = ~n0;
      IStrategoTerm ~x = null ; 
      ~id:label:
      while(true)
      switch(nextState) {
          case ~n0: 
           ~x = term ; 
            ~stm:<translate-strategy(|n1, n2)> s1
          case ~n1: 
            ~stm:<translate-strategy(|S, F)> s2
            ~stm:<Goto> S
          case ~n2: 
            term = ~<!ExprName(x)>; 
            ~stm:<translate-strategy(|S, F)> s2
            ~stm:<Goto> S
      }
    ]|)
   where prelude(|"translate-GuardedLChoice")
     ; <not(Next())> S
     ; x     := Id(<newname> "trm")
     ; label := <newlabel>
     ; n0    := (label, <newcase>)
     ; n1    := (label, <newcase>)
     ; n2    := (label, <newcase>)

  translate-GuardedLChoice(|S,F) :
    GuardedLChoice(s1, s2, s3) ->
    Block(bstm* |[ {
      nextState = 0;
      IStrategoTerm ~x = null ;
      boolean ~id:loop = true; 
      ~id:label:
      while(~expr:ExprName(loop))
      switch(nextState) {
        case 0: 
          ~x = term ; 
          ~stm:<translate-strategy(|Next(), (label, Lit(Deci("2"))))> s1
        case 1: 
          ~stm:<translate-strategy(|S, F)> s2 ;
           break;
        case 2: term = ~<!ExprName(x)>; 
           ~stm:<translate-strategy(|S, F)> s2 ; 
           break;
       }
       }
    ]|)
  where prelude(|"translate-GuardedLChoice") 
    ; !S => Next()
    ; x     := Id(<newname> "trm")
    ; label := <newlabel> ()
    ; loop  := <newloop> ()

  /** @type -> Lit(Deci(String))) */
  newcase  = !Lit(Deci("1001"))
  newlabel = !Id(<newname> "label")
  newloop  = !Id(<newname> "loop")

  goto(|label) = <Goto> label 
  
  Goto: Next() -> Empty()
  Goto: (scopeLabel, caseNumber) -> bstm |[ { nextState = ~caseNumber; continue ~scopeLabel; } ]|
  
  translate-strategy(|S,F) = 
       ( 
       translate-CallT(|S,F) ; fc
    <+ translate-Build(|S,F) ; fc
    <+ translate-Seq(|S,F) ; fc
    <+ translate-PrimT(|S,F) ; fc
    <+ translate-Id(|S,F) ; fc
    <+ translate-Fail(|S,F) ; fc
    <+ translate-GuardedLChoice(|S,F) ; fc
    <+ translate-Scope(|S,F) ; fc
    <+ translate-Match(|S,F) ; fc
    <+ translate-Let(|S,F) ; fc
//    <+ debug(!"translate-strategy failed ") ; fail
       ) 
//    ; debug(!"translated ")

  translate-Let(|S,F): 
  Let(defs, body) -> Block([<translate-strategy(|S,F)> body])
  where
      prelude(|"translate-Let")
    ; debug
    ; <map(fragment(translate-inner-definition | "LiftedDef"))> defs
 
  make-strategy-class : 
  (x, body) -> type-dec |[ 
        static final class x extends Strategy { 
          public final static x instance = new x();
          public IStrategoTerm apply(IStrategoTerm term) { 
            int nextState = 1;
            Root:
            while(true)
              switch(nextState) {
                case 0: return null;
                case 1: ~stm:body break Root;
              }
              return term;
          }
        } 
    ]|
  
  translate-CallT(|S,F):
    CallT(SVar(x), s*, t*) -> Block(call)
      where prelude(|"translate-CallT"); 
        // FIXME do actual lifting
        with(args1  := <map(\ x -> (<new>(), <translate-strategy(|S,F)> x) \)> s*)
      ; <map(fragment(make-strategy-class|"LiftedDef"))> args1
//      ; with(bodies := <map(make-strategy-class)> args1)
      ; with(args2  := <map(java-construct-term)> t* => args2)
      ; <debug(!"args1  ")> args1
//      ; <debug(!"bodies ")> bodies
      ; <debug(!"args2  ")> args2
      ; with(e*     := <conc> (<map(!Field(ExprName(Id(<Fst>)),Id("instance")))> args1, args2))
      ; <debug(!"e*     ")> e*
      ; <debug(!"F      ")> F
      ; <debug(!"S      ")> S
      ; with(call := bstm* |[ 
	               term = x.instance.apply(e*,term); 
	               if(term == null) 
	                 ~stm:<Goto> F
	               else
	                 ~stm:<Goto> S
	             ]|)
      ; <debug(!"call      ")> call

  java-ArgToCl :
    CallT(SVar(f{Closure(x), Frames([])}), [], []) -> expr|[ x ]|
//    Strat|[ f~{Closure(x),Frames([])}(|) ]| -> exp|[ x ]|

  java-ArgToCl :
    CallT(SVar(f{Offset(i),Closure(x),Frames([])}), [], []) -> expr|[ x ]|
//    Strat|[ f~{Offset(i),Closure(x),Frames([])}(|) ]| -> exp|[ x ]|

  // passing a remote closure to a function

  java-ArgToCl :
//    Strat|[ f~{Offset(i),Closure(x),Frames(frames)}(|) ]| -> 
    CallT(SVar(f{Offset(i),Closure(x),Frames(frames)}), [], []) ->
    expr|[ sl_fun_cl(~expr:<mk-int-const> i, ~expr:sl) ]|
  where prelude(|"java-ArgToCl") ;
    with(sl := <not([]); java-frames-to-static-link> frames)


  translate-PrimT(|S,F) :
    PrimT(f, s*, t*) -> 
    <java-check-unbound-args(|F,t*)>  
    Block(bstm* |[ 
      term = SSL.~id:Id(f)(~*args); 
      if(term == null) ~<Goto> F else ~<Goto> S
    ]|)
  where prelude(|"translate-PrimT") ;
        <debug(!"s* ")> s*
      ; with(args1 := <map(java-ArgToCl)> s*)
      ; <debug(!"foo ")> t*
      ; with(args2 := <with(map(java-construct-term))> t*)
      ; <debug(!"zap ")> args2
      ; with(args  := <with(conc)> (args1, args2))
  
/* ================================ Build  */

  translate-Build(|S,F):
    Build(t) -> 
    <java-check-unbound-args(|F,t)> 
    Block(bstm*|[
               ~*decs
               ~*stms
               term = ~expr:e;
               ~stm:<Goto> S
               ]|)
  where prelude(|"translate-Build")
    ; {| java-CheckList, java-FailureLabel : 
	     rules( java-FailureLabel : _ -> F )
	   ; <java-construct-term> t => e
	   ; debug(!"term ")
	   ; bagof-java-CheckList; unzip; (id, reverse; concat) => (decs, stms)
	   ; debug(!"bagof-CheckList ")
      |} 

  java-check-unbound-args(|F,t) =
    try(java-CheckUnboundArgs(|F,t))

  java-CheckUnboundArgs(|F,t) :
    s -> 
    stm|[ 
      if(~expr:e)
        ~stm:<Goto> F
      else  
        ~stm:s
    ]|
    where prelude(|"CheckUnboundArgs") ;
      <collect({?Var(_){t*}; where(<not(["bound"])> t* )})> t
    ; debug(!"unbound ")
	; not([])
	; foldr1(!expr|[ ~expr:<Hd; java-ConstructVar> == null ]|
	        ,!expr|[ ~expr:<Fst; java-ConstructVar> == null || ~expr:<Snd> ]|) => e
    ; debug(!"expr ")

/**
 * Term construction with constant term caching
 */
rules 

  java-init-term-caching =
    where(
         t1 := Op("Nil", [])
       ; t2 := Anno(Op("Nil", []), Op("Nil", []))
       ; e  := expr|[ atermFactory.makeList() ]|
    )
    ; rules( java-Cache : t1 -> e )
    ; rules( java-Cache : t2 -> e )

  /** @type Term -> Exp */
  java-construct-term = prelude(|"java-construct-term");
       java-Cache 
    <+ java-ConstructAnnoVar
    <+ java-ConstructVar
    <+ !(<id>, <java-ConstructTerm>)
       ; (java-CacheConstant <+ Snd)

  java-CacheConstant :
    (t, e1) -> e2
  where prelude(|"CacheConstant") ; <debug> (t, "->", e1) ;
      <(Op(id, map(java-Cache)); proper-list 
            + Anno(java-Cache, java-Cache) 
            + Int(id) + Str(id) + Real(id) )> t
      ; x  := <newname> "term"
      ; e2 := ExprName(Id(x))
      ; rules( java-Cache : t -> e2 )
      ; !(x, e1)
      ; fragment(java-DeclareTermId|"ConstDecl")
      ; fragment(java-InitTermId|"ConstInit")

// helpers

strategies
    
  is-TupleOp = ?Op("", _)

  java-DeclareTermId :
    (x, e) ->
    class-body-dec|[ static IStrategoTerm ~<!Id(x)>; ]|

  java-InitTermId :
    (x, e) -> bstm*|[ x = e; ]|

  java-mk-int-const = prelude(|"mk-int-const") ;
    !Lit(Deci(<try(int-to-string)>))
    

rules

  java-ConstructTerm :
    Int(i) -> 
    expr|[ 
      termFactory.makeInt(~expr:<java-mk-int-const> i)
    ]|
  where prelude(|"java-ConstructTerm - Int")

  java-ConstructTerm :
    Real(x) -> 
    expr|[ 
      termFactory.makeReal(~expr:Lit(Float(<try(real-to-string)> x)))
    ]|
  where prelude(|"java-ConstructTerm - Real")

  java-ConstructTerm :
    Str(x) -> 
    expr|[ 
      termFactory.makeString(~expr:Lit(String([Chars(<escape> x)])))
    ]|
  where 
      prelude(|"java-ConstructTerm - Str")

  java-ConstructVar :
    x@Var(_) -> e
  where 
      prelude(|"java-ConstructVar") 
    ; with(e := <java-VarToReadRef> x)
    ; debug(!"var to read ref: ")

  java-ConstructAnnoVar :
    Anno(Var(x), pt2) -> 
    expr|[ 
      termFactory.setAnnotations(~expr:e, ~expr:<java-construct-term> pt2)
    ]|
  where
      prelude(|"java-ConstructAnnoVar") 
    ; <java-ConstructVar> Var(x) => e

  java-ConstructTerm :
    Anno(pt1, Op("Nil", [])) -> <java-construct-term> pt1
  where 
      prelude(|"java-ConstructTerm - pt1, Op(Nil, [])") 
    ; <not(?Var(_))> pt1

  java-ConstructTerm :
    Anno(pt1, pt2) -> 
    expr|[ 
      termFactory.setAnnotations(~expr:<java-construct-term> pt1, ~expr:<java-construct-term> pt2)
    ]|
  where 
      prelude(|"java-ConstructTerm - pt1{pt2}")
    ; <not(?Op("Nil", []))> pt2
    ; <not(?Var(_))> pt1

//  java-ConstructTerm :
//    |[ _ t ]| -> <java-construct-term> t

  java-ConstructTerm :
    Op(c, t*) -> expr|[ termFactory.makeAppl(~*[cn | args]) ]|
  where
      prelude(|"java-ConstructTerm - Op(c, t*)")
    ; not(is-ListOp + is-TupleOp)
    ; cn   := ExprName(Id(<java-ConstructorName> (c, <length> t*)))
    ; args := <map(java-construct-term)> t*
    ; debug(!"not listop")
    
  java-ConstructTerm :
    Explode(t1, t2) -> 
    expr|[ 
      SSL_mkterm(~expr:<java-construct-term> t1, ~expr:<java-construct-term> t2) 
    ]|
  where 
      prelude(|"java-ConstructTerm - Explode")

  java-ConstructTerm : 
    Op("", args) -> expr|[ termFactory.makeTuple(~*args') ]|
  where
      prelude(|"java-ConstructTerm - Op(\"\", [...])") 
    ; args' := <map(java-construct-term)> args
    
  java-ConstructTerm :
    Op("Nil", []) -> expr|[ termFactory.makeList() ]|
  where prelude(|"java-ConstructTerm - Op(Nil, [])")

  java-ConstructTerm :
    Op("Cons", [t1, t2]) -> 
    expr|[ 
      ((IStrategoList)(~expr:e)).prepend(~expr:<java-construct-term> t1)
    ]|
  where 
      prelude(|"java-ConstructTerm - Cons")
    ; with(
       <java-construct-term> t2
	    ; if <not(Anno(is-ListOp,id))> t2 then 
	        java-check-aterm-list 
	      else
	          if ?Id(_) then
	            !|[ (IStrategoList) ~expr:<id> ]|
	          else
	            try(java-UncastATerm)
	          end
	          ; try(java-CastATermListSetAnnotations)
	        end => e)

  java-check-aterm-list :
    e -> expr|[ (IStrategoList)~id:x ]|
  where 
      prelude(|"java-check-aterm-list") 
    ; x := Id(<newname> "trm")
	; F := <java-FailureLabel> ()
    ; stms := 
	     (bstm |[ IStrategoList ~id:x; ]|, 
          bstm*|[ ~id:x = checkTermList(~expr:e);
                  if(~id:x == null) ~stm:<Goto> F ]|)
    ; rules( java-CheckList :+ _ -> stms )

  java-CastATerm :
    e -> expr|[ (IStrategoTerm) ~expr:e ]|

  java-CastATermListSetAnnotations :
    expr|[ termFactory.setAnnotations(~expr:e1, ~expr:e2) ]| -> expr|[ (IStrategoList) termFactory.setAnnotations(~expr:e1, ~expr:e2) ]|

  java-UncastATerm :
    expr|[ (IStrategoTerm)~expr:e ]| -> e

  java-VarToReadRef : 
    Var(x{}) -> ExprName(Id(x{}))

  java-VarToReadRef :
    Var(x{Frames([])}) -> ExprName(Id(x{}))

  java-VarToReadRef :
    Var(x{Offset(i), Frames([])}) -> ExprName(Id(x{}))

  java-VarToReadRef : 
    Var(x{Offset(i), Frames(frames)}) -> 
    expr|[ sl_readvar(~expr:<java-mk-int-const> i, ~expr:sl) ]|
  where 
    with(sl := <not([]); java-frames-to-static-link> frames)

signature
  constructors
  
    Offset: Int -> Term
    Frames: List(Term) -> Term
    
/**
 * Signatures
 */
strategies

  JavaTranslate =
      fragment(JavaDeclareConstructor|"ConstructorDecl")
    ; fragment(JavaInitConstructorQ <+ JavaInitConstructor|"ConstructorInit")

  JavaDeclareConstructor :
    OpDecl(c, t) -> class-body-dec|[ static IStrategoConstructor ~id:Id(csym); ]|
  where 
      prelude(|"DeclareConstructor") 
    ; n    := <Arity> t
    ; csym := <concat-strings> ["sym_", <cify> c, "_", <int-to-string> n]
    ; rules(java-ConstructorName : (c, n) -> csym)

  JavaInitConstructorQ :
    OpDecl(c, t) ->
    bstm*|[
      ~id:csym = ATmakeSymbol(~expr:Lit(String([Chars(<double-quote> c')])), 
			                  ~expr:<java-mk-int-const> ar,
			                  ATtrue);
    ]|
  where 
      <string-as-chars(unescape-chars; un-double-quote-chars)> c => c' 
    ; ar   := <Arity> t
    ; csym := <java-ConstructorName> (c, ar)

  JavaInitConstructor :
    OpDecl(c, t) ->
    bstm*|[
      ~id:csym = termFactory.makeConstructor(~expr:Lit(String([Chars(c)])), 
                                             ~expr:<java-mk-int-const> ar);
    ]|
  where 
      ar   := <Arity> t
    ; csym := Id(<java-ConstructorName> (c, ar))

/* ================================ Match */
strategies

  translate-Match(|S,F) :
    Match(t) -> <translate-Match(|S,F)> Match(t, ExprName(Id("term")))
  where prelude(|"translate-Match - Match/1");
    <debug(!"term ")> t

  translate-Match(|S,F) :
    Match(Wld(), trm) -> <Goto> S
  where prelude(|"translate-Match - Match(Wld,trm)")

  translate-Match(|S,F) :
    Match(As(t1,t2), trm) ->
    stm|[ 
      { 
        ~stm:(<translate-Match(|Next(),F)> Match(t1,trm))
        ~stm:(<translate-Match(|S,F)> Match(t2,trm))
      }
    ]|
  where prelude(|"translate-Match - Match(As(t1,t2), trm)")

  translate-Match(|S,F) :
    Match(Var(x){"unbound"}, trm) ->
    stm|[ { ~e = ~expr:trm; ~stm:<Goto> S } ]|
  where prelude(|"translate-Match - Match(Var(x){unbound}, trm)");
    ExprName(e) := <java-VarToWriteRef> x


  translate-Match(|S,F) :
    Match(Var(x){"bound"}, trm) ->
    stm|[ 
      if( ~expr:e == ~expr:trm ) 
        ~stm:<Goto> S
      else 
        ~stm:<Goto> S
     ]|
  where 
      prelude(|"translate-Match - Match(Var(x){bound}, trm)")
    ; with(e := <java-VarToReadRef> Var(x))

  translate-Match(|S,F) :
    Match(Var(x){"(un)bound"}, expr) ->
    stm|[ 
      if(~expr:e1 == null) {
          lhs = ~expr:expr;
          ~stm:<Goto> S
      } else if(!(~expr:e1).equals(~expr:expr)) {
        ~stm:<Goto> F
      } else
        ~stm:<Goto> S
    ]|
  where 
      prelude(|"translate-Match - Match(Var(x){(un)bound})")
    ; <debug(!"XX ")> Var(x)
    ; with(e1 := <java-VarToReadRef> Var(x))
    ; <debug(!"PP")> ()
	; with(e2 := <java-VarToWriteRef> x)
	; if !e2 => ExprName(_) then
        lhs := e2
	  else
        lhs := e2
	  end
    ; <debug(!"e1 ")> e1
    ; <debug(!"e2 ")> e2
    ; <debug(!"lhs  ")> lhs

  java-VarToWriteRef :
    x{} -> ExprName(Id(x))

  java-VarToWriteRef :
    x{Frames([])} -> ExprName(Id(x))

  java-VarToWriteRef : 
    x{Offset(i), Frames([])} -> ExprName(Id(x))

  java-VarToWriteRef : 
    x{Offset(i), Frames(frames)} -> 
    expr|[ sl_readvar(~expr:<java-mk-int-const> i, ~expr:sl).var ]|
  where 
    <not([]); java-frames-to-static-link> frames => sl

  java-frames-to-static-link = prelude(|"java-frames-to-static-link") ; 
    (Tl <+ err(|"*** frames-to-static-link error: "); fail)
    ; foldr(!expr|[ sl ]|,
	        !expr|[ sl_up(~expr:<Snd>) ]|)

  translate-Match(|S,F) :
    Match(Var(x){}, trm) -> <translate-Match(|S,F)> Match(Var(x){"(un)bound"}, trm)
  where prelude(|"translate-Match - Match(Var(x){}")
    ; <debug(!"ZZ ")> x

  translate-Match(|S,F) :
    Match(Explode(t1, t2), expr) ->
    stm|[ 
    {
      IStrategoTerm ~id:n0, ~id:n1;
	 ~id:n0 = SSL_get_constructor(~expr:expr);
	 ~id:n1 = SSL_get_arguments(~expr:expr);
	 ~stm:(<translate-Match(|Next(),F)> Match(t1, ExprName(n0)))
	 ~stm:(<translate-Match(|S     ,F)> Match(t2, ExprName(n1)))
     } ]|
  where
      prelude(|"translate-Match - Match(Explode)") 
    ; with(!expr => ExprName(Id(_)))
    ; with(n0 := Id(<newname> "trm"))
    ; with(n1 := Id(<newname> "trm"))

  translate-Match(|S,F) =
       ( translate-MatchNoAnno(|S,F)
      <+ translate-MatchAnno(|S,F) ) 
      ; where(<debug> "after anno matching")

  translate-MatchNoAnno(|S,F) :
    Match(Anno(pt1, Wld()), expr) -> <translate-Match(|S,F)> Match(pt1, expr)
  where prelude(|"translate-MatchNoAnno - Match(pt1{^_}")

  translate-MatchAnno(|S,F) :
    Match(Anno(pt1, pt2), expr) -> 
    stm|[ 
      { 
        ATerm ~id:x; 
        ~id:x = (ATerm)ATgetAnnotations(~expr:expr);
        if(~id:x == NULL) 
           ~id:x = (ATerm) ATempty;
        ~stm:stm0
        ~stm:stm1
      } 
    ]|
  where 
      prelude(|"translate-MatchAnno - Match(pt1{^pt2})")
    ; <not(?Wld())> pt2
    ; <debug(!"pt1 ")> pt1
    ; <debug(!"pt2 ")> pt2
    ; with(x    := Id(<newname> "trm"))
    ; with(stm0 := <translate-Match(|Next(),F)> Match(pt1, expr))
    ; with(stm1 := <translate-Match(|S     ,F)> Match(pt2, ExprName(x)))

  /**
   * @todo  String constants should probably be cached, just like constructor names
   */
  translate-Match(|S,F) :
    Match(Str(x), expr) -> 
    stm|[
      if((~expr:expr).getTermType() == IStrategoTerm.STRING && ((IStrategoString)(~expr:expr)).getValue().equals(~expr:x'))
        ~stm:<Goto> S
      else 
        ~stm:<Goto> F
    ]|
  where
      prelude(|"translate-Match - Match(Str)")
    ; with(!expr => ExprName(Id(_)))
    ; with(x' := Lit(String([Chars(<escape> x)])))

  translate-Match(|S,F) :
    Match(Int(i), expr) -> 
    stm|[
      if((~expr:expr).getTermType() == IStrategoTerm.INT && ((IStrategoInt)~expr:expr).getValue() == ~expr:x')
        ~stm:<Goto> S
      else 
        ~stm:<Goto> F
    ]|
  where 
      prelude(|"translate-Match - Match(Int)")
    ; <debug(!"zz ")> expr
    ; with(!expr => ExprName(Id(_)))
    ; with(x' := <java-mk-int-const> i)
    ; debug(!"xx ")

  translate-Match(|S,F) :
    Match(Real(i),expr) -> 
    stm|[
      if((~expr:expr).getTermType() == IStrategoTerm.REAL && ((IStrategoReal)~expr:expr).getValue() == ~expr:x')
        ~stm:<Goto> S
      else 
        ~stm:<Goto> F
    ]|
  where 
      prelude(|"translate-Match - Match(Real)")
    ; with(!expr => ExprName(Id(_)))
    ; with(x' := Lit(Float(<try(real-to-string)> i)))

  /**
   * Translate a match of an Op, but not a Cons/2 or Nil/0.
   */
  translate-Match(|S,F) :
    Match(op@Op(c, ts), expr) ->
    stm|[
      if( matchConstructor(~expr:expr, ~id:cname) )
        { 
          ~bstm*:match-args
          ~stm:<Goto> S
        }
      else
        ~stm:<Goto> F
    ]|
  where prelude(|"translate-Match - Match(Op)");
       <not(is-ListOp)> op
     ; with(cname := Id(<java-ConstructorName> (c, <length> ts)))
     ; with((match-args, _) := <thread-map(\ (t,i) ->
             (
               <java-MatchArg1(|Next(),F) <+ java-MatchArg2(|Next(),F)> 
                  (t, expr|[ (~expr:expr).getSubterm(~expr:<java-mk-int-const> i) ]|)
             , <add>(i, 1)
             )
           \ )> (ts,0))

  java-MatchArg1(|S,F) : 
    (Var(x){t*}, expr) -> <translate-Match(|S,F)> Match(Var(x){t*}, expr)
  where 
      prelude(|"java-MatchArg1")
    

  java-MatchArg2(|S,F) : 
    (t, expr) -> 
    stm|[ 
      { 
         IStrategoTerm x = ~expr:expr; 
         ~stm:(<translate-Match(|S,F)> Match(t, ExprName(Id(x))))
      } 
    ]|
  where
      prelude(|"java-MatchArg2")
    ; with(x := <newname> "trm")

  translate-Match(|S,F) :
    Match(Op("Nil", []), expr) ->
    stm|[
      if((~expr:expr).getTermType() == IStrategoTerm.LIST && ((IStrategoList)~expr:expr).isEmpty())
        ~<Goto> S
      else 
        ~<Goto> F
    ]|
  where prelude(|"translate-Match - Match(Op(Nil))")


  translate-Match(|S,F) :
    Match(Op("Cons", [hd, tl]), expr) ->
    stm|[
      if((~expr:expr).getTermType() == IStrategoTerm.LIST && !((IStrategoList)~expr:expr).isEmpty())
        { 
          ~bstm*:match-args 
          ~stm:<Goto> S
        }
      else
        ~stm:<Goto> F
    ]|
  where 
    <map(java-MatchArg1(|Next(),F) <+ java-MatchArg2(|Next(),F))> 
	   [ (hd, expr|[ ((IStrategoList)~expr:expr).head() ]|)
	   , (tl, expr|[ ((IStrategoList)~expr:expr).tail() ]|) ] => match-args
