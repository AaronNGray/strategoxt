/**
 * Java backend for the Stratego compiler
 *
 * @author Karl Trygve Kalleberg
 * @author Eelco Visser
 */
module s2j
imports
  Stratego-Core 
  libstratego-lib
  Java-15 
  Java-EBlock 

signature
  constructors 
    Next  : Term
    Match : Term * Exp -> Exp
    
strategies

  io-s2j = io-wrap(compile-spec)
 
rules
 
  compile-spec :
    Specification([Signature([Constructors(ops)]), Strategies(defs)]) -> 
     |[ 
     package org.strategoxt.compiler.tests.cases;
     
     import org.strategoxt.lang.Runtime;
     import org.strategoxt.lang.Strategy; 
     import org.strategoxt.lang.Failure;
     import org.strategoxt.lang.terms.*;
         
     import static org.strategoxt.lang.Runtime.termFactory;
     import static org.strategoxt.lang.Term.nonNull;
     import static org.strategoxt.lang.Term.checkTermList;
     import static org.strategoxt.lang.Term.matchConstructor;
     		
     public class Main {

     ~*cnst-decls
     ~*cnstr-decls
     
     private static void preInit() {
       ~*cnst-inits
       ~*cnstr-inits
     }

	 public static String testMain(String input) {
	    preInit();
        return main_0_0.instance.apply(Runtime.termFactory.parseFromString(input)).toString();
     }
        
	 public static void main(String args[]) {
	    preInit();
	    IStrategoTerm zz = Runtime.prepareCLIArgs(args);
	    System.out.println(zz);
        IStrategoTerm term = main_0_0.instance.apply(zz);
        if(term == null) { 
          System.err.println("Rewriting failed!"); 
          System.exit(1); 
        }
        else { System.out.println(term); }
	 }

     ~*function-defs

     }
     ]|
     where 
        alltd(Translate)
      ; <map(translate-definition)> defs => function-defs
      ; cnstr-decls   := <bagof-Fragment> "ConstructorDecl"
      ; cnstr-inits   := <bagof-Fragment; concat> "ConstructorInit"
      ; cnst-decls    := <bagof-Fragment> "ConstDecl"
      ; cnst-inits    := <bagof-Fragment; concat; reverse> "ConstInit" 

rules
  translate-definition:
    SDefT(x, strats*, terms*, s) -> type-dec |[ 
            public static class x extends Strategy {
              public final static x instance = new x();
              public IStrategoTerm apply(param*, IStrategoTerm term) {
                int nextState = 1;
                Root:
                while(true)
                  switch(nextState) {
                  case 0: return null;
                  case 1: ~stm:body; break Root;
                  }
                return term;
              }
            }
         ]|
    where
      prelude(|"translate-definition")
    ; <map(translate-parameter)> strats* => strats'
    ; <map(translate-parameter)> terms* => terms'
    ; <conc> (strats', terms') => param*
    ; <translate-body(|Next(), (Id("Root"), Lit(Deci("0"))))> s => body


  // XXX: add Strategy parameter
  translate-parameter :
  VarDec(x, ConstType(_)) -> param |[ final IStrategoTerm x ]|
  where prelude(|"translate-parameter - term")
  
  translate-parameter : 
  VarDec(x, FunType(_, _)) -> param |[ final Strategy x ]|
  where prelude(|"translate-parameter - strategy")
  
strategies
  prelude(|msg) = where(?x#(_) ; log(|Debug(), [ msg, " : ", x ]))
  
  verify-SwitchGroup(|stratname) = ?SwitchGroup(_, _) <+ log(|Error(), [ stratname, ": not a SwitchGroup!" ])
  
  /** @type Strategy -> List(SwitchGroup) */
  translate-body(|S,F) = 
    prelude(|"translate-body") 
    ; translate-strategy(|S,F)
    ; //verify-SwitchGroup(|"translate-body")
      debug(!"after translate-body :")

  translation-failed = ?x#(_) ; log(|Error(), [ "Unknown constructor type ", x ]) ; fail
  
  translate-Scope(|S, F) : 
  Scope(vars, e) -> Block(<conc> (vars', [<translate-strategy(|S,F)> e]))
  where prelude(|"translate-Scope") ;
    <map(\ x -> bstm |[ IStrategoTerm x = null; ]| \)> vars => vars'
    
  /** @type Id -> Stm */
  translate-Id(|S,F) :
    Id() -> <Goto> S
  where prelude(|"translate-Id")
    
  /** @type Id -> Stm */
  translate-Fail(|S,F) :
    Fail() -> <Goto> F
  where prelude(|"translate-Fail")

  /** @type Seq -> Stm */
  translate-Seq(|S, F) :
    Seq(s1, s2) -> 
    bstm |[ 
      { 
        ~stm:<translate-strategy(|Next(), F)> s1 
        ~stm:<translate-strategy(|Next(), F)> s2 
      } 
    ]|
  where prelude(|"translate-Seq")
   ; <debug(!"s1")> s1
   ; <debug(!"s2")> s2
  
  translate-GuardedLChoice(|S,F) :
    GuardedLChoice(s1, s2, s3) ->
      bstm* |[
      nextState = ~n0;
      ~id:label:
      while(true)
      switch(nextState) {
          case ~n0: 
            IStrategoTerm ~x = term ; 
            ~stm:<translate-strategy(|n1, n2)> s1 ;
          case ~n1: 
            ~stm:<translate-strategy(|S, F)> s2 ;
            ~stm:<Goto> S
          case ~n2: 
            term = ~<!ExprName(x)>; 
            ~stm:<translate-strategy(|S, F)> s2 ; 
            ~stm:<Goto> S
      }
    ]|
   where prelude(|"translate-GuardedLChoice")
       ; <not(Next())> S
       ; !Id(<newname> "trm") => x
       ; newlabel => label
       ; !(label, <newcase>) => n0
       ; !(label, <newcase>) => n1
       ; !(label, <newcase>) => n2

  translate-GuardedLChoice(|S,F) :
    GuardedLChoice(s1, s2, s3) ->
    bstm* |[ {
      nextState = 0;
      ~id:label:
      while(true)
      switch(nextState) {
        case 0: 
          IStrategoTerm ~x = term ; 
          ~stm:<translate-strategy(|Next(), (label, Lit(Deci("2"))))> s1
        case 1: 
          ~stm:<translate-strategy(|S, F)> s2 ;
           break;
        case 2: term = ~<!ExprName(x)>; 
           ~stm:<translate-strategy(|S, F)> s2 ; 
           break;
       }
       }
    ]|
  where prelude(|"translate-GuardedLChoice") 
      ; !S => Next()
      ; !Id(<newname> "trm") => x
      ; newlabel => label

  /** @type -> Lit(Deci(String))) */
  newcase = !Lit(Deci("1001"))
  newlabel = !Id(<newname> "label")

  goto(|label) = <Goto> label 
  
  Goto: Next() -> Empty()
  Goto: (scopeLabel, caseNumber) -> bstm |[ { nextState = ~caseNumber; continue ~scopeLabel; } ]|
  
  translate-strategy(|S,F) = 
       ( 
       translate-CallT(|S,F)
    <+ translate-Build(|S,F)
    <+ translate-Seq(|S,F)
    <+ translate-PrimT
    <+ translate-Id(|S,F)
    <+ translate-Fail(|S,F)
    <+ translate-GuardedLChoice(|S,F) ; debug(!"after guarded choice: ")
    <+ translate-Scope(|S,F)
    <+ translate-Match(|S,F)
    <+ translate-Let(|S,F) 
    <+ fail
       ) ; debug(!"translated ")
  
  translate-Let(|S,F): 
  Let(defs, body) -> Block(<conc> (defs', [<translate-strategy(|S,F)> body]))
  where
      prelude(|"translate-Let")
    ; debug
    ; <map(translate-definition)> defs => defs'
 
  
  make-strategy-class : 
  (x, s) -> bstm |[ 
        static final class x extends Strategy { 
          public final static x instance = new x();
          public IStrategoTerm apply(IStrategoTerm term) { 
            try { ~bstm:s } catch(Failure f) { return null; } return term; 
          }
        } 
    ]|
  
  translate-CallT(|S,F):
    CallT(SVar(x), s*, t*) ->
      Block(<concat>
	         [ bodies | 
	             bstm |[ 
	             { 
	               term = x.instance.apply(e*,term) ; 
	               if(term == null) 
	                 ~stm:<Goto> F
	               else
	                 ~stm:<Goto> S
	             }
	             ]|
	         ] 
           )
      where prelude(|"translate-CallT"); 
        // FIXME do actual lifting
        <map(\ x -> (<new>(), <translate-strategy(|0,1)> x) \)> s* => args1 // FIXME correct S,F
      ; <map(make-strategy-class)> args1 => bodies
      ; <map(construct-term)>t* => args2
      ; <conc> (<map(!ExprName(Id(<Fst>)))> args1, args2) => e*

  translate-PrimT :
    PrimT(_, _, _) -> stm |[ PrimT(); ]|
  where prelude(|"translate-PrimT")
    
  
/* ================================ Build  */

  translate-Build(|S,F):
    Build(t) -> 
    <check-unbound-args(|F,t)>
    Block(bstm*|[
        ~*decs;
        ~*stms;
        term = ~expr:e;
        ~stm:<Goto> S
    ]|)
    where prelude(|"translate-Build")
       ; {| CheckList, FailureLabel : 
	     rules( FailureLabel : _ -> F )
	   ; <construct-term> t => e
	   ; debug(!"term ")
	   ; bagof-CheckList; unzip; (id, reverse; concat) => (decs, stms)
	   ; debug(!"bagof-CheckList ")
	   |}

  check-unbound-args(|F,t) =
    try(CheckUnboundArgs(|F,t))

  CheckUnboundArgs(|F,t) :
    s -> 
    stm|[ 
      if(~expr:e)
        ~stm:<Goto> F
      else  
        ~stm:s
    ]|
    where <collect({?Var(_){t*}; where(<not(["bound"])> t* )})> t
	; not([])
	; foldr1(!expr|[ ~expr:<Hd; ConstructVar> == null ]|
	        ,!expr|[ ~expr:<Fst; ConstructVar> == null || ~expr:<Snd> ]|) => e

/**
 * Term construction with constant term caching
 */
rules 

  init-term-caching =
    where(
       !Op("Nil", []) => t1
       ; !Anno(Op("Nil", []),Op("Nil", [])) => t2
       ; !expr|[ atermFactory.makeList() ]| => e
    )
    ; rules( Cache : t1 -> e )
    ; rules( Cache : t2 -> e )

  /** @type Term -> Exp */
  construct-term = prelude(|"construct-term");
       Cache 
    <+ ConstructAnnoVar
    <+ ConstructVar
    <+ !(<id>, <ConstructTerm>)
       ; (CacheConstant <+ Snd)

  CacheConstant :
    (t, e1) -> e2
    where prelude(|"CacheConstant") ;
          <(Op(id, map(Cache)); proper-list 
            + Anno(Cache, Cache) 
            + Int(id) + Str(id) + Real(id) )> t
        ; <newname> "term" => x	    
        ; !ExprName(Id(x)) => e2
        ; rules( Cache : t -> e2 )
        ; !(x, e1)
        ; fragment(DeclareTermId|"ConstDecl")
        ; fragment(InitTermId|"ConstInit")

// helpers

strategies
    
  is-ListOp = ?Op("Nil", []) + ?Op("Cons", [_, _])

  is-TupleOp = ?Op("", _)

  proper-list =
    Op("Nil", [])
    + Op("Cons", [id, proper-list])
    + Op(id, id)
      ; not(is-ListOp)

  DeclareTermId :
    (x, e) ->
    class-body-dec|[ static IStrategoTerm ~<!Id(x)>; ]|

  InitTermId :
    (x, e) -> bstm*|[ x = e; ]|

   mk-int-const = prelude(|"mk-int-const") ;
    !Lit(Deci(<try(int-to-string)>))
    

rules

  ConstructTerm :
    Int(i) -> 
    expr|[ 
      termFactory.makeInt(~expr:<mk-int-const> i)
    ]|
  where prelude(|"ConstructTerm - Int")

  ConstructTerm :
    Real(x) -> 
    expr|[ 
      termFactory.makeReal(~expr:Lit(Float(<try(real-to-string)> x)))
    ]|
  where prelude(|"ConstructTerm - Real")

  ConstructTerm :
    Str(x) -> 
    expr|[ 
      termFactory.makeString(~expr:Lit(String([Chars(<escape> x)])))
    ]|
  where prelude(|"ConstructTerm - Str")

  ConstructVar :
    x@Var(_){} -> e
  where prelude(|"ConstructVar") ;
        <VarToReadRef> x => e
      ; debug(!"var to read ref: ")

  ConstructAnnoVar :
    Anno(Var(x), pt2) -> 
    expr|[ 
      termFactory.setAnnotations(~expr:e, ~expr:<construct-term> pt2)
    ]|
  where prelude(|"ConstructAnnoVar") ; 
        <ConstructVar> Var(x) => e

  ConstructTerm :
    Anno(pt1, Op("Nil", [])) -> <construct-term> pt1
  where prelude(|"ConstructTerm - pt1, Op(Nil, [])") ; 
        <not(?Var(_))> pt1

  ConstructTerm :
    Anno(pt1, pt2) -> 
    expr|[ 
      termFactory.setAnnotations(~expr:<construct-term> pt1, ~expr:<construct-term> pt2)
    ]|
  where prelude(|"ConstructTerm - pt1{pt2}") ; 
        <not(?Op("Nil", []))> pt2
      ; <not(?Var(_))> pt1

//  ConstructTerm :
//    |[ _ t ]| -> <construct-term> t

  ConstructTerm :
    Op(c, t*) -> expr|[ termFactory.makeAppl(~*[cn | args]) ]|
  where prelude(|"ConstructTerm - Op(c, t*)") ; debug ;
        not(is-ListOp + is-TupleOp)
      ; cn := ExprName(Id(<ConstructorName> (c, <length> t*)))
      ; args := <map(construct-term)> t*
      ; debug(!"not listop")
    
  ConstructTerm :
    Explode(t1, t2) -> 
    expr|[ 
      SSL_mkterm(~expr:<construct-term> t1, ~expr:<construct-term> t2) 
    ]|
  where prelude(|"ConstructTerm - Explode")

  ConstructTerm : 
    Op("", args) -> expr|[ termFactory.makeTuple(~*args') ]|
  where prelude(|"ConstructTerm - Op(\"\", [...])") ;
        <map(construct-term)> args => args'
    
  ConstructTerm :
    Op("Nil", []) -> expr|[ termFactory.makeList() ]|
  where prelude(|"ConstructTerm - Op(Nil, [])")

  ConstructTerm :
    Op("Cons", [t1, t2]) -> 
    expr|[ 
      ((IStrategoList)(~expr:e)).prepend(~expr:<construct-term> t1)
    ]|
  where prelude(|"ConstructTerm - Cons");
        <construct-term> t2
      ; if <not(Anno(is-ListOp,id))> t2 then 
          check-aterm-list 
        else
          if ?Id(_) then
	    !|[ (IStrategoList) ~expr:<id> ]|
          else
            try(UncastATerm)
          end
          ; try(CastATermListSetAnnotations)
        end => e

  check-aterm-list :
    e -> expr|[ (IStrategoList)~id:x ]|
  where prelude(|"check-aterm-list") ;
       !Id(<newname> "trm") => x
	 ; FailureLabel => F
	 ; stms := 
	     (bstm |[ IStrategoList ~id:x; ]|, 
          bstm*|[ ~id:x = checkTermList((IStrategoList)~expr:e);
                  if(~id:x == null) ~stm:<Goto> F ]|)
     ; rules( CheckList :+ _ -> stms )

  CastATerm :
    e -> expr|[ (IStrategoTerm) ~expr:e ]|

  CastATermListSetAnnotations :
    expr|[ termFactory.setAnnotations(~expr:e1, ~expr:e2) ]| -> expr|[ (IStrategoList) termFactory.setAnnotations(~expr:e1, ~expr:e2) ]|

  UncastATerm :
    expr|[ (IStrategoTerm)~expr:e ]| -> e

  VarToReadRef : 
    Var(x){} -> ExprName(Id(x))

  VarToReadRef :
    Var(x){Frames([])} -> ExprName(Id(x))

  VarToReadRef :
    Var(x){Offset(i), Frames([])} -> ExprName(Id(x))

  VarToReadRef : 
    Var(x){Offset(i), Frames(frames)} -> 
    expr|[ sl_readvar(~expr:<mk-int-const> i, ~expr:sl) ]|
  where <not([]); frames-to-static-link> frames => sl

signature
  constructors
  
    Offset: Int -> Term
    Frames: List(Term) -> Term
    
/**
 * Signatures
 */
strategies

  Translate =
      fragment(DeclareConstructor|"ConstructorDecl")
    ; fragment(InitConstructorQ <+ InitConstructor|"ConstructorInit")

  DeclareConstructor :
    OpDecl(c, t) -> class-body-dec|[ static IStrategoConstructor ~id:Id(csym); ]|
    where prelude(|"DeclareConstructor") ;
          <Arity> t => n
        ; csym := <concat-strings> ["sym_", <cify> c, "_", <int-to-string> n]
        ; rules(ConstructorName : (c, n) -> csym)

  Arity : 
    ConstType(t) -> 0

  Arity : 
    FunType(ts, t) -> <length> ts

  InitConstructorQ :
    OpDecl(c, t) ->
    bstm*|[
      ~id:csym = ATmakeSymbol(~expr:Lit(String([Chars(<double-quote> c')])), 
			                  ~expr:<mk-int-const> ar,
			                  ATtrue);
    ]|
    where <string-as-chars(unescape-chars; un-double-quote-chars)> c => c' 
        ; <Arity> t => ar
        ; <ConstructorName> (c, ar) => csym

  InitConstructor :
    OpDecl(c, t) ->
    bstm*|[
      ~id:csym = termFactory.makeConstructor(~expr:Lit(String([Chars(c)])), 
                                             ~expr:<mk-int-const> ar);
    ]|
    where ar   := <Arity> t
        ; csym := Id(<ConstructorName> (c, ar))

/* ================================ Match */
strategies

  translate-Match(|S,F) :
    Match(t) -> <translate-Match(|S,F)> Match(t, ExprName(Id("term")))
  where prelude(|"translate-Match - Match/1");
    <debug> t

  translate-Match(|S,F) :
    Match(Wld(), trm) -> <Goto> S
  where prelude(|"translate-Match - Match(Wld,trm)")

  translate-Match(|S,F) :
    Match(As(t1,t2), trm) ->
    stm|[ 
      { 
        ~stm:(<translate-Match(|Next(),F)> Match(t1,trm))
        ~stm:(<translate-Match(|S,F)> Match(t2,trm))
      }
    ]|
  where prelude(|"translate-Match - Match(As(t1,t2), trm)")

  translate-Match(|S,F) :
    Match(Var(x){"unbound"}, trm) ->
    stm|[ { ~e = ~expr:trm; ~stm:<Goto> S } ]|
  where prelude(|"translate-Match - Match(Var(x){unbound}, trm)");
    <VarToWriteRef> x => e


  translate-Match(|S,F) :
    Match(Var(x){"bound"}, trm) ->
    stm|[ 
      if( ~expr:e == ~expr:trm ) 
        ~stm:<Goto> S
      else 
        ~stm:<Goto> S
     ]|
    where prelude(|"translate-Match - Match(Var(x){bound}, trm)");
      <VarToReadRef> x => e

  translate-Match(|S,F) :
    Match(Var(x){"(un)bound"}, trm) ->
    stm|[ 
      if( ~expr:e1 == null )
        { 
          ~e2 = ~expr:trm; 
          ~stm:<Goto> S
        }
      else if( !(~expr:e1).equals(~expr:trm) )
        ~stm:<Goto> F
      else
        ~stm:<Goto> S
    ]|
    where prelude(|"translate-Match - Match(Var(x){(un)bound})");
      e1 := <VarToReadRef> Var(x)
	; e2 := <VarToWriteRef ; ?ExprName(<id>)> Var(x)
	; <debug> (e1, e2)

  VarToWriteRef :
    Var(x){} -> ExprName(Id(x))

  VarToWriteRef :
    Var(x){Frames([])} -> ExprName(Id(x))

  VarToWriteRef : 
    Var(x){Offset(i), Frames([])} -> ExprName(Id(x))

  VarToWriteRef : 
    Var(x){Offset(i), Frames(frames)} -> 
    expr|[ sl_readvar(~expr:<mk-int-const> i, ~expr:sl) ]|
    where <not([]); frames-to-static-link> frames => sl

  translate-Match(|S,F) :
    Match(Var(x){}, trm) -> <translate-Match(|S,F)> Match(Var(x){"(un)bound"}, trm)
  where prelude(|"translate-Match - Match(Var(x){}")

  translate-Match(|S,F) :
    Match(Explode(t1, t2), Id(trm)) ->
    stm|[ 
    {
      ATerm ~id:x, ~id: y;
	 ~id:x = SSL_get_constructor(~id:trm);
	 ~id:y = SSL_get_arguments(~id:trm);
	 ~stm:(<translate-Match(|Next(),F)> Match(t1, x))
	 ~stm:(<translate-Match(|S,F)> Match(t2, y))
     } ]|
    where prelude(|"translate-Match - Match(Explode)") ;
          !Id(<newname> "trm") => x
        ; !Id(<newname> "trm") => y

  translate-Match(|S,F) =
       TranslateMatchNoAnno(|S,F)
    <+ TranslateMatchAnno(|S,F)

  TranslateMatchNoAnno(|S,F) :
    Match(Anno(pt1, Wld()), trm) -> <translate-Match(|S,F)> Match(pt1, trm)
  where prelude(|"TranslateMatchNoAnno - Match(pt1{^_}")
    

  TranslateMatchAnno(|S,F) :
    Match(Anno(pt1, pt2), Id(trm)) -> 
    stm|[ 
      { 
        ATerm ~id:x; 
        ~id:x = (ATerm)ATgetAnnotations(~id:trm);
        if(~id:x == NULL) 
           ~id:x = (ATerm) ATempty;
        ~stm:(<translate-Match(|Next(),F)> Match(Var(pt1), Id(trm)))
        ~stm:(<translate-Match(|S,F)> Match(Var(pt2), Id(x)))
      } 
    ]|
    where prelude(|"TranslateMatchAnno - Match(ptr1{^pt2})");
          <not(?Wld())> pt2
        ; !Id(<newname> "trm") => x

  /**
   * @todo  String constants should probably be cached, just like constructor names
   */
  translate-Match(|S,F) :
    Match(Str(x), trm) -> 
    stm|[
      if((~expr:trm).getTermType() == IStrategoTerm.STRING && ((IStrategoString)(~expr:trm)).getValue().equals(~expr:x'))
        ~stm:<Goto> S
      else 
        ~stm:<Goto> F
    ]|
  where prelude(|"translate-Match - Match(Str)");
        !Lit(String([Chars(<escape> x)])) => x'

  translate-Match(|S,F) :
    Match(Int(i), trm) -> 
    stm|[
      if(((~expr:trm).getTermType() == IStrategoTerm.INT) && ((IStrategoInt)~expr:trm).getValue() == ~expr:x')
        ~stm:<Goto> S
      else 
        ~stm:<Goto> F
    ]|
  where prelude(|"translate-Match - Match(Int)");
        <mk-int-const> i => x'

  translate-Match(|S,F) :
    Match(Real(i),trm) -> 
    stm|[
      if(((~expr:trm).getTermType() == IStrategoTerm.REAL) && (((IStrategoReal)~expr:trm).getValue() == ~expr:x'))
        ~stm:<Goto> S
      else 
        ~stm:<Goto> F
    ]|
  where prelude(|"translate-Match - Match(Real)");
        !Lit(Float(<try(real-to-string)> i)) => x'

  /**
   * Translate a match of an Op, but not a Cons/2 or Nil/0.
   */
  translate-Match(|S,F) :
    Match(op@Op(c, ts), trm) ->
    stm|[
      if( matchConstructor(~expr:trm, ~id:cname) )
        { 
          ~bstm*:match-args
          ~stm:<Goto> S
        }
      else
        ~stm:<Goto> F
    ]|
  where prelude(|"translate-Match - Match(Op)");
       <not(is-ListOp)> op
     ; cname := Id(<ConstructorName> (c, <length> ts))
     ; <thread-map(\ (t,i) ->
             (
               <MatchArg1(|Next(),F) <+ MatchArg2(|Next(),F)> 
                  (t, expr|[ ((IStrategoAppl)~expr:trm).getSubterm(~expr:<mk-int-const> i) ]|)
             , <add>(i, 1)
             )
           \ )> (ts,0) => (match-args,_)

  MatchArg1(|S,F) : 
    (Var(x){t*}, trm) -> <translate-Match(|S,F)> Match(Var(x){t*}, trm)
  where prelude(|"MatchArg1")
    

  MatchArg2(|S,F) : 
    (t, trm) -> 
    stm|[ 
      { 
         ATerm x = ~expr:trm; 
         ~stm:(<translate-Match(|S,F)> Match(t, Id(x)))
      } 
    ]|
  where prelude(|"MatchArg1");
        <newname> "trm" => x

  translate-Match(|S,F) :
    Match(Op("Nil", []), trm) ->
    stm|[
      if((ATgetType(~expr:trm) == AT_LIST) && ATisEmpty(~expr:trm))
        ~<Goto> S
      else 
        ~<Goto> F
    ]|
  where prelude(|"translate-Match - Match(Op(Nil))")

  translate-Match(|S,F) :
    Match(Op("Cons", [hd, tl]), trm) ->
    stm|[
      if((ATgetType(~expr:trm) == AT_LIST) && !(ATisEmpty(~expr:trm)))
        { 
          ~bstm*:match-args 
          ~stm:<Goto> S
        }
      else
        ~stm:<Goto> S
    ]|
    where <map(MatchArg1(|Next(),F) <+ MatchArg2(|Next(),F))> 
	   [(hd, expr|[ ATgetFirst((ATermList)~expr:trm) ]|), 
            (tl, expr|[ (ATerm)ATgetNext((ATermList)~expr:trm) ]|)] => match-args

/**
 * Fragments
 */

strategies

  fragment(s|tp) =
    where(s; ?x; rules( Fragment :+ tp -> x ))

/**
 * Frames
 */
 
strategies
 
  frames-to-static-link =
    (Tl <+ debug(!"*** frames-to-static-link error: "); fail)
    ; foldr(!expr|[ sl ]|,
	    !expr|[ sl_up(~expr:<Snd>) ]|)
    