/**
 * Java output postprocessing.
 *
 * @author Lennart Kats
 */
module java-postprocess

imports
  libjava-front

overlays

  /**
   * Minimum number of statements in an init method required to split it up,
   * in order to circumvent the 64K method size limit.
   */
  LARGE_METHOD_SIZE = 600

strategies

  java-relabel =
    java-relabel(|"NO_FAIL_LABEL", "NO_SUCCESS_LABEL", "NO_OUTER_LABEL")

  java-relabel(|failure, success, outer-fail) =
    java-relabel-outer-label(|failure, success, outer-fail)
  <+
    java-relabel-success-label(|failure, success, outer-fail)
  <+
    java-relabel-stm(|failure, success, outer-fail)
  <+
    all(java-relabel(|failure, success, outer-fail))
  
  java-relabel-stm(|failure, success, outer-fail) :
    |[ Fail: { bstm* } ]| -> |[ x_label': { bstm'* } ]|
    with
      x_label' := <newname> "Fail"
    ; bstm'*   := <java-relabel(|x_label', success, failure)> bstm*
  
  java-relabel-success-label(|failure, success, outer-fail) :
    |[ Success: { bstm* } ]| -> bstm |[ x_label': { bstm'* } ]|
    with
      x_label' := <newname> "Success"
    ; bstm'*   := <java-relabel(|failure, x_label', outer-fail)> bstm*
   
  java-relabel-outer-label(|failure, success, outer-fail) :
    |[ OuterFail: { bstm* } ]| -> bstm |[ { bstm'* } ]|
    with
      bstm'* := <java-relabel(|outer-fail, success, outer-fail)> bstm*
  
   java-relabel-stm(|failure, success, outer-fail) :
     Id("Fail") -> Id(failure)
   
   java-relabel-stm(|failure, success, outer-fail) :
     Id("Success") -> Id(success)
   
   java-relabel-stm(|failure, success, outer-fail) :
     Id("OuterFail") -> Id(outer-fail)

strategies

  java-split-method =
    try(java-split-method' <+ ![<id>])

  java-split-method' :
    class-body-dec |[
      mod* t x(param*) {
        bstm*
      }
    ]| ->
    class-body-dec* |[ 
      ~*<java-split-method> |[
        mod* t x(param*) {
          x'(e_param*);
          bstm2*
        }
      ]|

      mod2* t x'(param*) {
        bstm1*
      }
    ]|
    where
      <gt> (<length> bstm*, LARGE_METHOD_SIZE())
    with
      x'               := <newname> x
    ; e_param*         := <map(java-param-to-arg)> param*
    ; mod2*            := <map(try(\<Public + Protected> -> Private()\))> mod*
    ; (bstm1*, bstm2*) := <split-at(|LARGE_METHOD_SIZE())> bstm*

  java-param-to-arg :
    param |[ t x ]| -> expr |[ x ]|

strategies

  java-simplify =
    topdown-consnil(
      try(Block(flatten-list))
    ; repeat(java-simplify-stm + java-simplify-expr)
    )

  topdown-consnil(s) =
    rec rec(s; all-consnil(rec))
  
  all-consnil(s) =
    ?[_ | _] < [s | s] + all(s)
  
  java-simplify-stm :
    [<Empty + Semicolon> | s*] -> s*
  
  java-simplify-stm :
    If(e, s1, Empty()) -> If(e, s1)
  
  java-simplify-stm :
    Block([Block(s)]) -> Block(s)
  
  java-simplify-stm :
    |[ if (e1 == e2) ; else stm2 ]| -> |[ if (e1 != e2) stm2 ]|
  
  java-simplify-expr :
    |[ new Strategy[] {} ]| -> |[ NO_STRATEGIES ]|
  
  java-simplify-expr :
    |[ new IStrategoTerm[] {} ]| -> |[ NO_TERMS ]|
    
  java-simplify-stm :
    bstm* |[ if (TRACES_ENABLED) stm bstm* ]| -> bstm* |[ stm bstm* ]|
    where
      <get-config> "--stacktrace" => 1

  java-simplify-stm :
    bstm* |[ if (TRACES_ENABLED) stm bstm* ]| -> bstm*
    where
      <get-config> "--stacktrace" => 0
  
  java-eliminate-stacktrace =
    alltd(
      \bstm |[ if (TRACES_ENABLED) stm ]| -> Empty()\
    )

strategies

  java-optimize =
    topdown-consnil(repeat(
      optimize-match-test
    + optimize-assignments
    ))
  ; bottomup(repeat( // should be done after previous pass
      optimize-conditionals
    ))

  optimize-match-test :
    bstm* |[
      IStrategoTerm x_cached = term;
      Success: {
        Fail: {
          ~bstm*:<match-decls-and-appl-test => (bstm_decl*, x_cons, bstm_body*)>
        }
        term = x_cached;
        bstm_othermatch*
      }
      bstm_tail*
    ]| ->
    bstm* |[
      IStrategoTerm x_cached = term;
      IStrategoConstructor x_actualcons = term.getTermType() == IStrategoTerm.APPL
        ? ((IStrategoAppl) term).getConstructor()
        : null;
      Success: {
        if (x_actualcons == x_cons) {
          Fail: {
            bstm_decl*
            bstm_body*
          }
          term = x_cached;
        }
        bstm_othermatch'*
      }
      bstm_tail*
    ]|
    with
      x_actualcons := <newname> "cons"
    where
      bstm_othermatch'* := <replace-match-test1(|x_actualcons, x_cached)> bstm_othermatch*

  replace-match-test1(|x_actualcons, x_cached) :
    bstm* |[
      IStrategoTerm x_cached' = term;
      Success: {
        Fail: {
          ~bstm*:<match-decls-and-appl-test => (bstm_decl*, x_cons, bstm_body*)>
        }
        term = x_cached';
        bstm_othermatch*
      }
      bstm_tail*
    ]| ->
    bstm* |[
      Success: {
        if (x_actualcons == x_cons) {
          Fail: {
            bstm_decl*
            bstm_body*
           }
          term = x_cached;
        }
        bstm_othermatch'*
      }
      bstm_tail*
    ]|
    with
      bstm_othermatch'* := <try(replace-match-test1(|x_actualcons, x_cached))> bstm_othermatch*
  
  match-decls-and-appl-text :
    [Block(bstm*) | _] -> <match-decls-and-appl-test> bstm*
  
  match-decls-and-appl-test :
    bstm* |[ IStrategoTerm x = null; bstm* ]| -> ([<Hd> | bstm_decl*], x_cons, bstm_body*)
    where
      (bstm_decl*, x_cons, bstm_body*) := <match-decls-and-appl-test> bstm*
    
  match-decls-and-appl-test :
    bstm* |[
      if (~e:ExprName(Id("term")).getTermType() != IStrategoTerm.APPL || e_cons != ((IStrategoAppl) term).getConstructor())
        break Fail;
      bstm_body*
    ]| ->
    ([], x_cons, bstm_body*)
    with
      !e_cons => |[ x.x_cons ]|
    <+
      !e_cons => |[ x_cons ]|

  optimize-conditionals :
    bstm |[ Fail: { if (TRUE) break Fail; bstm1* } ]| -> bstm |[ ; ]|

  optimize-conditionals :
    bstm |[ { if (TRUE) break x; bstm* } ]| -> bstm |[ { if (TRUE) break x; } ]|
    where
      not(!bstm* => [])
  
  optimize-conditionals :
    bstm |[ if (e) if (TRUE) stm ]| -> |[ if (e) stm ]|
  
  optimize-conditionals :
    bstm |[ Success: { if (e) break Success; bstm* } ]| -> |[ if (!e) { bstm* } ]|
  
  optimize-conditionals :
    bstm |[ if (!(e1 == e2)) stm ]| -> |[ if (e1 != e2) stm ]|
  
  optimize-conditionals :
    bstm |[ if (e1) { if (e2) stm } ]| -> |[ if (e1 && e2) stm ]|
    where
      not(!e2 => expr |[ TRUE ]|)
  
  optimize-conditionals :
    |[ Fail: { bstm* } ]| -> |[ Fail: { bstm'* } ]|
    where
      !bstm*
    ; one(?|[ if (e) break Fail; ]|)
    ; at-last([remove-if-true]) => bstm'*
  
  optimize-conditionals :
    Block([Block(s)]) -> Block(s)
  
  optimize-assignments :
    bstm* |[ term = y; x = term; term = z; bstm* ]| ->
    bstm* |[ x = y; term = z; bstm* ]|
    where
      not(!z => expr |[ term ]|)
  
  optimize-assignments :
    bstm* |[ x = y; x = e; bstm* ]| ->
    bstm* |[ x = e; bstm* ]|
    where
      not(<oncetd(?x)> e)
  
  remove-if-true :
    |[ if (TRUE) break Fail; ]| -> |[ break Fail; ]|
  
  remove-if-true :
    |[ if (TRUE) break Success; ]| -> |[ break Success; ]|
  
  remove-if-true :
    |[ if (TRUE) return e; ]| -> |[ return e; ]|
