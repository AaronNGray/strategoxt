
/**
 * Java backend for the Stratego compiler
 *
 * @author Karl Trygve Kalleberg
 * @author Lennart Kats
 * @author Eelco Visser
 */
module s2j

imports
  shared-constructors
  
  libstrc
  libstratego-xtc
  libstratego-lib
  libjava-front

  java-postprocess
  variable-lifting
  variable-access
  backend-simplify
  s2j-options
  lib/dr-scoping

signature
  constructors 
    Next  : Term
    Match : Term * Exp -> Exp
    Offset: Int -> Term
    Frames: List(Term) -> Term
    
    // stategoxt-annos extension:
    AnnoDef  : List(Anno) * Def -> Annos
    Extend   : Anno
    Override : Anno
    Internal : Anno
    Escape   : Stm -> Strategy

overlays

  MAX_STATIC_TARGS = 5
  MAX_STATIC_SARGS = 5
    
strategies

  main-s2j =
    io-wrap(
      s2j-options
    ,
      s2j
    )
 
rules
    
  s2j = 
      with(
        s2j-init-options
      ; record-main-classname
      )
    ; log-timed(
        backend-simplify
      | "Backend preprocessing succeeded", 1
      )
    ; log-timed(
        dr-scope-all-verbose(java-compile-spec)
      | "Backend transformation succeeded", 1
      )
    ; log-timed(
        java-simplify
      ; olevel1(java-optimize)
      ; java-relabel
      | "Backend postprocessing succeeded", 1
      )
     
  record-main-classname = 
    <get-config> "-i"
  ; base-filename
  ; jify
  ; remove-extension
  ; rules(
      MainClassName := <id>
    )
  
  jify =
    escape(Jify)
  
  Jify(x) =
    \['_'  | cs] -> ['_' | <x> cs]\
  <+
    Cify(x)
  
  java-compile-spec :
    Specification([Signature([Constructors(ops)]), Strategies(defs)]) -> 
     |[ 
     ~package-dec?: pkgname
     
     ~import-dec*:imports

     import org.strategoxt.lang.*;
     import org.spoofax.interpreter.terms.*;
         
     import static org.strategoxt.lang.Term.checkListTail;
     import static org.strategoxt.lang.Term.checkListAnnos;
     import static org.strategoxt.lang.Term.EMPTY_STRATEGY_LIST;
     import static org.strategoxt.lang.Term.EMPTY_TERM_LIST;
         
     @SuppressWarnings({"unused"})
     public class x_name {

     private static boolean TRACES_ENABLED = e_traces;
     private static boolean TRUE = true; // (ECJ 3.3 reachability detection bug workaround)
     private static ITermFactory constantFactory;

     ~*cnst-decls
     ~*cnstr-decls
     
     public static void init(Context context) {
       ITermFactory termFactory = context.getFactory();
       if (constantFactory == termFactory)
         return;
       constantFactory = termFactory;
       ~*import-inits
       ~*cnstr-inits
       ~*cnst-inits
       ~*def-inits
       context.postInit("~x_name");
     }

     ~*main
     ~*constant

     ~*constant-defs
     ~*function-defs
     ~*lifted-defs

     }
     ]|
  with 
      alltd(JavaTranslate)
    ; imports       := <java-imports>
    ; import-inits  := <java-init-imports>
    ; x_name        := <MainClassName>
    ; pkgname       := <!package-dec? |[ package ~x:<get-config> "-p"; ]| <+ !None()>
    ; main          := <java-main-methods>
    ; constant      := <java-constant-methods>
    ; switch <get-config> "--stacktrace"
        case 0: e_traces := |[ false ]|
        case 1: e_traces := |[ true ]|
        case 2: e_traces := |[ x_name.class.desiredAssertionStatus() ]|
      end
  with
    rules(
      CurrentLiftedFrame := None()
    )
  ; function-defs := <map(translate-outer-definition)> defs
  ; add-default-constructors
  ; constant-defs := <map(translate-constant-definition)> <get-config <+ ![]> "-D"
  ; lifted-defs   := <bagof-LiftedDef>
  ; cnstr-decls   := <bagof-ConstructorDecl>
  ; cnstr-inits   := <bagof-ConstructorInit>
  ; def-inits     := <bagof-DefInit>
  ; cnst-decls    := <bagof-ConstDecl>
  ; cnst-inits    := <bagof-ConstInit; concat; reverse>
  
  java-imports =
    <get-config> "-la"
  ; map(java-import)
  <+
    ![]
  
  java-init-imports =
    <get-config> "-la"
  ; map(java-init-import)
  <+
    ![]
  
  java-import :
    x -> StaticImportOnDemandDec(TypeName(Id(x')))
    with
      x' := <jify> x
  
  java-init-import :
    x -> |[ x'.init(context); ]|
    with
      x' := <jify> x

  java-main-methods :
    _ -> []
    where
      <get-config> "--library"

  java-main-methods :
    _ ->
    |[
     public static String testMain(String inputTerm) {
        Context context = new Context();
        init(context);
        try {
          IStrategoTerm result = x_main.instance.invoke(context, context.getFactory().parseFromString(inputTerm));
          context.uninit();
          return result == null ? null : result.toString();
        } catch (StrategoExit exit) {
          return null;
        }
     }
        
     public static void main(String args[]) {
        Context context = new Context();
        init(context);
        try {
          IStrategoTerm result = context.invokeStrategyCLI(x_main.instance, "~x_name", args);
          context.uninit();
          if (result == null) {
            System.err.println("~x_name" + (TRACES_ENABLED ? ": rewriting failed, trace:" : ": rewriting failed"));
            context.printStackTrace();
            System.exit(1); 
          } else {
            System.out.println(result);
          }
        } catch (StrategoExit exit) {
          System.exit(exit.getValue());
        }
     }
    ]|
    where
      not(<get-config> "--library")
    with
      x_name := <MainClassName>
    ; main   := <get-config <+ !"main"> "-m"
    ; x_main := <conc-strings> (<jify> main, "_0_0")

  java-constant-methods =
    !|[
      private static IStrategoTerm getConstant(ITermFactory factory, IStrategoTerm constant) {
        if (factory == constantFactory) {
          return constant;
        } else if (factory != null) {
          return new TermConverter(factory).convert(constant);
        } else {
          throw new IllegalStateException("Component not initialized; please call init() first");
        }
      }
     
      private static IStrategoTerm getConstant(ITermFactory factory, ITermReference constant) {
        if (factory == constantFactory) {
          return constant.get();
        } else if (factory != null) {
          return new TermConverter(factory).convert(constant.get());
        } else {
          throw new IllegalStateException("Component not initialized; please call init() first");
        }
      }
    ]|

rules

  translate-constant-definition : // TODO: check if contant definition name not taken
    (name, value) -> def'
    with
      name'  := <conc-strings> (<cify> name, "_0_0")
    ; def    := SDefT(name', [], [], Build(value))
    ; def'   := <translate-outer-definition> def
  
  translate-outer-definition =
     translate-outer-definition-plain
  <+ translate-outer-definition-override
  <+ translate-outer-definition-extend
  <+ translate-outer-definition-internal
  <+ translate-outer-definition-conflict
  
  translate-outer-definition-plain :
    SDefT(x, s*, t*, s){a*} -> 
    type-dec |[
       public static class x extends Strategy {
         public static x instance = new x();
         
         ~body
         ~invokedynamic*
       }
    ]|
    with
      body           := <translate-definition-body>
    ; invokedynamic* := <maybe-make-invoke-dynamic> (s*, t*)

  translate-outer-definition-override :
    AnnoDef([Override()], def @ SDefT(x, s*, t*, s)) ->
    type-dec |[
       private static final class x' extends x {
         ~(body)
         @Override public String getName() { return "~x"; }
       }
    ]|
    with
      x' := <conc-strings> (x, "_override")
    ; rules(DefInit :+= |[ x.instance = new x'(); ]|)
    with
      e_s*      := <translate-args> s*
    ; e_t*      := <translate-args> t*
    ; outercall := |[ term = outer.invoke(context, term, e_s*, e_t*); ]|
    ; def'      := <alltd(\Override() -> outercall\)> def
    ; body      := <translate-definition-body> def'

  translate-outer-definition-extend :
    AnnoDef([Extend()], def @ SDefT(x, s*, t*, s)) ->
    type-dec |[
       private static final class x' extends x {
         private static final x outer = x.instance;
         ~(body)
         @Override public String getName() { return "~x"; }
       }
    ]|
    with
      x' := <conc-strings> (x, "_extension")
    ; rules(DefInit :+= |[ x.instance = new x'(); ]|)
    with
      e_s*      := <translate-args> s*
    ; e_t*      := <translate-args> t*
    ; outercall := |[ term = outer.invoke(context, term, e_s*, e_t*); ]|
    ; def'      := SDefT(x, s*, t*, GuardedLChoice(s, Id(), Escape(outercall)))
    ; body      := <translate-definition-body> def'

  translate-outer-definition-internal :
    AnnoDef([Internal()], def @ SDefT(x, s*, t*, s)) ->
    type-dec |[
       private static final class x extends Strategy {
         public static final x instance = new x();
         
         ~body
         ~invokedynamic*
       }
    ]|
    with
      body := <translate-definition-body> def
    ; invokedynamic* := <maybe-make-invoke-dynamic> (s*, t*)

  translate-outer-definition-conflict :
    AnnoDef(a*, SDefT(x, _, _, _)) -> ()
    with
      fatal-err(|["conflicting annotations for strategy ", x])

  translate-inner-definition :
    SDefT(x, s*, t*, s) ->
    type-dec |[
       private static final class x extends Strategy {
         ~instance-field*
         ~lifted-tfield*
         ~lifted-sfield*
         
         ~body
         ~invokedynamic*
       }
    ]|
    with
      ?def
    ; lifted-tvar*   := <collect-lifted-tvars> def
    ; lifted-svar*   := <collect-lifted-svars> def
    ; lifted-sfield* := <map(\y -> class-body-dec |[ IStrategy y;      ]|\)> lifted-svar*
    ; lifted-tfield* := <map(\y -> class-body-dec |[ ITermReference y; ]|\)> lifted-tvar*
    ; lifted-args    := <conc> (lifted-svar*, lifted-tvar*)
    with
      if !lifted-tvar* => lifted-svar* => [] then
        instance-field* := class-body-dec* |[ public static final x instance = new x(); ]|
      else
        instance-field* := []
      end
    with
      {| CurrentLiftedFrame :
        rules(CurrentLiftedFrame := x{})
      ; body           := <java-eliminate-stacktrace> <translate-definition-body>
      ; invokedynamic* := <maybe-make-invoke-dynamic> (s*, t*)
      |}
  
  maybe-make-invoke-dynamic :
    (s*, t*) -> invokedynamic*
    with
      if is-dynamic-signature(|s*, t*) then
        invokedynamic* := [<make-invoke-dynamic> (s*, t*)]
      else
        invokedynamic* := []
      end
    
  make-invoke-dynamic :
    (s*, t*) ->
    |[ @Override
       public IStrategoTerm invokeDynamic(Context context, IStrategoTerm term,
                                          IStrategy[] sargs, IStrategoTerm[] targs) {
         if (sargs == null || targs == null || sargs.length != i_slength || targs.length != i_tlength)
           throw new IllegalArgumentException("Illegal arguments for " + getName());
         
         return invoke(context, term, e_s*, e_t*);
       }
    ]|
    with
      i_slength := <write-to-string> <length> s*
    ; i_tlength := <write-to-string> <length> t*
    ; e_s*      := <number(\(_,n) -> |[ sargs[~i:<write-to-string> n] ]|\)> s*
    ; e_t*      := <number(\(_,n) -> |[ targs[~i:<write-to-string> n] ]|\)> t*
  
  translate-definition-body :
    SDefT(x, s*, t*, s) ->
    |[ mod_override*
       public IStrategoTerm invoke(Context context, IStrategoTerm term, param*) {
           ITermFactory termFactory = context.getFactory();
           bstm_init*
           if (TRACES_ENABLED) context.push("~x");
           Fail: {
             bstm
             if (TRACES_ENABLED) context.popOnSuccess();
             if (TRUE) // (avoid unreachable stm error)
               return term;
           };
           if (TRACES_ENABLED) context.popOnFailure();
           return null;
       }
    ]|
    with
      {| IsStrategyArg, java-CheckBuild, CurrentLiftedFrame:
        (s'*, [])          := <translate-params> s*
      ; (t'*,  bstm_init*) := <translate-params> t*
      ; param*             := <conc> (s'*, t'*)   
      ; if is-dynamic-signature(|s*, t*) then
          mod_override* := []
        else
          mod_override* := [ anno |[ @Override ]| ]
        end
      ; bstm := <translate-body> s  
      |}
    
  translate-outer-definition :
    ExtSDef(_, _, _) -> Semicolon()

  /**
   * Translates strategy formal parameters to method parameters and initialization.
   */
  translate-params =
    unzip(translate-param)
  ; (id, concat)

  translate-param :
    VarDec(x{}, ConstType(_)) -> (param |[ IStrategoTerm x ]|, [])

  translate-param :
    VarDec(x{Offset(_), Escapes()}, ConstType(_)) ->
    ( param |[ IStrategoTerm x' ]|
    , bstm* |[ TermReference x = new TermReference(x'); ]|)
    with
      x' := <conc-strings> ("ref_", x)
  
  translate-param : 
    VarDec(x, FunType(_, _)) -> (param |[ IStrategy x ]|, [])
    with
      x'    := x{}
    ; frame := <CurrentLiftedFrame>
    ; rules(IsStrategyArg: (frame, x'))

  /**
   * Translates strategy formal parameters to call arguments.
   */
  translate-args =
    map(translate-arg)

  translate-arg :
    VarDec(x{}, ConstType(_)) -> expr |[ x ]|

  translate-arg :
    VarDec(x{Offset(_), Escapes()}, ConstType(_)) -> expr |[ x.get() ]|
  
  translate-arg : 
    VarDec(x, FunType(_, _)) -> expr |[ x ]|
  
strategies
  
  /** @type Strategy -> Stm */
  translate-body = 
    translate-strategy

  translation-failed = ?x#(_) ; log(|Error(), [ "Unknown constructor type ", x ]) ; fail
  
  translate-Scope : 
    Scope(vars, body) -> bstm* |[ bstm_decl* bstm_body ]|
    with
      bstm_decl* := <map(to-java-vardecl)> vars
    ; bstm_body  := <translate-strategy> body
    
  /** @type Id -> Stm */
  translate-Id :
    Id() -> Empty()
    
  /** @type Id -> Stm */
  translate-Fail :
    Fail() -> |[ if (TRUE) break Fail; ]| // (avoid unreachable stm error)

  translate-Override :
    Override() -> <fatal-err(|"override call illegal in this context")>

  translate-Escape :
    Escape(java) -> java

  /** @type Seq -> Stm */
  translate-Seq :
    Seq(s1, s2) -> 
    bstm* |[
        ~stm:<translate-strategy> s1 
        ~stm:<translate-strategy> s2 
    ]|

  /** @type GuardedLChoice -> Block */  
  translate-GuardedLChoice-no-left-branch :
    GuardedLChoice(s1, Id(), s2) ->
    bstm* |[
      // (this pattern is matched optimized in java-postprocess)
      IStrategoTerm x_termcopy = term;
      Success: {
        Fail: {
           stm_s1
           if (TRUE) // (avoid unreachable stm error)
             break Success;
        }
        term = x_termcopy;
        stm_s2
      }
    ]|
   with
     x_termcopy := <newname> "term"
   ; stm_s1     := <translate-strategy> s1
   ; stm_s2     := <translate-strategy> s2

  /** @type GuardedLChoice -> Block */  
  translate-GuardedLChoice :
    GuardedLChoice(s1, s2, s3) ->
    bstm* |[
      IStrategoTerm x_termcopy = term;
      Success: {
        Fail: {
           stm_s1
           OuterFail: { // (redirects failure to outer Fail block)
             stm_s2
             if (TRUE) // (avoid unreachable stm error)
               break Success;
           }
        }
        term = x_termcopy;
        stm_s3
      }
    ]|
   with
     x_termcopy := <newname> "term"
   ; stm_s1     := <translate-strategy> s1
   ; stm_s2     := <translate-strategy> s2
   ; stm_s3     := <translate-strategy> s3

  translate-strategy = 
       ( 
       translate-CallT-dynamic
    <+ translate-CallT
    <+ translate-Build
    <+ translate-Seq
    <+ translate-PrimT
    <+ translate-Id
    <+ translate-Fail
    <+ translate-Override
    <+ translate-GuardedLChoice-no-left-branch
    <+ translate-GuardedLChoice
    <+ translate-Scope
    <+ translate-Match
    <+ translate-Let
    <+ translate-ImportTerm
    <+ translate-Escape
    <+ fatal-err(|"translate-strategy failed ")
       )

  translate-Let : 
    Let(defs, body) -> body'
    with
      !defs
    ; record-inner-definitions
    ; list-loop(rules(LiftedDef :+= <translate-inner-definition>))
    ; body' := <translate-strategy> body

  record-inner-definitions =
    list-loop({
      if ?def @ SDefT(x, _, _, _) then
        x' := x{}
      ; rules(InnerDefinition: x' -> def)
      end
    })
  
  translate-CallT-dynamic:
    CallT(SVar(x), s*, t*) ->
    bstm* |[
      bstm_init*
      term = e_instance.invokeDynamic(context, term, new IStrategy[] { e_s* }, new IStrategoTerm[] { e_t* });
      if (term == null) 
        break Fail;
    ]|
    where
      is-dynamic-signature(|s*, t*)
    with
      lifted-decls-wrap(
        if <is-self-call> x then
          e_instance := |[ this ]|
        else
          e_instance := <lifted-call-to-instance>
        end
      ; e_s* := <map(lifted-strategy-to-instance)> s*
      ; e_t* := <map(java-construct-term)> t*
      ,
        ?bstm_init*
      )

  translate-CallT:
    CallT(SVar(x), s*, t*) ->
    bstm* |[
      bstm_init*
      term = e_instance.invoke(context, term, e_s*, e_t*);
      if (term == null) 
        break Fail;
    ]|
    with
      lifted-decls-wrap(
        if <is-self-call> x then
          e_instance := |[ this ]|
        else
          e_instance := <lifted-call-to-instance>
        end
      ; e_s* := <map(lifted-strategy-to-instance)> s*
      ; e_t* := <map(java-construct-term)> t*
      ,
        ?bstm_init*
      )

  translate-PrimT :
    CallDynamic(f, s*, t*) -> <fail>
    with
      fatal-err(|"Think again. Dynamic calls are not supported")

  translate-PrimT :
    PrimT(f, s*, t*) -> 
    <java-check-unbound-args(|t*)>  
    bstm* |[
      bstm_init*
      term = context.invokePrimitive("~f", term, new IStrategy[] { e_s* }, new IStrategoTerm[] { e_t* });
      if (term == null) break Fail;
    ]|
    with
      lifted-decls-wrap(
        e_s*  := <map(lifted-strategy-to-instance)> s*
      ; e_t*  := <map(java-construct-term)> t*
      ,
        ?bstm_init*
      )
  
  lifted-decls-wrap(s, get-init-stms) =
    dr-ignore-states( // (hide and then scope these dyn. rules)
      s
    ; with(
        <get-init-stms> <concat> [<bagof-CallTDecls> | <bagof-CallTAssigns>]
      )
    | ["CallTDecl", "CallTDecls", "CallTAssigns"]
    )
  
  lifted-strategy-to-instance =
    if ?CallT(_, _, _) then
      // Pass (potentially parameterizable) svar calls as-is
      lifted-call-to-instance
    else
      // Lift definition and produce call
      with(
        !SDefT(<newname => x> "jlifted", [], [], <id>)
      ; rules(DefInit :+= <translate-inner-definition>)
      )
    ; <lifted-call-to-instance> CallT(SVar(x), [], [])
    end
  
  lifted-call-to-instance =
    lifted-call-to-instance-self-call
  <+
    lifted-call-to-instance-from-frame
  <+
    lifted-call-to-instance-with-args
  <+
    lifted-call-to-instance-direct
  <+
    lifted-call-to-instance-instance
  
  lifted-call-to-instance-self-call :
    CallT(SVar(x), _, _) -> expr |[ this ]|
    where
      <is-self-call> x

  lifted-call-to-instance-from-frame :
    CallT(SVar(x{a*}), _, _) -> expr |[ x ]|
    where
      frame := <CurrentLiftedFrame>
    ; !a*
    ; one(?Offset(_))
    ; one(Frames(one(?frame)))
  
  lifted-call-to-instance-with-args :
    CallT(SVar(x), _, _) -> expr |[ x' ]|
    where
      sarg* := <LiftedSVars> x{}
    ; targ* := <LiftedTVars> x{}
    ; (!sarg* => [_ | _] + !targ* => [_ | _]) // needs lifting
    with
      if not(<CallTDecl> x => x') then // add declaration
        x' := <newname> x
      ; rules(
          CallTDecl: x -> x'
        )
      ; init := bstm |[ x x' = new x(); ]|
      ; rules(
          CallTDecls :+= init
        )
      ; e_sarg* := <map(\x -> <lifted-call-to-instance> CallT(SVar(x), [], [])\)> sarg*
      ; e_targ* := <map(\x -> ExprName(Id(x))\)> targ*
      ; assigns := <zip(\(x_field, e_value) -> |[ x'.x_field = e_value; ]|\)> ([sarg*, targ*], [e_sarg*, e_targ*])
      ; rules(
          CallTAssigns :+= assigns
        )
      end
  
  lifted-call-to-instance-direct :
    CallT(SVar(x{a*}), _, _) -> expr |[ x ]|
    where
      <IsStrategyArg> (<CurrentLiftedFrame>, x{})

  lifted-call-to-instance-instance :
    CallT(SVar(x), _, _) -> expr |[ x.instance ]|
  
  is-dynamic-signature(|s*, t*) =
    where(
      <gt> (<length> s*, MAX_STATIC_SARGS())
    + <gt> (<length> t*, MAX_STATIC_TARGS())
    )
  
/* ================================ Build  */

  translate-Build:
    Build(t) -> 
    <java-check-unbound-args(|t)> 
    bstm* |[
      ~*decs
      ~*stms
      term = e;
    ]|
    where
      {| java-CheckBuild :
         <java-construct-term> t => e
       ; bagof-java-CheckBuild; unzip; (id, reverse; concat) => (decs, stms)
      |}
      
  /**
   * Translate 'import-term'
   * - uses LazyTermReference for caching
   * - inlining construction would exceed max method limit
   *    even an array may have this effect
   *  - inlining a string could be an easy solution to inline it
   *    (minding the 32767 length limit)
   */
  translate-ImportTerm :
    ImportTerm(file) -> |[ term = getConstant(termFactory, x_constant); ]|
    with
      inputfile  := <find-import-term-file> file // (exits on error)
    ; outputfile := <base-filename> file
    ; pkgname    := <get-config <+ !""> "-p"
    ; pkgpath    := <conc-strings> ("/", <string-replace(|".", "/")> pkgname, "/")
    with
      outputdir := <get-config; dirname <+ !"."> "-o"
    ; copyfile  := <conc-strings> (outputdir, "/", outputfile)
    ; if not(<eq> (<modification-time> inputfile, <file-exists; modification-time> copyfile)) then
        <copy-file> (inputfile, copyfile)
      ; log(|Info(), ["Referenced imported term file ", file, "; copied to ", outputdir])
      <+
        fatal-err-msg(|["Could not copy imported term file ", inputfile, " to ", copyfile])
      else
        log(|Info(), ["Referenced imported term file ", file, "; exists in ", outputdir])
      end
    with
      x_constant := <newname> "constImportTerm"
    ; x_main     := <MainClassName>
    ; rules(ConstDecl :+= class-body-dec |[ private static ImportTermReference x_constant; ]|)
    ; rules(
        ConstInit :+=
          bstm* |[ x_constant = new ImportTermReference(termFactory, x_main.class, "~pkgpath", "~outputfile"); ]|
      )
   
  find-import-term-file :
    file -> file'
    with
      pack-stratego-options-wrap(
        pack-include-path
      ; getfirst(pack-find-from-dir(|file)) => file'
      <+
        basefile := <base-filename> file
      ; pack-include-path
      ; getfirst(pack-find-from-dir(|basefile)) => file'
      )
    <+
      file' := <file-exists> file
    <+
      fatal-err(|["file ", file, " for imported term not found"])
      
  pack-stratego-options-wrap(s) =
    finally(
      with(
        include* := <get-config <+ ![]> "-I"
      ; <set-config> ("-I", [])
      ; <parse-options(pack-stratego-options, system-usage, id)> [<whoami>, include*, "-I", "."]
      )
    ; s
    , <set-config> ("-I", include*)
    )

  java-check-unbound-args(|t) =
    try(java-CheckUnboundArgs(|t))

  java-CheckUnboundArgs(|t) :
    stm -> 
    bstm* |[
      if (e)
        break Fail;
      stm
    ]|
    where
      <collect({?Var(_){t*}; where(<not(["bound"])> t* )})> t
    ; not([])
    ; foldr1(!expr|[ ~expr:<Hd; java-ConstructVar> == null ]|
            ,!expr|[ ~expr:<Fst; java-ConstructVar> == null || ~expr:<Snd> ]|) => e

/**
 * Term construction with constant term caching
 */
rules

  // TODO: Fix constants being generated multiple times
  //       e.g., <conc> ([], []) does this; it's got something to do with annos 

  /** @type Term -> Exp */
  java-construct-term =
       java-Cache 
    <+ java-ConstructAnnoVar
    <+ java-ConstructVar
    <+ !(<id>, <java-ConstructTerm>)
       ; (java-CacheConstant-again <+ java-CacheConstant <+ Snd)

  java-CacheConstant-again :
    (t, e1 @ |[ getConstant(termFactory, e2) ]|) -> e1
    with
      rules(java-Cache: t -> e1)

  java-CacheConstant :
    (t, e1) -> |[ getConstant(termFactory, e2) ]|
  where
      <(Op(id, map(java-Cache)); java-proper-list 
            + Anno(java-Cache, java-Cache) 
            + Int(id) + Str(id) + Real(id) )> t
  with
        if !t => Op(op, _) then
          x := <newname> <conc-strings> ("const", <try(un-double-quote-chars); jify> op)
        else
          x := <newname> "const"
        end
      ; e2 := ExprName(Id(x))
      ; rules( java-Cache : t -> |[ getConstant(termFactory, e2) ]| )
      ; !(x, e1)
      ; rules(ConstDecl :+= <java-DeclareTermId>)
      ; rules(ConstInit :+= <java-InitTermId>)

 java-proper-list =
    Op("Nil", [])
    + Op("Cons", [id, java-proper-list])
    // UNDONE: + Op("Cons", [id, java-proper-list + ?|[ getConstant(e1, e2) ]|])
    + Op(id, id)
      ; not(is-ListOp)

// helpers

strategies
    
  is-TupleOp = ?Op("", _)

  java-DeclareTermId :
    (x, e) ->
    class-body-dec|[ private static IStrategoTerm x; ]|

  java-InitTermId :
    (x, e) -> bstm*|[ x = e; ]|

  java-mk-int-const =
    !Lit(Deci(<try(int-to-string)>))

rules

  java-ConstructTerm :
    Int(i) -> 
    expr|[ 
      termFactory.makeInt(~expr:<java-mk-int-const> i)
    ]|

  java-ConstructTerm :
    Real(x) -> 
    expr|[ 
      termFactory.makeReal(~expr:Lit(Float(<try(real-to-string)> x)))
    ]|

  java-ConstructTerm :
    Str(x) -> 
    expr|[ 
      termFactory.makeString(~expr:Lit(String([Chars(<escape> x)])))
    ]|

  java-ConstructVar :
    x@Var(_) -> e
  with 
      e := <java-VarToReadRef> x

  java-ConstructAnnoVar :
    Anno(Var(x), pt2) -> 
    expr|[ 
      termFactory.annotateTerm(e, checkListAnnos(termFactory, ~expr:<java-construct-term> pt2))
    ]|
  where
      <java-ConstructVar> Var(x) => e

  java-ConstructTerm :
    Anno(pt1, Op("Nil", [])) -> <java-construct-term> pt1
  where 
      <not(?Var(_))> pt1

  java-ConstructTerm :
    Anno(pt1, pt2) -> 
    expr|[ 
      termFactory.annotateTerm(~expr:<java-construct-term> pt1, checkListAnnos(termFactory, ~expr:<java-construct-term> pt2))
    ]|
  where 
      <not(?Op("Nil", []))> pt2
    ; <not(?Var(_))> pt1

//  java-ConstructTerm :
//    |[ _ t ]| -> <java-construct-term> t

  java-ConstructTerm :
    Op(c, t*) -> expr|[ termFactory.makeAppl(~*[cons | args]) ]|
  where
      not(is-ListOp + is-TupleOp)
  with
      cons := <java-ConstructorName-expr> (c, <length> t*)
    ; args := <map(java-construct-term)> t*
    
  java-ConstructTerm :
    Explode(t1, t2) -> expr |[ x ]|
    with
      e_t1 := <java-construct-term> t1
    ; e_t2 := <java-construct-term> t2
    ; x    := <newname> "mkterm"
    ; rules(
        java-CheckBuild :+=
          ( bstm |[ IStrategoTerm x; ]|
          , bstm*|[
               x = context.invokePrimitive("SSL_mkterm", term, new IStrategy[] {},
                                           new IStrategoTerm[] { e_t1, e_t2 });
               if (x == null)
                 break Fail;
            ]|)
      )

  java-ConstructTerm : 
    Op("", args) -> expr|[ termFactory.makeTuple(~*args') ]|
    with
      args' := <map(java-construct-term)> args
    
  java-ConstructTerm :
    Op("Nil", []) -> expr|[ (IStrategoTerm) termFactory.makeList() ]|

  java-ConstructTerm :
    Op("Cons", [t1, t2]) -> 
    expr|[ 
      (IStrategoTerm) termFactory.makeList(~expr:<java-construct-term> t1, e)
    ]|
    with
      <java-construct-term> t2
        ; if <not(Anno(is-ListOp,id))> t2 then 
            java-check-aterm-list 
          else
              if ?|[ getConstant(e1, e2) ]| + ?expr |[ x ]| then
                !|[ (IStrategoList) ~expr:<id> ]|
              else
                try(java-UncastATerm)
              end
              ; try(java-CastATermListSetAnnotations)
            end => e

  java-check-aterm-list :
    e -> expr |[ x ]|
    with 
      x := <newname> "list"
    ; rules(
        java-CheckBuild :+=
          ( bstm |[ IStrategoList x; ]|
          , bstm*|[
              x = checkListTail(e);
              if (x == null) break Fail;
            ]|)
      )

  java-CastATerm :
    e -> expr|[ (IStrategoTerm) e ]|

  java-CastATermListSetAnnotations :
    expr|[                 termFactory.annotateTerm(e1, checkListAnnos(e2, e3)) ]| ->
    expr|[ (IStrategoList) termFactory.annotateTerm(e1, checkListAnnos(e2, e3)) ]|

  java-UncastATerm :
    expr|[ (IStrategoTerm) e ]| -> e
    
/**
 * Signatures
 */
strategies

  JavaTranslate =
      rules(ConstructorDecl :+= <JavaDeclareConstructor>)
    ; rules(ConstructorInit :+= <JavaInitConstructorQ <+ JavaInitConstructor>)

  JavaDeclareConstructor :
    OpDecl(c, t) -> class-body-dec|[ public static IStrategoConstructor x; ]|
  where
    not(OpDecl("", id) + OpDecl("Cons", [id, id]) + OpDecl("Nil", []))
  with 
    n := <Arity> t
  ; x := <java-ConstructorName> (c, n)
  ; rules(IsLocalOpDecl: (c, n))

  java-ConstructorName :
    (c, n) -> <conc-strings> ("_cons", c', "_", n')
    with
      c' := <jify> c
    ; n' := <int-to-string> n
  
  java-ConstructorName-expr =
    if IsLocalOpDecl then
      with(x_main := <MainClassName>)
    ; !expr |[ x_main.~x:<java-ConstructorName> ]|
    else
      !expr |[ ~x:<java-ConstructorName> ]|
    end

  JavaInitConstructorQ :
    OpDecl(c, t) ->
    bstm |[
      x = termFactory.makeConstructor("\"" + "~c'" + "\"", 
                                      ~expr:<java-mk-int-const> ar);
    ]|
  where 
      <string-as-chars(unescape-chars; un-double-quote-chars)> c => c' 
    ; ar := <Arity> t
    ; x  := <java-ConstructorName> (c, ar)

  JavaInitConstructor :
    OpDecl(c, t) ->
    bstm |[
      x = termFactory.makeConstructor("~c", ~expr:<java-mk-int-const> ar);
    ]|
  where 
      ar := <Arity> t
    ; x  := <java-ConstructorName> (c, ar)
  
  add-default-constructors =
    with(
      add-private-constructor(|"Some", 1)
    ; add-private-constructor(|"None", 0)
    ; add-private-constructor(|"Conc", 2)
    )

  add-private-constructor(|name, arity) =
    if not(<IsLocalOpDecl> (name, arity)) then
      x := <java-ConstructorName> (name, arity)
    ; rules(
        ConstructorDecl :+= class-body-dec|[ public static IStrategoConstructor x; ]|
      )
    ; rules(
        ConstructorInit :+=
          |[ x = termFactory.makeConstructor("~name", ~expr:<java-mk-int-const> arity); ]|
      )
    end

/* ================================ Match */
strategies

  translate-Match :
    Match(t) -> result
    with
      result := <translate-Match> Match(t, ExprName(Id("term")))

  translate-Match :
    Match(Wld(), trm) -> Empty()

  translate-Match :
    Match(As(t1,t2), trm) ->
    bstm* |[ 
      stm_match1
      stm_match2
    ]|
    with stm_match1 := <translate-Match> Match(t1,trm)
       ; stm_match2 := <translate-Match> Match(t2,trm)

  translate-Match :
    Match(Var(x){"unbound"}, trm) -> stm_assign
    with
      stm_assign := <java-VarToWrite> (x, trm)

  translate-Match :
    Match(Var(x){"bound"}, trm) ->
    stm|[ 
      if(!e.match(~expr:trm)) 
        break Fail;
     ]|
    with
      e := <java-VarToReadRef> Var(x)

  translate-Match :
    Match(Var(x){"(un)bound"}, e) ->
    stm|[ 
      if (e_x == null)
        stm_assign
      else if (!e_x.match(e))
        break Fail;
    ]|
    with 
      e_x := <java-VarToReadRef> Var(x)
    ; stm_assign := <java-VarToWrite> (x, e)

  translate-Match :
    Match(Var(x){}, trm) -> <translate-Match> Match(Var(x){"(un)bound"}, trm)

  translate-Match :
    Match(Explode(t1, t2), e) ->
    bstm* |[ 
      IStrategoTerm x_cons = context.invokePrimitive("SSL_get_constructor", term,
                                                      new IStrategy[] {},
                                                      new IStrategoTerm[] { e });
      ~stm:(<translate-Match> Match(t1, ExprName(Id(x_cons))))
      IStrategoTerm x_args = context.invokePrimitive("SSL_get_arguments", term,
                                                     new IStrategy[] {},
                                                     new IStrategoTerm[] { e });
      ~stm:(<translate-Match> Match(t2, ExprName(Id(x_args))))
     ]|
  with
      !e => ExprName(Id(_))
    ; x_cons := <newname> "cons"
    ; x_args := <newname> "args"

  translate-Match =
       ( translate-MatchNoAnno
      <+ translate-MatchAnno )

  translate-MatchNoAnno :
    Match(Anno(pt1, Wld()), e) -> result
    with result := <translate-Match> Match(pt1, e)

  translate-MatchAnno :
    Match(Anno(pt1, pt2), e) -> 
    bstm* |[
      stm0
      IStrategoList x = e.getAnnotations();
      stm1
    ]|
  where 
      <not(Wld)> pt2
  with
      x    := <newname> "annos"
    ; stm0 := <translate-Match> Match(pt1, e)
    ; stm1 := <translate-Match> Match(pt2, ExprName(Id(x)))

  /**
   * @todo  String constants should probably be cached, just like constructor names
   */
  translate-Match :
    Match(Str(str), e) -> 
    stm|[
      if (e.getTermType() != IStrategoTerm.STRING
         || !e_str.equals(((IStrategoString) e).stringValue()))
        break Fail;
    ]|
  with
      !e => ExprName(Id(_))
    ; e_str := Lit(String([Chars(<escape> str)]))

  translate-Match :
    Match(Int(i), e) -> 
    stm|[
      if (e.getTermType() != IStrategoTerm.INT
         || e_int != ((IStrategoInt) e).intValue())
        break Fail;
    ]|
  with
      !e => ExprName(Id(_))
    ; e_int := <java-mk-int-const> i

  translate-Match :
    Match(Real(r), e) -> 
    stm|[
      if (e.getTermType() != IStrategoTerm.REAL 
          || e_real != ((IStrategoReal) e).realValue())
        break Fail;
    ]|
  with
      !e => ExprName(Id(_))
    ; e_real := Lit(Float(<try(real-to-string)> r))

  /**
   * Translate a match of an Op, but not a Cons/2 , Nil/0, or tuple.
   */
  translate-Match :
    Match(op@Op(c, ts), e) ->
    bstm* |[
      // (this pattern is matched optimized in java-postprocess)
      if (e.getTermType() != IStrategoTerm.APPL || e_nomatch) break Fail;
      ~bstm*:match-args
    ]|
  where
    <not(is-ListOp + is-TupleOp)> op
  with
    x_cons     := <java-ConstructorName> (c, <length> ts)
  ; match-args := <translate-Match-args> (e, ts)
  ; if not(<get-config> "-sc" => "off") then
      e_nomatch := |[ x_cons != ((IStrategoAppl) e).getConstructor() ]|
    else
      e_nomatch := |[ !x_cons.equals(((IStrategoAppl) e).getConstructor()) ]|
    end

  /**
   * Translate a match of an Op, but not a Cons/2 or Nil/0.
   */
  translate-Match :
    Match(op@Op(c, ts), e) ->
    bstm* |[
      if (e.getTermType() != IStrategoTerm.TUPLE || e.getSubtermCount() != i)
        break Fail;
      ~bstm*:match-args
    ]|
  where
    <is-TupleOp> op
  with
    i:= <write-to-string> <length> ts
  ; match-args := <translate-Match-args> (e, ts)
  
  translate-Match-args :
    (e, terms) -> bstm_matcharg*
    with
      (bstm_matcharg*, _) :=
        <thread-map(\ (t,i) -> (
               <java-MatchArg1 <+ java-MatchArg2> 
                  (t, expr|[ e.getSubterm(~expr:<java-mk-int-const> i) ]|)
             , <add>(i, 1)
             )
           \ )> (terms,0)

  java-MatchArg1 : 
    (Var(x){t*}, e) -> result
  with 
      result := <translate-Match> Match(Var(x){t*}, e)

  java-MatchArg2 : 
    (t, e) -> 
    bstm* |[
      stm1
      stm2
    ]|
    with
      x    := <newname> "arg"
    ; stm2 := <translate-Match> Match(t, ExprName(Id(x)))
    ; if !stm2 => Empty() then
       stm1 := Empty()
      else 
       stm1 := |[ IStrategoTerm x = e; ]|
     end

  translate-Match :
    Match(Op("Nil", []), e) ->
    bstm* |[
      if (e.getTermType() != IStrategoTerm.LIST || !((IStrategoList) e).isEmpty())
        break Fail;
    ]|

  translate-Match :
    Match(Op("Cons", [hd, tl]), e) ->
    bstm* |[
      if (e.getTermType() != IStrategoTerm.LIST || ((IStrategoList) e).isEmpty())
          break Fail;
      ~bstm*:match-args
    ]|
  with 
    <map(java-MatchArg1 <+ java-MatchArg2)> 
       [ (hd, expr|[ ((IStrategoList) e).head() ]|)
       , (tl, expr|[ ((IStrategoList) e).tail() ]|) ] => match-args
