/** 
 * Module flattening strategy for Stratego based on the generic graph
 * flattening algorithm from the library.  The program handles
 * command-line options for indicating paths to directories with
 * library modules and finds modules based on such a path.  It writes
 * dependencies for inclusion in a Makefile to the .r.dep file.
 * Pack-stratego calls an external process (parse-mod) for parsing
 * individual modules. 
 */

module pack-stratego
imports lib xtc-lib pack-graph sugar config pack-stratego-options
strategies

  pack-stratego = 
    xtc-iowrap(
      pack-stratego-options
    , process-options
    ; pack-stratego(|<include-path>) => (files, spec)
    ; <maybe-create-depfile> files
    ; <write-to> spec
    )

  pack-stratego(|mkpt) =
      \ FILE(s) -> IncludePathName(s) \
    ; !(<id>, mkpt, [])
    ; graph-nodes-undef(
        pack-stratego-parse-stratego
      , get-stratego-imports
        ; map(!IncludeFromPath(<id>))
      , \ (n,x,xs) -> [x|xs] \
      )
    ; if ?(_, []) then
       Fst
       ; unzip
       ; (id, flatten-stratego) 
      else
        if not(<get-config>"--slack") then
          Snd 
          ; map(report-module-not-found)
          ; <xtc-exit> 1
        else 
          Fst
        ; unzip
        ; (id, flatten-stratego) 
        end
      end

  report-module-not-found =
    let get-module-name =
          ?IncludeFromPath(<id>) + ?IncludePathName(<id>)

     in get-module-name => module-name
      ; <printnl> (stderr(), ["pack-stratego: error: module ", module-name, " not found"])
      ; <bagof-ImportedFrom> module-name
      ; if [] then
          id
        else if ?[mod] then
            <printnl> (stderr(), ["    imported from file ", mod])
        else
            where(<printnl> (stderr(), ["    imported from:"]))
          ; map({mod1 :
              ?mod1
            ; <printnl> (stderr(),   ["      file ", mod1 ])
            })
          end
        end
      ; <printnl> (stderr(),   [""])
    end


  pack-stratego-parse-stratego =
    let qualify-pathname =
            where(explode-string => cs)
          ; if <is-qualified> cs then
              id
            else
              <implode-string> ['.', '/' | cs]
            end
  
         is-qualified =
           ?['/' | _] + ?['.' | _ ]

     in ?(<id>, _)
      ; ?IncludePathName(<qualify-pathname>)
      ; if file-exists then
          include-pathname
        else
          <fatal-error> ["pack-stratego: error: file ", <id>, " does not exist\n"]
        end
    end

  pack-stratego-parse-stratego =
      ?(<id>, includes)
    ; ?IncludeFromPath(<id>)
    ; guarantee-extension(!"str")
    ; remove-extension => mod
    ; <fetch-elem(
          include-from-dir-cached(|mod)
       <+ include-from-dir(|mod)
       <+ include-from-xtc(|mod)
       )> includes

  include-pathname :
    file -> (file, tree)
      where if-verbose1(debug(!"  including "))
          ; <parse-stratego> file => tree

  include-from-dir-cached(|mod) :
    IncludeDir(dir) -> (file,<ReadFromFile> file)
      where <concat-strings; file-exists> [dir,"/", mod, ".rtree"] => file
          ; if-verbose1(debug(!"  including "))

  include-from-dir(|mod) :
    IncludeDir(dir) -> <include-pathname> file
      where 
        ( <concat-strings; file-exists> [dir,"/", mod, ".str"] => file
        + <concat-strings; file-exists> [dir,"/", mod, ".cr"] => file
        + <concat-strings; file-exists> [dir,"/", mod, ".r"] => file
        ) => file

  include-from-xtc(|mod) :
    IncludeXTC() -> (file, tree)
      where <conc-strings; xtc-find-loc> (mod, ".str") => file
          ; if-verbose1(say(<concat-strings> ["  including ", mod, " from XTC repository"]))
          ; <parse-stratego> file => tree

strategies

  include-dirs =
    (<get-config> "-I" <+ ![])
  ; filter(?IncludeDir(<id>))

  pass-include-dirs =
    include-dirs ; mapconcat(!["-I",<id>])

  parse-stratego =
     ?file
   ; <xtc-transform(!"parse-stratego",
	 	     <concat>[<get-config < !["--asfix"] + ![]> "--asfix",
                               <pass-verbose>, <pass-keep>, <pass-include-dirs>])>FILE(file)
   ; read-from
  <+ <fatal-error> ["parse error in ", <id>]

  get-stratego-imports =
    ?(file, Specification(<id>))
    ; filter(?Imports(<id>) ; mapconcat(expand-import))
    ; concat
    ; where(
        map({import:
            ?import
          ; rules(ImportedFrom :+ import -> file)
        })
      )

  flatten-stratego = 
    map(?Specification(<id>); filter(not(Imports(id))))
    ; concat 
    ; !Specification(<id>)

  expand-import = 
    ![<is-string>]
  + \ Import(i) -> [i] \ 
  + ?ImportWildcard(<id>) => path
  ; include-dirs
  ; mapconcat(
      {dir:
        ?dir 
      ; <concat-strings>[dir,"/",path] 
      ; readdir 
      ; filter(
          ( has-extension(!".rtree") 
          + has-extension(!".str") 
          + has-extension(!".r")
          ) 
        ; basename
        ; <concat-strings>[path,"/",<id>]
        )
      <+ ![]
      }
    )

signature
  constructors
    Import         : String -> Import
    ImportWildcard : String -> Import
