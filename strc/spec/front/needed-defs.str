/**
 * Extract those definitions that are needed for the main strategy and
 * join the bodies of operators with multiple definitions.
 */

module needed-defs
imports Stratego DefaultStrat desugar stratlib list-set list-misc lib pack-graph
	dynamic-rules

strategies

  /**
   * Sorting definitions
   *
   * Associate with the pair \verb|(f, n)| of strategy name and arity
   * the list of its definitions. The dynamic rule \verb|Definitions|
   * implements this 1association.
   */

  sort-defs = 
    map(RegisterSDefT + RegisterExtSDef + RegisterExtSDefInl)

  RegisterSDefT =
    ?def@SDefT(f, xs, ys, s);
    where(
        <length> xs => n
      ; <length> ys => m
      ; ![def | <Definitions <+ ![]> (f, (n, m))] => defs
      ; <union>([(n,m)], <Arities <+ ![]> f) => aris
      ; rules(
          Definitions : (f, (n, m)) -> defs
          Arities : f -> aris
        )
    )

  RegisterExtSDef =
    ?def@ExtSDef(f, xs, ys);
    where(
        <length> xs => n
      ; <length> ys => m
      ; ![def | <Definitions <+ ![]> (f, (n, m))] => defs
      ; <union>([(n,m)], <Arities <+ ![]> f) => aris
      ; rules(
          Definitions : (f, (n, m)) -> defs
          Arities : f -> aris
        )
    )

  RegisterExtSDefInl =
    ?def@ExtSDefInl(f, xs, ys, s);
    where(
        <length> xs => n
      ; <length> ys => m
      ; ![def | <Definitions <+ ![]> (f, (n, m))] => defs
      ; <union>([(n,m)], <Arities <+ ![]> f) => aris
      ; rules(
          Definitions : (f, (n, m)) -> defs
          Arities : f -> aris
        )
    )

strategies

  /**
   * Joining Definitions
   *
   * Join multiple definitions for the same strategy operator into one
   * definition by unifying the list of formal strategy parameters.
   */

  joindefs = JoinDefs1 <+ JoinDefsExt <+ JoinDefs2

rules

  JoinDefs1 : 
    [sdef] -> sdef

  JoinDefsExt =
    fetch(?ExtSDef(f,_,_) + ?ExtSDefInl(f,_,_,_))
    ; <debug(!"overloading external definition: ")> f
    ; giving-up

  JoinDefs2 : 
    defs @ [SDefT(f, xs1, xs2, s) | _] -> SDefT(f, ys1, ys2, <choices> ss)
    where <map(VarDec(new,id))> xs1 => ys1
	; <map(VarDec(new,id))> xs2 => ys2
	; <map(\ VarDec(y, t) -> CallT(SVar(y), [], []) \ )> ys1 => ys1'
	; <map(\ VarDec(y, t) -> Var(y) \ )> ys2 => ys2'
	; <map(\ SDefT(_, zs1, zs2, s) -> 
                 <tsubs> (<map(\ VarDec(z2,_) -> z2 \ )> zs2, ys2', 
		   <ssubs> (<map(\ VarDec(z1,_) -> z1 \ )> zs1, ys1', s)
                 ) \ )> defs => ss

  choices = 
    foldr(!Fail, !Choice(<Fst>,<Snd>))

strategies

  /**
   * Obtaining all definitions
   */

  all-defs = 
    !(<definition-names>, <sort-defs>, []);
    extract-needed-defs

  /**
   * Obtaining needed definitions
   */
  needed-defs = 
    !([("main", (0,0))], <sort-defs>, []);
    extract-needed-defs

  extract-needed-defs =
    graph-nodes-undef-roots-chgr(get-definition
                          ,svars-arity; map(try(DefinitionExists))
                          ,\ (_,x,d) -> [x|d] \ );
    // FilterNonMissingDefs; 
    (NoMissingDefs <+ MissingDefs; <exit> 1)

  definition-names =
    foldr(![], union, DefinitionName)

  DefinitionName :
    SDefT(f,xs,ys,_) -> [(f, (<length>xs, <length>ys))]

  DefinitionName :
    ExtSDef(f,xs,ys) -> [(f, (<length>xs, <length>ys))]

  DefinitionName :
    ExtSDefInl(f,xs,ys,_) -> [(f, (<length>xs, <length>ys))]

rules

  /**
   *
   * A strategy operator f with arity n is needed. All definitions for
   * the operator are fetched and joined. Note that this entails
   * that (1) operators can be overloaded and (2) there can be more
   * than one definition of an operator.
   */

  get-definition = 
    CongruenceDef <+ OverloadedDef; (joindefs, id)

  DefinitionExists :
    (f, (0,0)) -> (f, (n,m))
    where <Arities> f => [(n,m)]; <Definitions> (f, (n,m))

  DefinitionExists =
    ?(f, (0,0))
    ; <Arities> f => [_,_|_]
    ; not(fetch(?(0,0)))
    ; <error> ["passing name of overloaded definition: ", f]
    ; giving-up

  OverloadedDef :
    ((f, n), defs) -> (<Definitions> (f, n), defs)

  CongruenceDef :
    ((Mod(c, mod), n), defs) -> (fdef, defs)
    where <DefineCongruence; desugar> (c, mod, n) => fdef

/*
  FilterNonMissingDefs :
    (defs, undefs) -> (defs, undefs')
    where <filter(not(Definitions))> undefs => undefs'
*/

  NoMissingDefs : 
    (defs, []) -> defs

  MissingDefs : 
    (defs, [f|fs]) -> defs
    where <map(MissingDefMod <+ MissingDef)> [f|fs]

  MissingDef : 
    (f, n) -> <error> ["error: operator ", f, "/", n, " undefined "]

  MissingDefMod : 
    (Mod(c, m), n) -> 
    <error> ["error: operator ", c, "^", m , "/", n, " undefined "]

/*

Distributing Congruences

	For each constructor \verb|c|, there is a corresponding
	distributing congruence \verb|c^D|, defined according to
	the following scheme:

\begin{verbatim}
  c^D(s1,...,sn) : (c(x1,...,xn),env) -> c(y1,...,yn)
  where <s1> (x1,env) => y1;
        ...
        <sn> (xn, envn) => yn
\end{verbatim}
	
	This is implemented by the following rules.
*/

overlays
  OpPair(t1, t2) = Op("", [t1,t2])

rules
  DefineCongruence :
    (c, "D", (n,m)) -> 
    SDefT(Mod(c, "D"), ss, [], Scope([env | <conc>(xs1, ys1)], 
                                SRule(Rule(OpPair(Op(c, xs2), Var(env)), 
                                           Op(c, ys2), 
                                           Seqs(conds)))))
    where new => env;
          <copy(MkDistApplication); tuple-unzip(id)> (n, Var(env)) 
              => (conds, ss, xs1, xs2, ys1, ys2)

  MkDistApplication : 
    env -> (BAM(CallT(SVar(s),[],[]), OpPair(Var(x), env), Var(y)), 
            VarDec(s,DefaultStrat), x, Var(x), y, Var(y))
    where new => s; new => x; new => y

  MkDistApplication : 
    env -> (BAM(CallT(SVar(s),[],[]), OpPair(Var(x), env), Var(y)), 
            VarDec(s,DefaultStrat), x, Var(x), y, Var(y))
    where new => s; new => x; new => y

/*

Threading Congruences

	For each constructor \verb|c|, there is a corresponding
	threading congruence \verb|c^T|, defined according to
	the following scheme:

\begin{verbatim}
  c^T(s1,...,sn) : (c(x1,...,xn),e-first) -> (c(y1,...,yn), e-last)
  where <s1> (x1,e-first) => (y1,e2);
              ...;
        <sn> (xn, en) => (yn, e-last)
\end{verbatim}

	The following rules implement this scheme:

*/

  DefineCongruence :
    (c, "T", (0,m)) -> 
    SDefT(Mod(c, "T"), [], [], Scope([e], 
                                SRule(Rule(OpPair(Op(c, []), Var(e)), 
                                           OpPair(Op(c, []), Var(e)), 
                                           Id))))
    where new => e

  DefineCongruence :
    (c, "T", (n,m)) -> 
    SDefT(Mod(c, "T"), ss, [], Scope([e-first | <concat> [es, xs1, ys1]], 
                                SRule(Rule(OpPair(Op(c, xs2), Var(e-first)), 
                                           OpPair(Op(c, ys2), Var(e-last)), 
                                           Seqs(as)))))
    where <copy(new)> (<add>(n,1), ()) => [e-first | es];
          <last> es => e-last;
          <zipr(MkThreadApplication); tuple-unzip(id)> ([e-first | es], es)
	     => (as, ss, xs1, xs2, ys1, ys2)

  MkThreadApplication : 
    (e1,e2) -> (BAM(CallT(SVar(s),[],[]), OpPair(Var(x), Var(e1)), 
                                      OpPair(Var(y), Var(e2))), 
                VarDec(s,DefaultStrat), x, Var(x), y, Var(y))
    where new => s; new => x; new => y

/*

Copyright (C) 1998-2003 Eelco Visser <visser@acm.org>

*/