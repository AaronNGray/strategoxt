module lift-dynamic-rules
imports Stratego lib desugar dr-old-to-new

strategies

  LiftDynamicRules =
    upgrade-old-dr-constructs
  ; Specification([id,id, Strategies(define-rule-scope; lift-dynamic-rules)])

/* Desugar dynamic rule scopes {| ... : ... |} */

  define-rule-scope =
    topdown(try(DefDynRuleScope + DefDynRuleScopeLabel))

  DefDynRuleScope :
    |[ {| : s |} ]| -> s

  DefDynRuleScope :
    |[ {| x, sc* : s |} ]| -> |[ dr-scope({| sc* : s |} | ~str:x) ]|

  DefDynRuleScope :
    |[ {| x.t, sc* : s |} ]| -> |[ dr-scope( {| x :+ t |}; {| sc* : s |}
                                           | ~str:x ) ]|

  DefDynRuleScopeLabel :
    |[ {| x :+ t |} ]| -> |[ dr-label-scope(|~str:x, t) ]|

/* Lift dynamic rules from strategy definitions.  One dynamic rule set
is lifted out at a time, after which the process repeats; a definition
may contain multiple dynamic rules, and a dynamic rule itself may
contain dynamic rules. */

  lift-dynamic-rules = 
    listtd(repeat(lift-dynamic-rule))

  lift-dynamic-rule :
    [def | defs] -> <conc> ([def' | rdefs], defs)
    where {| ContextVar : 
	     <def-tvars> def; DeclareContextVars
           ; <split-dynamic-rule(split-dynamic-rules => (ss, rdefs); !Seqs(ss))> 
	        def => def'
	   |}

  def-tvars =
    <union> (<tvars>,
	     <?SDefT(_,_,<map(?DefaultVarDec(<id>) + ?VarDec(<id>,_))>,_)
	      <+ ?RDefT(_,_,<map(?DefaultVarDec(<id>) + ?VarDec(<id>,_))>,_)
	      <+ ![]
             >
	    )

/* Traverse to find dynamic rule definition.  Record all variables
that are declared in context using the dynamic rule ContextVar */

  split-dynamic-rule(s) = 
    rec x(oncetd(s <+ split-under-scope(x)))

  split-under-scope(f) :
    |[ { x* : s } ]| -> |[ { x* : s' } ]|
    where {| ContextVar : <DeclareContextVars> x*; <f> s => s' |}

  DeclareContextVars =
    map({(?ListVar(x) <+ ?x); rules(ContextVar : x -> x)})

/* Split each rule in a dynamic rule set */

  split-dynamic-rules :
    |[ rules(drd*) ]| -> 
    <map(SplitDynamicRule); unzip; (id, concat)> drd*

  SplitDynamicRule:
    drd@DynRuleDef|[ f(as1|as2) : r ]| ->
      <SplitDynamicRule(!|[ dr-set-rule(|~str:f, ~<Fst>, ~<Snd>) ]|)> drd

  SplitDynamicRule:
    DynRuleDef|[ f(as1|as2).t : r ]| ->
      <SplitDynamicRule(!|[ dr-set-rule(|~str:f, t, ~<Fst>, ~<Snd>) ]|)> DynRuleDef|[ f(as1|as2) : r ]|

  SplitDynamicRule:
    DynRuleDef|[ f(as1|as2) :+ r ]| ->
      <SplitDynamicRule(!|[ dr-add-rule(|~str:f, ~<Fst>, ~<Snd>) ]|)> DynRuleDef|[ f(as1|as2) : r ]|

  SplitDynamicRule:
    DynRuleDef|[ f(as1|as2).t :+ r ]| ->
      <SplitDynamicRule(!|[ dr-add-rule(|~str:f, t, ~<Fst>, ~<Snd>) ]|)> DynRuleDef|[ f(as1|as2) : r ]|

  SplitDynamicRule:
    DynRuleDef|[ f(as1|as2) :- t ]| ->
      <SplitDynamicRule(!|[ dr-undefine-rule(|~str:f, ~<Fst>) ]|)> DynRuleDef|[ f(as1|as2) : t -> () where id ]|

  SplitDynamicRule:
    DynRuleDef|[ f(as1|as2).t :- t1 ]| ->
      <SplitDynamicRule(!|[ dr-undefine-rule(|~str:f, t, ~<Fst>) ]|)> DynRuleDef|[ f(as1|as2) : t1 -> () where id ]|



  // TODO: Introduce memoization!
  //  * for bagof-RuleA and RuleA
  //  * for lifted aux-RuleA (mapping from RDefs to stamp/label)

  SplitDynamicRule(saveclsr):
    drd@DynRuleDef|[ f(as1|as2) : t1 -> t2 where s ]| ->
    (|[ where(~<saveclsr> (t1', |[ (~str:stamp, t*) ]| )) ]|,
      <conc> (callees, callers)
     )
    where
    // Prepare LHS for use as a key
      <dummify> t1 => t1'

    // Determine the context variables to be stored in the closure
    ; <tvars; map(!Var(<id>))> t1' => keys
    ; <tvars; filter(test(ListVar(ContextVar) <+ ContextVar); !Var(<id>))> (t2, s) => vals1
    ; <diff> (vals1, keys) => t*

    ; if id // here comes the memoization
        then // aux-Rule has not been lifted yet

          <conc-strings>("aux-", f) => f'  // has to be the same such that + of aux-f works
        ; new => stamp
        ; new => x
        ; !Var(x) => t0

        // aux-rule will receive pattern vars and entire LHS as additional term args.
        ; <tvars> t1 => t1vars // *all* pattern variables in LHS t1
        ; <concat> [as2,
                    <map(try(?ListVar(<id>)); !DefaultVarDec(<id>))> t1vars,
                    [DefaultVarDec(x)]
                   ] => as2' // add them to term args as2 (for passing to aux- rule)

        // Building the lifted aux-rule
        ; ![ |[ f'(as1|as2') : (~str:stamp, t*) -> t2 
                  where <s> t0 ]|
           ] => callees

        // Check whether Rule and bagof-Rule still need to be generated
        ; !(f, (<length> as1, <length> as2)) => rsig
        ; if <DRCallersGenerated> (rsig, t1')
            then 
              ![] => callers
            ; <debug(!"callers already generated: ")> (rsig, t1')
            else
              <conc-strings>("bagof-", f) => g

            // Transform passed arguments of f into calling arguments for f'
            ; <map((?DefaultVarDec(<id>) + ?VarDec(<id>,_)); !Call(SVar(<id>),[]))> as1 => s1*
            ; <map((?DefaultVarDec(<id>) + ?VarDec(<id>,_)); !Var(<id>))> as2 => t1*

            // the calls to aux-rule should pass pattern vars and entire LHS as additional term args.
            ; <concat> [t1*, <map(!Var(<id>))> t1vars, [t0]] => t1'*

            // If dummified key is the same as original, just use x for lookup
            ; (!t1'; try(?t1; !Var(x))) => t1''

            ; ![ |[ f(as1|as2) : x@t1 -> <fetch-elem(f'(s1*|t1'*))> closures
                      where dr-lookup-rule(|~str:f, t1'') => closures ]|,
                 |[ g(as1|as2) : x@t1 -> <filter(f'(s1*|t1'*))> closures
                      where (dr-lookup-rule(|~str:f, t1'') <+ ![]) => closures ]|
               ] => callers
            ; rules(DRCallersGenerated : (rsig, t1') -> ())
            ; <debug(!"freshly generating the DR callers: ")> (rsig, t1')
          end

        else
          ![] => callees
        ; ![] => callers
      end





/*
  ;where(<debug(!"just testing: "); strename; debug(!"just the result: ")> |[ rules( RuleA(st1,st2|tr1) :+ Foo(qr, pr) -> Bar(pr,0) where <leq> (qr,pr) ) ]|)
      ;where(try(<debug(!"about to rename: ");
                 strename//dr-rename-vars
                 ; debug(!"just renamed: ")> drd))
*/

strategies
  dr-rename-vars =
  {| DRRenameVar:
    where(<reset-counter> "DRVarNumber")
  ; rec x(debug(!"input rec x: "); RenameVarTerm(debug(!"DRRenameVar input: "); DRRenameVar; debug(!"DRRenameVar output: ") <+ debug(!"NewNumberedVar input: "); NewNumberedVar); debug(!"RenameVarTerm output: ") <+ all(x))
  |}

  RenameVarTerm(s) =
    Var(ListVar(s; <strcat> (<id>, "*")))
 <+ Var(s)
  + SVar(s)
  + VarDec(s, id)
  + DefaultVarDec(s)

rules
  NewNumberedVar :
    x -> y
    where <next-counter> "DRVarNumber" => n
        ; <strcat> ("drvar_", <int-to-string> n) => y
        ; rules(DRRenameVar: x -> y)

\end{code}

% Copyright (C) 1998-2002 Eelco Visser <visser@acm.org>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
% 02111-1307, USA.

