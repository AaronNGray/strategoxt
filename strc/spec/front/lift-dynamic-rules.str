module lift-dynamic-rules
imports Stratego lib desugar dr-old-to-new

strategies

  LiftDynamicRules =
    upgrade-old-dr-constructs
  ; Specification([id,id, Strategies(define-rule-scope; lift-dynamic-rules)])

/* Desugar dynamic rule scopes {| ... : ... |} */

  define-rule-scope =
    topdown(try(DefDynRuleScope + DefDynRuleScopeLabel))

  DefDynRuleScope :
    |[ {| : s |} ]| -> s

  DefDynRuleScope :
    |[ {| x, sc* : s |} ]| -> |[ dr-scope({| sc* : s |} | ~str:x) ]|

  DefDynRuleScope :
    |[ {| x.t, sc* : s |} ]| -> |[ dr-scope( {| x :+ t |}; {| sc* : s |}
                                           | ~str:x ) ]|

  DefDynRuleScopeLabel :
    |[ {| x :+ t |} ]| -> |[ dr-label-scope(|~str:x, t) ]|

/* Lift dynamic rules from strategy definitions.  One dynamic rule set
is lifted out at a time, after which the process repeats; a definition
may contain multiple dynamic rules, and a dynamic rule itself may
contain dynamic rules. */

  lift-dynamic-rules = 
    listtd(repeat(lift-dynamic-rule))

  lift-dynamic-rule :
    [def | defs] -> <conc> ([def' | rdefs], defs)
    where {| ContextVar : 
	     <def-tvars> def; DeclareContextVars
           ; <split-dynamic-rule(split-dynamic-rules => (ss, rdefs); !Seqs(ss))> 
	        def => def'
	   |}

  def-tvars =
    <union> (<tvars>,
	     <?SDefT(_,_,<map(?DefaultVarDec(<id>) + ?VarDec(<id>,_))>,_)
	      <+ ?RDefT(_,_,<map(?DefaultVarDec(<id>) + ?VarDec(<id>,_))>,_)
	      <+ ![]
             >
	    )

/* Traverse to find dynamic rule definition.  Record all variables
that are declared in context using the dynamic rule ContextVar */

  split-dynamic-rule(s) = 
    rec x(oncetd(s <+ split-under-scope(x)))

  split-under-scope(f) :
    |[ { x* : s } ]| -> |[ { x* : s' } ]|
    where {| ContextVar : <DeclareContextVars> x*; <f> s => s' |}

  DeclareContextVars =
    map({(?ListVar(x) <+ ?x); rules(ContextVar : x -> x)})

/* Split each rule in a dynamic rule set */

  split-dynamic-rules :
    |[ rules(drd*) ]| -> 
    <map(SplitDynamicRule); unzip; (id, concat)> drd*

  SplitDynamicRule:
    drd@DynRuleDef|[ f(as1|as2) : r ]| ->
      <SplitDynamicRule(!|[ dr-set-rule(|~str:f, ~<Fst>, ~<Snd>) ]|)> drd

  SplitDynamicRule:
    DynRuleDef|[ f(as1|as2).t : r ]| ->
      <SplitDynamicRule(!|[ dr-set-rule(|~str:f, t, ~<Fst>, ~<Snd>) ]|)> DynRuleDef|[ f(as1|as2) : r ]|

  SplitDynamicRule:
    DynRuleDef|[ f(as1|as2) :+ r ]| ->
      <SplitDynamicRule(!|[ dr-add-rule(|~str:f, ~<Fst>, ~<Snd>) ]|)> DynRuleDef|[ f(as1|as2) : r ]|

  SplitDynamicRule:
    DynRuleDef|[ f(as1|as2).t :+ r ]| ->
      <SplitDynamicRule(!|[ dr-add-rule(|~str:f, t, ~<Fst>, ~<Snd>) ]|)> DynRuleDef|[ f(as1|as2) : r ]|

  SplitDynamicRule:
    DynRuleDef|[ f(as1|as2) :- t ]| ->
      <SplitDynamicRule(!|[ dr-undefine-rule(|~str:f, ~<Fst>) ]|)> DynRuleDef|[ f(as1|as2) : t -> () where id ]|

  SplitDynamicRule:
    DynRuleDef|[ f(as1|as2).t :- t1 ]| ->
      <SplitDynamicRule(!|[ dr-undefine-rule(|~str:f, t, ~<Fst>) ]|)> DynRuleDef|[ f(as1|as2) : t1 -> () where id ]|



  // TODO: Introduce memoization!

  SplitDynamicRule(saveclsr):
    DynRuleDef|[ f(as1|as2) : t1 -> t2 where s ]| ->
    (|[ where(~<saveclsr> (t1', |[ Closure(~str:stamp, [t*]) ]| )) ]|,
     [ |[ f'(as1|as2) : (Closure(~str:stamp, [t*]), t1) -> t2 
                where Snd; s ]|,
       |[ f(as1|as2) : x@t1 -> <fetch-elem({cl: ?cl; <f'(s1*|t1*)> (cl, t0) })> closures
                where dr-lookup-rule(|~str:f, t1'') => closures ]|,
       |[ g(as1|as2) : x@t1 -> <filter({cl: ?cl; <f'(s1*|t1*)> (cl, t0) })> closures
                where (dr-lookup-rule(|~str:f, t1'') <+ ![]) => closures ]|
     ])
    where
        <conc-strings>("bagof-", f) => g
      ; <conc-strings>("aux-", f) => f'  // has to be the same such that + of aux-f works
      ; new => stamp

      // Transform passed arguments of f into calling arguments for f'
      ; <map((?DefaultVarDec(<id>) + ?VarDec(<id>,_)); !Call(SVar(<id>),[]))> as1 => s1*
      ; <map((?DefaultVarDec(<id>) + ?VarDec(<id>,_)); !Var(<id>))> as2 => t1*

// We now pass the entire LHS to the aux- rule as well, no need for additional term-arguments.
//      ; <tvars> t1 => t1vars                                     // *all* pattern variables in LHS t1
//      ; <conc> (as2, <map(try(?ListVar(<id>)); !DefaultVarDec(<id>))> t1vars) => as2' // add them to term args as2 (for passing to aux- rule)
//      ; <conc> (t1*, <map(!Var(<id>))> t1vars) => t1'*           // same for actual values at call-site

      // Prepare LHS for use as a key
      ; new => x
      ; !Var(x) => t0
      ; <dummify> t1 => t1'
      ; try(?t1; !Var(x)) => t1'' // If dummified version is the same, just use x for lookup

      // Determine the context variables to be stored in the Closure
      ; <tvars; map(!Var(<id>))> t1' => keys
      ; <tvars; filter(test(ListVar(ContextVar) <+ ContextVar); !Var(<id>))> (t2, s) => vals1
      ; <diff> (vals1, keys) => t*

\end{code}

% Copyright (C) 1998-2002 Eelco Visser <visser@acm.org>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
% 02111-1307, USA.

