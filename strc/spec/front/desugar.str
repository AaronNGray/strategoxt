\literate[Desugaring]

	Desugaring : translating high-level constructs to low-level
	ones

\begin{code}
module desugar
imports Stratego-Amb DefaultStrat sugar stratlib lib stratego-desugar
strategies

  desugar-io =
    io-wrap(Specification([id,Strategies(desugar-spec)]))
\end{code} 

	\paragraph{Varyadic operators}

\begin{code}
rules

  map1(s) = 
    [s | id]; [id | try(map1(s))] <+ [id | map1(s)]

/*
  HL :
    SDefT(f, as1, as2, s) -> SDefT(f, as1', as2', s)
    where <map1(MkFunType)> as1 => as1' 
        ; <map(try(MkConstType))> as2 => as2'

  HL :
    SDefT(f, as1, as2, s) -> SDefT(f, as1', as2', s)
    where <map1(MkConstType)> as2 => as2'
        ; <map(try(MkFunType))> as1 => as1' 

  HL :
    RDefT(f, as1, as2, s) -> RDefT(f, as1', as2', s)
    where <map1(MkFunType)> as1 => as1' 
        ; <map1(try(MkConstType))> as2 => as2'
*/

  desugar-DefaultVarDec =
    topdown(try(DesugarDefaultVarDec))

  DesugarDefaultVarDec :
    SDefT(f, s1, t1, s) -> SDefT(f, s2, t2, s)
    where <map(try(MkFunType))> s1 => s2
        ; <map(try(MkConstType))> t1 => t2

  DesugarDefaultVarDec :
    ExtSDef(f, s1, t1) -> ExtSDef(f, s2, t2)
    where <map(try(MkFunType))> s1 => s2
        ; <map(try(MkConstType))> t1 => t2

  MkFunType :
    DefaultVarDec(x)-> VarDec(x, DefaultStrat)

  MkConstType :
    DefaultVarDec(x)-> VarDec(x, DefaultTerm)

  HL : Seqs([])           -> Id
  HL : Seqs([s | ss])     -> Seq(s, Seqs(ss))
  HL : Choices([])        -> Fail
  HL : Choices([s | ss])  -> Choice(s, Choices(ss))
  HL : LChoices([])       -> Fail
  HL : LChoices([s | ss]) -> LChoice(s, LChoices(ss))

  HL : Lets(sdefs,s) -> Let(sdefs, s)

  //HL : Lets([], s) -> s
  //HL : Lets([sdef | sdefs], s) -> Let(sdef, Lets(sdefs, s))

  MkSeq : (s1, s2) -> Seq(s1, s2)

strategies

  seqs = foldr(!Id, MkSeq)
\end{code}

	\paragraph{Match, Build, Apply combinations}

\begin{code}
rules

  HL : BA(s, t)            -> Seq(Build(t), s)
  HL : MA(t, s)            -> Seq(Match(t), s)
  HL : AM(s, t)            -> Seq(s, Match(t))
  HL : BAM(s, t1, t2)      -> Seqs([Build(t1), s, Match(t2)])
  HL : InfixApp(t1, s, t2) -> App(s, Op("",[t1,t2]))

\end{code} 

\paragraph{Primitives}

	Lift non-variable arguments to primitives.

\begin{code}
rules

  LiftPrimArgs : 
    Prim(f, ts) -> Scope(xs, Seq(Seqs(s), PrimT(f, [], ts')))
    where <fetch(not(Var(id)))> ts
        ; <unzip(LiftPrimArg); (concat, unzip(id))> ts => (xs, (s, ts'))

  LiftPrimArgs : 
    PrimT(f, ss, ts) -> Scope(xs, Seq(Seqs(s), PrimT(f, ss, ts')))
    where <fetch(not(Var(id)))> ts
        ; <unzip(LiftPrimArg); (concat, unzip(id))> ts => (xs, (s, ts'))

  LiftCallArgs : 
    CallT(f, ss, ts) -> Scope(xs, Seq(Seqs(s), CallT(f, ss, ts')))
    where <fetch(not(Var(id)))> ts
        ; <unzip(LiftPrimArg); (concat, unzip(id))> ts => (xs, (s, ts'))

  LiftPrimArg :
    Var(x) -> ([], (Id, Var(x)))

  LiftPrimArg :
    t -> ([x], (Where(Seq(Build(t), Match(Var(x)))), Var(x)))
    where <not(Var(id))> t; new => x
\end{code}

\paragraph{Strategy Applications}

	Factoring out strategy applications; The right-hand side of a
	rule can contain applications of a strategy to a term; This is
	factored out by translating it to a condition that applies the
	strategy and matches the result against a new variable, which
	is then used in the rhs;  In fact this can be generalized to
	applications in arbitrary builds;

\begin{code}
rules

  // this rule is not valid, consider a RootApp in t'

  Bapp0 : Build(t[App(Build(t'), t'')]) -> Build(t[t'](pat-td))

  // follows from Bapp2

  Bapp1 : Build(App(s, t')) -> Seq(Build(t'), s)

  Bapp : Build(t[App(s, t')]) -> 
          Scope([x], Seq(Where(BAM(s, t', Var(x))), Build(t[Var(x)](pat-td))))
          where new => x

  Bapp0 : Build(t[RootApp(Build(t'))]) -> Build(t[t'](pat-td))

  Bapp1 : Build(RootApp(s)) -> s

  Bapp : Build(t[RootApp(s)]) -> 
          Scope([x], Seq(Where(Seq(s, Match(Var(x)))), Build(t[Var(x)](pat-td))))
          where new => x

  Bapp : Build(t[Anno(t1, t2)]) -> 
          Scope([x], Seq(Where(Seq(PrimT("SSLsetAnnotations", [], [t1, t2]), Match(Var(x)))), 
                         Build(t[Var(x)](pat-td))))
          where new => x
\end{code}

Only look for Apps and RootApps under constructor applications and term
explosions. Avoid lifting an App from within another App or RootApp.

\begin{code}
  pat-td(s) = 
    s <+ (Op(id, fetch(pat-td(s)))
         + Explode(id, pat-td(s))
         + Explode(pat-td(s), id)
         + PrimT(id, id, fetch(pat-td(s)))
         + CallT(id, id, fetch(pat-td(s)))
	 + As(id, pat-td(s)))	 
\end{code}

\begin{code}
strategies

  Mapp = Mapp1 <+ Mapp2

rules

  Mapp1 : Match(App(s, t')) -> BA(s, t')

  Mapp2 : Match(t[App(s, t')]) -> 
          Scope([x], Seq(Match(t[Var(x)](pat-td)), 
                     Seq(Build(Var(x)), 
                     Seq(Build(t'), s))))
          where new => x

  Mapp1 : Match(RootApp(s)) -> s

  Mapp2 : Match(t[RootApp(s)]) -> 
          Scope([x], Seq(Match(t[Var(x)](pat-td)), Seq(Build(Var(x)), s)))
          where new => x

  Mapp2 : Match(t[Anno(t1, t2)]) -> 
          Scope([x], Seq(Match(t[As(Var(x), t1)](pat-td)), 
                         Where(Seq(PrimT("SSLgetAnnotations", [], [Var(x)]), Match(t2)))))
          where new => x
\end{code}


\paragraph{List Matching}

\begin{code}
rules

  ListVarScope :
    Scope(xs, s) -> Scope(ys, s)
    where <map(try(?ListVar(<id>)))> xs => ys

  ListVarScope :
    SDefT(f, as1, as2, s) -> SDefT(f, as1, as2', s)
    where <map(try(?ListVar(<id>)))> as2 => as2'

  SingleListVar :
    Var(ListVar(x)) -> Var(x)

  ListMatch : 
    Match(t[Op("Cons", [Var(ListVar(x)), Op("Nil", [])])]) -> 
    Match(t[Var(x)])

  ListBuild : 
    Build(t[Op("Cons", [Var(ListVar(x)), Op("Nil", [])])]) -> 
    Build(t[Var(x)])
\end{code}

\paragraph{Term Explosion and Construction}

\begin{code}
rules

  Expl : 
    Match(t[Explode(t1, t2)]) -> 
    Scope([x], 
          Seq(Match(t[Var(x)]),
              Where(BAM(Scope([y],Seq(Match(Var(y)),PrimT("SSL_explode_term",[],[Var(y)]))), 
                        Var(x), 
			Op("", [t1, t2])
                        ))))
    where new => x; new => y

  Expl  : 
    Build(t[Explode(t1, t2)]) -> 
    Scope([x], Seq(PrimT("SSL_mkterm",[],[t1,t2]), 
                   Seq(Match(Var(x)),
                       Build(t[Var(x)]))))
    where new => x

  Expl : 
    ExplodeCong(s1, s2) ->
    Scope([x,x',y,y'],
	  Seq(Match(Explode(Var(x),Var(y))),
	      Seq(Where(Seq(BAM(s1, Var(x), Var(x')), BAM(s2, Var(y), Var(y')))),
                  PrimT("SSL_mkterm",[],[Var(x'),Var(y')]))))
    where new => x; new => x'; new => y; new => y'
\end{code} 


\paragraph{Rules to Strategies}

	A rule corresponds to a strategy that first matches the
	left-hand side, then checks the conditions and finally builds
	the right-hand side; The left-hand side and right-hand side
	should be in basic term format, as defined by the predicate
	|bterm|;

\begin{code}
strategies

  pureterm = not(topdown(Con(id, id, id) + App(id, id)))

  buildterm = not(topdown(Con(id, id, id) + Wld))

rules

  RtoS : SRule(Rule(l, r, s)) -> Seqs([Match(l), Where(s), Build(r)])
         where <pureterm> l ; <buildterm> r

  RtoS : SRule(StratRule(l, r, s)) -> Seqs([l, Where(s), r])
\end{code} 

\paragraph{Contexts}

	Factoring out contexts; Contexts used in a rule are translated
	to a local traversal that replaces the pattern occuring in the
	context in the lhs by the pattern occurring in the context in
	the rhs;

\begin{code}
rules

  Rcon : 
    SRule(Rule(l[Con(Var(c), l', f)], r[Con(Var(c), r', CallT(f', [], []))], s)) ->
    Scope([c'],
      SRule(Rule(l[Var(c)], r[Var(c')], 
	         Seq(s, BAM(CallT(f', [SRule(Rule(l', r', Id))], []), 
                            Var(c), Var(c'))))))
         where new => c'

  Rcon' : 
    SRule(Rule(l[Con(Var(c), l', f)], r[Con(Var(c), r', CallT(f', [], []))], s)) ->
    SRule(Rule(l[Var(c)], 
               r[App(CallT(f', [SRule(Rule(l', r', Id))], []), Var(c))],
	       s))

  Rcon'' : SRule(Rule(l[Con(Var(c), l', CallT(f, [], []))], r, s)) ->
         SRule(Rule(l[Var(c)], r, 
	       Seq(s, BA(CallT(f, [Match(l')], []), Var(c)))))
	(* Con(Var(c), _, _) should not occur in r *)
\end{code}

	Note: The local traversal should be closed for variables not
	occuring in the outer pattern; But this is more relevant for
	multi-contexts which are not supported yet;

	Other problems:

	- local variables for inner rule; the inner SRule should be
	enclosed in a \verb|Scope(xs, _)| where 
\begin{verbatim}
   <diff> (<tvars> (l', r'), <tvars> (l[Var(c)], r[Var(c')])) => xs
\end{verbatim}
	
	- placement of derived strategy in where clause; option first
	do a matching traversal at start of where, and at end of where
	do a replacing traversal.

	- multiple uses of context in rhs

\paragraph{Desugaring single rules}

\begin{code}
strategies

  desugarRule = 
    rec x(try(Rcon; x + Scope(id, x) + RtoS))
\end{code} 

\paragraph{Desugaring Strategies}

\begin{code}
strategies

  DesugarListMatching =
    topdown(try(ListVarScope + desugarRule); 
            repeat((HL + ListMatch + ListBuild) <+ SingleListVar))

   // MkFunType + MkConstType + 

  desugar = 
    topdown(try(desugarRule); 
            repeat(LiftPrimArgs + LiftCallArgs + HL + Bapp + Mapp + Expl + Desugar))

  desugar' = 
    topdown(try(desugarRule); repeat(HL))

  /**
   * Desugar all definnitions in specification
   *
   * Note that inline bodies of external definitions are _not_
   * desugared. These are assumed to be in StrategoCore. This should
   * be checked.
   */

  desugar-spec = 
    map(
      SDef(id, id, desugar) 
      + SDefT(id, id, id, desugar)
      + ExtSDef(id, id, id) 
      + ExtSDefInl(id, id, id, id)
      <+ debug(!"not a definition: "); fail
    )
\end{code}
 
% Copyright (C) 1998-2003 Eelco Visser <visser@acm.org>

