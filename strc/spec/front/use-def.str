module use-def
imports Stratego list-set stratlib lib bound-unbound-vars 
strategies

  use-def-io =
    io-wrap(stratego-warnings-options, where(spec-use-def))

  stratego-warnings-options = 
    ArgOption("--warning" + "-W",
        where(<extend-config> ("--warning", [<id>])); !(),
        !"-W | --warning     Set warning level (-W all to switch all warnings on)"
    )

  /**
   * Test whether all variables used in builds are matched before.
   *
   * This analysis makes use of bound-unbound-vars to the real work.
   */

  spec-use-def = 
    Specification([Signature(id),
                   Overlays(defs-use-def),
		   Strategies(defs-use-def)])

  defs-use-def =
    [] <+ where(filter(def-use-def); [])

  def-use-def = 
  where(
    {| Context, MarkVar :
      topdown(try(Var(?ListVar(<id>))))
      ; !Scope(<tvars>, <id>)
      ; mark-scope
      ; ?Scope(_, <id>)
      ; (sdef-ud <+ rdef-ud <+ overlay-ud)
    |}
  )

  sdef-ud =
    ?|[ f(as) = s ]|
    ; where(
        rules(
	  Context : msg -> ["** Error in definition ", f,  ":\n   " | msg]
	  Warning : msg -> ["* Warning in definition ", f, ":\n  " | msg] 
	)
       ; <unbound-vars> s
      )

  sdef-ud =
    ?|[ f(a1* | a2*) = s ]|
    ; where(
        rules(
	  Context : msg -> ["** Error in definition ", f, ":\n   " | msg]
	  Warning : msg -> ["* Warning in definition ", f, ":\n  " | msg] )
        ; <unbound-vars> s
      )

  rdef-ud =
    ?|[ f(as) : t1 -> t2 where s ]|
    ; where(
        rules(
	  Context : msg -> ["** Error in rule ", f, ":\n   " | msg]
	  Warning : msg -> ["* Warning in rule ", f, ":\n  " | msg] 
	)
	; <bind-vars> t1
        + <unbound-vars> s
        + <use-vars> t2
      )

  rdef-ud =
    ?|[ f(a1* | a2*) : t1 -> t2 where s ]|
    ; where(
        rules( 
	  Context : msg -> ["** Error in rule ", f, ":\n   " | msg] 
	  Warning : msg -> ["* Warning in rule ", f, ":\n  " | msg] 
	)
	; <bind-vars> t1
        + <unbound-vars> s
        + <use-vars> t2
      )

  rdef-ud =
    ?RDefT(f, as1, as2, StratRule(s1, s2, s3))
    ; where(
        rules( 
	  Context : msg -> ["** Error in rule ", f, ":\n   " | msg] 
	  Warning : msg -> ["* Warning in rule ", f, ":\n  " | msg] 
	)
        ; <unbound-vars> (s1, s2, s3)
      )

  overlay-ud =
    ?Overlay|[ f(x*) = t ]|
    ; where(
        rules( 
	  Context : msg -> ["** Error in overlay ", f, ":\n   " | msg] 
	  Warning : msg -> ["* Warning in overlay ", f, ":\n  " | msg] 
	)
        ; <use-vars> t
      )

  unbound-vars = 
    Build(id)         < Build(use-vars)
    + Match(id)	      < Match(bind-vars)
    + Rule(id,id,id)  < (Rule(bind-vars,id,id)
			 + Rule(id,id,unbound-vars)
			 + Rule(id,use-vars,id))
    + PrimT(id,id,id) < (PrimT(id,unbound-vars,id)
			 + PrimT(id,id,use-vars))
    + CallT(id,id,id) < (CallT(id,unbound-vars,id)
			 + CallT(id,id,use-vars))
    + some(unbound-vars)

  bind-vars = 
      Var(id)     < fail
    + App(id,id)  < App(unbound-vars, use-vars)
    + RootApp(id) < RootApp(unbound-vars)
    + some(bind-vars)

  use-vars = 
      ?Var(x){a*} < where(!a*; ( ?["bound"]     < fail
		               + ?["(un)bound"] < <MaybeUnbound> Var(x); fail
		               + ?["unbound"]   < <Unbound> Var(x)
		               + ?[]            ; <Unbound> Var(x)))
    + App(id,id)  < App(unbound-vars, use-vars)
    + RootApp(id) < RootApp(unbound-vars)
    + some(use-vars)

  Unbound = 
    (?Var(ListVar(x)) <+ ?Var(x))
    ; <Context; error> ["variable '", x, "' used, but not bound"]

  MaybeUnbound = 
    (?Var(ListVar(x)) <+ ?Var(x))
    ; <Warning; error> ["variable '", x, "' used, but may not be bound"]
