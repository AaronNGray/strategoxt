\literate[Specification to List of Definitions]

	Translation of a specification consisting of a signature,
	rules and strategy definitions to a list of strategy
	definitions.

\begin{code}
module spec-to-sdefs
imports Stratego desugar stratlib list-sort Stratego-MetaTransition
strategies

  spec-to-sdefs-io = 
    io-wrap(
      ExpandOverlays
      ; try(AddAnnoCongDef)
      ; RulesToSdefs
      ; AddCongruenceDefinitions
      ; DesugarListMatching
      ; desugar-DefaultVarDec
    )

\end{code}

\paragraph{Congruences from Signature}

	Congruences are recognized by the parser as strategy
	calls; The following strategy generates strategy definitions
	from the signature; For instance, the operator declaration
\begin{verbatim}
     OpDecl("F", FunType([_, _], _))
\end{verbatim}
	is translated to the strategy definition
\begin{verbatim}
     SDef("F", ["x1", "x2"], Cong("F", [SVar("x1"), SVar("x2")]))
\end{verbatim}

\begin{code}
rules
  
  MkCongDef : 
    OpDecl(f, ConstType(t)) -> SDefT(f, [], [], Cong(f, []))
    where <not(CongDefined)> (f, 0)
        ; rules(CongDefined : (f, 0) -> ())

  MkCongDef : 
    OpDecl(f, FunType(ts, t)) -> 
    SDefT(f, xdecs, [], Cong(f, <map(MkCall)> xs))
    where <length> ts => n
        ; <not(CongDefined)> (f, n)
        ; rules(CongDefined : (f, n) -> ())
        ; <unzip(new; !(VarDec(<id>, DefaultStrat), <id>))> ts => (xdecs, xs)

  MkCongDefs : 
    Constructors(ods) -> <filter(MkCongDef)> ods

  RegisterCongDef =
    ?ExtSDef(f, xs, []) 
    ; where(<length> xs => n)
    ; rules(CongDefined : (f, n) -> ())

  RegisterCongDef =
    ?ExtSDefInl(f, xs, [], _)
    ; where(<length> xs => n)
    ; rules(CongDefined : (f, n) -> ())

  RegisterCongDef =
    ?SDefT(f, xs, [], _)
    ; where(<length> xs => n)
    ; rules(CongDefined : (f, n) -> ())

strategies

  congdefs = {| CongDefined : filter(MkCongDefs); concat |}
\end{code}

\paragraph{Constructors from Operators}

\begin{code}
(*
  MkConsDef : OpDecl(f, FunType(ts, t)) -> 
              RDef(f, [], )
	      where <map(new)> ts => xs

	RDef(f, [],
	   Rule(Op(x1,...,xn), Op(f, xs), id)

  MkConsDef : 
    Overlay(f, xs, t) -> RDef(f, [], Op(x1,...,xn), t)
*)
\end{code}


\paragraph{Congruences from Overlays}

	Each overlay defines a congruence operator as well as
	abstractions to be used in match and build operations. 

\begin{code}
rules

  Overlay-to-Congdef :
    Overlay(f, xs, t) -> SDef(f, xdecs, <trm-to-cong> t)
    where <map(!VarDec(<id>, DefaultStrat))> xs => xdecs

  trm-to-cong = 
    rec x(try(Op(id, map(x))); Trm-to-Cong)

  Trm-to-Cong : 
    Var(x) -> CallT(SVar(x), [], [])
  Trm-to-Cong : 
    Op(f, ts) -> CallT(SVar(f), ts, [])
  Trm-to-Cong : 
    Anno(t, ts) -> CallT(SVar("Anno_Cong__"), [t, ts], [])
  Trm-to-Cong : 
    Str(x) -> Match(Str(x))
  Trm-to-Cong : 
    Int(x) -> Match(Int(x))
  Trm-to-Cong : 
    Real(x) -> Match(Real(x))
  Trm-to-Cong : 
    BuildDefault(x) -> Id
\end{code}

\paragraph{Congruence over Annotations}

\begin{code}
overlays

  AnnoCongDef =
    RDefT("Anno_Cong__", 
         [VarDec("s1",FunType([ConstType(Sort("ATerm",[]))],ConstType(Sort("ATerm",[])))), 
          VarDec("s2",FunType([ConstType(Sort("ATerm",[]))],ConstType(Sort("ATerm",[]))))],
	 [],
         Rule(Anno(Var("x"), Var("y")), 
              Anno(Var("x'"), Var("y'")),
              Seqs([BAM(Call(SVar("s1"),[]), Var("x"), Var("x'")), 
                    BAM(Call(SVar("s2"),[]), Var("y"), Var("y'"))])))

/*
  AnnoCongDef =
    |[ Anno_Cong__(S1 : ATerm -> ATerm, S2 : ATerm -> ATerm) : 
         X1{Y1} -> X2{Y2}
         where <S1()> X1 => X2; <S2()> Y1 => Y2
    ]|
*/

\end{code}

\paragraph{Expanding Overlays}   

\begin{code}
rules
  
  ExpOverlay(ols) : 
    Op(f, ts) -> <tsubstitute> (sbs, t)
    where ols; fetch(where({xs, t: ?Overlay(f, xs, t);
                                   !(<zip(id)> (xs, ts), t)} 
                           => (sbs, t)))

// Note: when overlays in overlay definitions already have been
// expanded the repeat is not necessary. Therefore exp-overlays1 and
// exp-overlays2:

strategies

  exp-overlays1(ols) = 
    try(where(not(ols => [])); 
        topdown(repeat(ExpOverlay(ols))))

  exp-overlays2(ols) = 
    try(where(not(ols => [])); 
        topdown(try(ExpOverlay(ols))))
\end{code}


\paragraph{Rule Definitions to Strategy Definitions}

	A rule definition defines an implicitly scoped strategy
	definition;

\begin{code}
rules

  RDtoSD : 
    RDef(f, xs, r) -> SDefT(f, xs, [], Scope(<tvars> r, SRule(r)))

  RDtoSD : 
    RDefT(f, xs, ys, r) -> SDefT(f, xs, ys, Scope(<diff>(vs, ys'), SRule(r)))
    where <declared-vars> ys => ys'
        ; <tvars; map(try(?ListVar(<id>)))> r => vs

  DeclareVariables :
    SDef(f, xs, s) -> SDefT(f, xs, [], Scope(<tvars> s, s))

  DeclareVariables :
    SDefT(f, xs, ys, s) -> SDefT(f, xs, ys, Scope(<diff>(vs, ys'), s))
    where <declared-vars> ys => ys'
        ; <tvars; map(try(?ListVar(<id>)))> s => vs

  ExpandCall :
    Call(f, ss) -> CallT(f, ss, [])

  replace-call-and-rdef =
    topdown(try(ExpandCall + let-rdef-to-sdef))

  let-rdef-to-sdef = 
    let 
     rdef-to-sdef = 
       \ RDef(f, xs, r)      -> SDefT(f, xs, [], SRule(r)) \
     + \ RDefT(f, xs, ys, r) -> SDefT(f, xs, ys, SRule(r)) \
    in
      Let(list(try(rdef-to-sdef)),id)
    end

\end{code} 

\paragraph{Specification to Definition List}

	Desugaring a specification consist of deriving the list of
	joined strategy definitions from its rule definitions and
	strategy definitions; The signature components are ignored;

\begin{code}
rules

  Sp0 : Specification(bspecs) -> bspecs
  Sp1 : Signature(bsigs)      -> <congdefs> bsigs
  Sp2 : Strategies(sdefs)     -> sdefs
  Sp3 : Rules(rdefs)          -> <map(RDtoSD)> rdefs

  RulesToSdefs : 
    Specification([
      Signature(bsigs), 
      Strategies(sdefs)
    ]) ->
    Specification([
      Signature(bsigs),
      Strategies(<map(try(RDtoSD + DeclareVariables); replace-call-and-rdef)> sdefs)
    ])

  AddCongruenceDefinitions : 
    Specification([
      Signature(bsigs), 
      Strategies(sdefs)
    ]) ->
    Specification([
      Signature(bsigs),
      Strategies(<conc> (<congdefs> bsigs, sdefs))
    ])
    where <map(try(RegisterCongDef))> sdefs


  AddAnnoCongDef :
    Specification([
      Signature(bsigs), 
      Strategies(sdefs)
    ]) ->
    Specification([
      Signature(bsigs), 
      Strategies([AnnoCongDef | sdefs])
    ])
    where <not(fetch(  ?SDefT("Anno_Cong__",_,_,_) 
		     + ?RDefT("Anno_Cong__",_,_,_)
		     + ?ExtSDef("Anno_Cong__",_,_)
		     + ?ExtSDefInl("Anno_Cong__",_,_,_)))> sdefs

  ExpandOverlays : 
    Specification([
      Signature(bsigs), 
      Overlays(ols), 
      Strategies(sdefs)
    ]) ->
    Specification([
      Signature(bsigs), 
      Strategies(<conc>(<map(Overlay-to-Congdef)> ols, <exp-overlays2(!ols')> sdefs))
    ])
    where <exp-overlays1(!ols)> ols => ols'

strategies

  ExpandOverlaysIO = iowrap(ExpandOverlays)
\end{code}

% Copyright (C) 1998-2002 Eelco Visser <visser@acm.org>
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
% 02111-1307, USA.

