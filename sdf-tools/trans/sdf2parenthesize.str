/**
 * Generates a Stratego that puts Bracket constructors at the right place.
 *
 * @author  Martin Bravenboer <martin@cs.uu.nl>
 * @since   0.11
 */
module sdf2parenthesize
imports Stratego Sdf2 options xtc-lib stratego-xt-xtc-tools collect sdf-options
imports sdf-spread-cons

strategies

  io-sdf2parenthesize =
    xtc-io-wrap(parenthesize-options,
      xtc-transform(!"sdf2table", !["-n", "-m", <get-sdf-main-module> | <pass-v-verbose>])
    ; xtc-transform(!"implodePT")
    ; xtc-transform(!"sdf-desugar")
    ; xtc-io-transform(
        sdf-spread-cons
      ; topdown(try(simple-group(Prod2Pattern <+ !NoPattern())))
      ; collect(
          Assoc2Patterns
        + Chain2Patterns
        )
      ; concat
      ; map(Pattern2Rule(|<RuleName>))
      ; innermost-module
      )
    ; xtc-transform(!"pp-stratego", !["--abstract" | <pass-verbose>])
    )

/**
 * Transformation
 */
strategies
  
  innermost-module :
    rs ->
      |[ module M1
         imports liblib M2
         strategies

           f =
             io-wrap(g)

           g =
             innermost(l)

         rules
           ~* rs

         signature
           constructors
             Parenthetical : Unknown -> Unknown
      ]|
    where ModuleName => M1
        ; LanguageName => M2
        ; <conc-strings> ("io-", M1) => f
        ; <conc-strings> ("parenthesize-", M2) => g
        ; RuleName => l

  RuleName =
    <conc-strings> (<LanguageName>, "Parenthesize") => l

/**
 * Assoc
 */
strategies

  /**
   * @type  Priority -> List(Term)
   */
  Assoc2Patterns :
    assoc(simple-group(t1), left(), simple-group(t2))
      ->
    <AssocLeft2Patterns(|t1)> t2

  Assoc2Patterns :
    assoc(simple-group(t1), assoc(), simple-group(t2))
      ->
    <AssocLeft2Patterns(|t1)> t2

  Assoc2Patterns :
    assoc(simple-group(t1), right(), simple-group(t2))
      ->
    <AssocRight2Patterns(|t1)> t2

  Assoc2Patterns :
    assoc(simple-group(t1), non-assoc(), simple-group(t2))
      ->
    <PatternsOne(|t2)> t1

  Chain2Patterns :
    chain([simple-group(t1), simple-group(t2)])
      ->
    <PatternsOne(|t2)> t1

strategies

  /**
   * Term with Brackets to a rewrite rule.
   *
   * At the LHS the brackets are removed, at the RHS they
   * changed in real terms.
   *
   * @type  Term -> RuleDef
   */
  Pattern2Rule(|l) :
    p -> |[ l : t1 -> t2 ]|
      where <topdown(try(?Parenthetical(<id>)))> p => t1
          ; <topdown(try(\ Parenthetical(t) -> |[ Parenthetical(t) ]| \ ))> p => t2
    
  /**
   * Put the pattern p2 at all places where it is not allowed.
   *
   * For example, applied to Plus(_, _, _) it will result in 
   * the patterns
   *  - Plus(p, _, _)
   *  - Plus(_, p, _) 
   *  - Plus(_, _, p)
   */
  AssocLeft2Patterns(|p2) :
    |[ x(t, t1*) ]| -> ps
      where let set-pattern = {t2* :
              \ (n, p) -> |[ x(t, t2*) ]| 
                  where <set-index> (<dec> n, Parenthetical(p2), t1*) => t2* \ }
             in <map-with-index(set-pattern)> t1* => ps
            end

  AssocRight2Patterns(|p2) :
    |[ x(t3*) ]| -> ps
      where <split-init-last> t3* => (t1*, t) 
          ; let set-pattern = {t2* :
              \ (n, p) -> |[ x(t2*) ]| 
                  where <set-index> (<dec> n, Parenthetical(p2), t1*)
                      ; <conc> (<id>, [t]) => t2* \ }
             in <map-with-index(set-pattern)> t1* => ps
            end

  /**
   * Produce all patterns that have one p2 child
   */
  PatternsOne(|p2) : 
    |[ x(t1*) ]| -> ps
      where let set-pattern = {t2* :
              \ (n, p) -> |[ x(t2*) ]| 
                  where <set-index> (<dec> n, Parenthetical(p2), t1*) => t2* \ }
             in <map-with-index(set-pattern)> t1* => ps
            end

  /**
   * Creates a wildcard-children pattern for a production
   */
  Prod2Pattern :
    p@prod(syms, _, _) -> |[ x(t*) ]|
      where < filter(not(is-empty-sym))
            ; map({x: new => x; !Term |[ x ]| })
            > syms => t*
          ; <cons-of-prod> p => x

/**
 * Helper copied from sdf2rtg.
 *
 * @todo  Put in some SDF lib or whatever
 */
strategies

  /**
   * @type  Symbol -> Symbol
   */
  is-empty-sym = ?lit(_)
  is-empty-sym = ?layout()
  is-empty-sym = opt(is-empty-sym)
  is-empty-sym = cf(is-empty-sym)
  is-empty-sym = lex(is-empty-sym)
  is-empty-sym = label(id, is-empty-sym)

/**
 * Options
 */
strategies

  parenthesize-options =
    sdf-main-module-option
  + stratego-module-option
  + language-option

  stratego-module-option =
    ArgOption("--omod"
    , ?s; rules(ModuleName : _ -> s)
    , <concat-strings>   ["--omod mod       ", "Name of the resulting Stratego module (required)"]
    )

  language-option =
    ArgOption("--lang"
    , ?s; rules(LanguageName : _ -> s)
    , <concat-strings>   ["--lang name      ", "Name of the language (required)"]
    )


signature
  constructors
    StrategoModuleFlag : Flag
    Parenthetical      : Term -> Term
    NoPattern          : Term