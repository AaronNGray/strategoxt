/**
 * Generates a Stratego that puts Bracket constructors at the right place.
 *
 * @author  Martin Bravenboer <martin@cs.uu.nl>
 * @since   0.11
 */
module sdf2parenthesize
imports Stratego Sdf2 options xtc-lib stratego-xt-xtc-tools collect sdf-options
imports sdf-spread-cons

strategies

  io-sdf2parenthesize =
    xtc-io-wrap(parenthesize-options,
      xtc-transform(!"sdf2table", !["-n", "-m", <get-sdf-main-module> | <pass-v-verbose>])
    ; xtc-transform(!"implodePT")
    ; xtc-transform(!"sdf-desugar")
    ; xtc-io-transform(
        sdf-spread-cons
      ; collect(Assoc2BracketRules)
      ; concat
      ; innermost-module
      )
    ; xtc-transform(!"pp-stratego", !["--abstract" | <pass-verbose>])
    )

/**
 * Transformation
 */
strategies
  
  innermost-module :
    rs ->
      |[ module M1
         imports options M2
         strategies

           f =
             io-wrap(g)

           g =
             innermost(l)

         rules
           ~* rs
      ]|
    where ModuleName => M1
        ; LanguageName => M2
        ; <conc-strings> ("io-", M1) => f
        ; <conc-strings> (M2, "-parenthesize") => g
        ; <conc-strings> (M2, "-Bracket") => l

/**
 * Assoc
 */
strategies

  Assoc2BracketRules :
    assoc(simple-group(prod1), left(), simple-group(prod2)) ->
      <zip( \ (t1, t2) -> |[ AssocBracket : t1 -> t2 ]| \)> (lhs, rhs)
      where <Prod2Pattern; Wld2Vars> prod1 => t1
          ; <Prod2Pattern; Wld2Vars> prod2 => t2
          ; <AssocLeft2Patterns(|t1)> t2 => lhs
          ; <map(InBracket(|t1))> lhs => rhs

strategies

  /**
   * Puts t children in a bracket constructor.
   */
  InBracket(|t) :
    |[ x(t1*) ]| -> |[ x(t2*) ]|
      where <map(try(?t; !|[ Bracket(t) ]|))> t1* => t2*
    
  /**
   * Put the pattern p2 at all places where it is not allowed.
   *
   * For example, applied to Plus(_, _, _) it will result in 
   * the patterns
   *  - Plus(p, _, _)
   *  - Plus(_, p, _) 
   *  - Plus(_, _, p)
   */
  AssocLeft2Patterns(|p2) :
    |[ x(t, t1*) ]| -> ps
      where let set-pattern = {t2* :
              \ (n, p) -> |[ x(t, t2*) ]| 
                  where <set-index> (<dec> n, p2, t1*) => t2* \ }
             in <map-with-index(set-pattern)> t1* => ps
            end


  /**
   * Creates a wildcard-children pattern for a production
   */
  Prod2Pattern :
    p@prod(syms, _, _) -> |[ x(t*) ]|
      where < filter(not(is-empty-sym))
            ; map(!|[ _ ]|)
            > syms => t*
          ; <cons-of-prod> p => x

  Wld2Vars =
    topdown(try({x: \ |[ _ ]| -> Term |[ x ]| where new => x \} ))

/**
 * Helper copied from sdf2rtg.
 *
 * @todo  Put in some SDF lib or whatever
 */
strategies

  /**
   * @type  Symbol -> Symbol
   */
  is-empty-sym = ?lit(_)
  is-empty-sym = ?layout()
  is-empty-sym = opt(is-empty-sym)
  is-empty-sym = cf(is-empty-sym)
  is-empty-sym = lex(is-empty-sym)
  is-empty-sym = label(id, is-empty-sym)

/**
 * Options
 */
strategies

  parenthesize-options =
    sdf-main-module-option
  + stratego-module-option
  + language-option

  stratego-module-option =
    ArgOption("--omod"
    , ?s; rules(ModuleName : _ -> s)
    , <concat-strings>   ["--omod mod       ", "Name of the resulting Stratego module (required)"]
    )

  language-option =
    ArgOption("--lang"
    , ?s; rules(LanguageName : _ -> s)
    , <concat-strings>   ["--lang name      ", "Name of the language (required)"]
    )


signature
  constructors
    StrategoModuleFlag : Flag
