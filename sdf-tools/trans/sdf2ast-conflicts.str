/**
 * Generates a description of conflicts in an AST from an SDF syntax definition.
 *
 * @author  Martin Bravenboer <martin@cs.uu.nl>
 * @since   0.11
 */
module sdf2ast-conflicts
imports
  libstratego-lib
  Stratego
  Sdf2
  libstratego-xtc
  strategoxt-xtc-tools
  sdf-spread-cons
  ast-conflicts

  sdf/grammar/utils
  sdf/tool/options
  sdf/tool/xtc
  sdf/symbol/implode

strategies

  main-sdf2ast-conflicts =
    xtc-io-wrap(sdf-main-module-option,
      xtc-sdf2-normalize(|<get-sdf-main-module>)
    ; xtc-io-transform(
        error-if-empty-grammar(<xtc-exit> 1)
      ; core-sdf2conflicts
      )
    )

  core-sdf2conflicts =
    sdf-spread-cons
    ; topdown(try(Priority2Symbol))
    ; topdown(try(simple-group(Prod2Symbol <+ !NoSymbol())))
    ; <conc> (<chain-patterns>, <assoc-patterns>)
    ; filter(not(oncetd(?NoSymbol())))

signature
 constructors
   NoSymbol : Symbol

/**
 * Produce conflict patterns from SDF definitions.
 */  
strategies

  assoc-patterns = 
     collect(?assoc(_, _, _))
   ; filter(Assoc2Conflicts)
   ; concat

  chain-patterns =
    chains := <collect(?chain([_, _]))>
    ; nodes := <new-iset>
    ; edges := <new-hashtable>
    ; <map(ignore-chain <+ define-chain(|nodes, edges) <+ cannot-handle-chain)> chains
    ; hashgraph-transitive-closure(|nodes, edges)
    ; <hashtable-getlist> edges
    ; map(Chain2Conflicts)
    ; concat

  define-chain(|nodes, edges) =
    ?chain([simple-group(sym1@Symbol(s1, n)), simple-group(sym2@Symbol(s2, _))])
    ; <iset-add(|sym1)> nodes
    ; <iset-add(|sym2)> nodes
    ; <hashtable-pushlist(|(sym1, sym2), <range> (0, n))> edges

  define-chain(|nodes, edges) =
    ?chain([with-arguments(simple-group(sym1@Symbol(s1, _)), default([arg])), simple-group(sym2@Symbol(s2, _))])
    ; <iset-add(|sym1)> nodes
    ; <iset-add(|sym2)> nodes
    ; <hashtable-push(|(sym1, sym2), <string-to-int> arg)> edges

  ignore-chain =
    oncetd(?NoSymbol())

  cannot-handle-chain =
    log(|Error(), "Cannot handle chain priority: ", <id>)

rules

  /**
   * @type Priority -> List(Conflict)
   */
  Assoc2Conflicts :
    assoc(simple-group(sym1), left(), simple-group(sym2)) -> <AssocLeft2Conflicts(|sym1)> sym2

  Assoc2Conflicts :
    assoc(simple-group(sym1), assoc(), simple-group(sym2)) -> <AssocLeft2Conflicts(|sym1)> sym2

  Assoc2Conflicts :
    assoc(simple-group(sym1), right(), simple-group(sym2)) -> <AssocRight2Conflicts(|sym1)> sym2

  Assoc2Conflicts :
    assoc(simple-group(sym1), non-assoc(), simple-group(sym2)) -> <AllConflicts(|sym2)> sym1

  /**
   * @type Symbol -> List(Conflict)
   */
  AssocLeft2Conflicts(|sym2) :
    sym1@Symbol(c, n) -> <map(!SubtermConflict(sym1, <id>, sym2))> is
      where <range> (1, n) => is

  /**
   * @type Symbol -> List(Conflict)
   */
  AssocRight2Conflicts(|sym2) :
    sym1@Symbol(c, n) -> <map(!SubtermConflict(sym1, <id>, sym2))> is
      where <range> (0, <dec> n) => is

  AllConflicts(|sym2) :
    sym1@Symbol(x, n) -> <map(!SubtermConflict(sym1, <id>, sym2))> is
    where
      is := <range> (0, n)

  Chain2Conflicts :
    ((sym1, sym2), args) -> <map(!SubtermConflict(sym1, <id>, sym2))> args 

strategies

  /**
   * Rewrites a prod to a Symbol.
   */
  Prod2Symbol :
    p@prod(syms, _, _) -> Symbol(x, n)
    where
      n := <filter(not(is-empty-sym)); length> syms
      ; x := <cons-of-prod> p

  Priority2Symbol :
    chain([with-arguments(simple-group(p@prod(syms, _, _)), default([arg])), group2])
      ->
    chain([with-arguments(simple-group(p), default([arg'])), group2])
    where
      syms' :=
        <add-indices; retain-all((id, not(is-empty-sym)); ?(<id>, _))> syms
      ; arg' := 
          <get-index; dec; int-to-string> (<string-to-int; inc> arg, syms')

signature
  constructors
    with-arguments : Group * List(Argument) -> Group

strategies

  hashgraph-transitive-closure(|nodes, edges) =
    iset-transitive-closure(|<?IndexedSet(<id>)> nodes, <?Hashtable(<id>)> edges)

  external iset-transitive-closure(|nodes, edges)
