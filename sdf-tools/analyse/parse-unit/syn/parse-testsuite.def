definition
module RealCon
imports IntCon

exports
  sorts OptExp RealCon
  context-free syntax
    "e" IntCon -> OptExp {cons("present")}
               -> OptExp {cons("absent")}

    IntCon "." NatCon OptExp  -> RealCon {cons("real-con")}

module IntCon
imports Whitespace

exports
  sorts NatCon IntCon
  lexical syntax   
    [0-9]+ -> NatCon  {cons("digits")}
  context-free syntax
    NatCon         -> IntCon {cons("natural")}
    pos:"+" NatCon -> IntCon {cons("positive")}
    neg:"-" NatCon -> IntCon {cons("negative")}

module Whitespace

exports
  lexical syntax
    [\ \t\n\13]	-> LAYOUT
  context-free restrictions
    LAYOUT? -/- [\ \t\n\13]

module Literals
imports Whitespace

hiddens
  sorts AlphaNumericalEscChar DecimalEscChar EscChar L-Char

exports
  sorts QLiteral
  lexical syntax
    "\\" ~[012]                    -> AlphaNumericalEscChar {cons("default")}

    "\\" [01] [0-9] [0-9]          -> DecimalEscChar {cons("dec0_199")}
    "\\" "2" [0-4] [0-9]           -> DecimalEscChar {cons("dec200_249")}
    "\\" "2" "5" [0-5]             -> DecimalEscChar {cons("dec250_255")}

    alpha:AlphaNumericalEscChar  -> EscChar {cons("alpha-numeric")}
    decimal:DecimalEscChar       -> EscChar {cons("decimal")}

    ~[\000-\031\"\\] \/ [\t\n\13] -> L-Char {cons("normal")}
    EscChar                      -> L-Char {cons("escaped")}

    "\"" chars:L-Char* "\""        -> QLiteral {cons("quoted")}

  sorts UQLiteral
  lexical syntax
    [a-z]                          -> UQLiteral {cons("one-char")}
    [a-z][A-Za-z0-9\-]*[A-Za-z0-9] -> UQLiteral {cons("more-chars")}

  sorts Literal
  context-free syntax
    QLiteral  -> Literal {cons("qlit")}
    UQLiteral -> Literal {cons("uqlit")}

  lexical restrictions
    UQLiteral -/- [A-Za-z0-9]

module ATerms
imports Literals IntCon RealCon

exports
  sorts ATermList ACon AFun ATerm Ann
  context-free syntax
    "[" elems:{ ATerm ","}* "]"             -> ATermList {cons("not-empty")}
    IntCon                                  -> ACon      {cons("int")}
    RealCon                                 -> ACon      {cons("real")}
    Literal                                 -> AFun
    ACon                                    -> ATerm     {cons("constant")}
    list:ATermList                          -> ATerm     {cons("list")}
    fun:AFun                                -> ATerm     {cons("fun")}
    fun:AFun "(" args:{ ATerm ","}+ ")"     -> ATerm     {cons("appl")}
    "<" type:ATerm ">"                      -> ATerm {cons("placeholder")}
    "{" annos:{ ATerm ","}+ "}"             -> Ann       {cons("annotation")}
    ACon Ann                                -> ATerm     {cons("annotated-constant")}
    list:ATermList Ann                      -> ATerm     {cons("annotated-list")}
    fun:AFun Ann                            -> ATerm     {cons("annotated-fun")}
    fun:AFun "(" args:{ ATerm ","}+ ")" Ann -> ATerm {cons("annotated-appl")}
    "<" type:ATerm ">" Ann                  -> ATerm {cons("annotated-placeholder")}

module parse-testsuite
imports ATerms
exports
  sorts TestSuite

  context-free syntax
    "testsuite" Name TopSort Test+ -> TestSuite {cons("parse-testsuite")}
    "topsort" Sort -> TopSort {cons("topsort")}

    "test" Description Input Result -> Test {cons("parse-test")}
    "test"             Input Result -> Test {cons("parse-test")}

    "->" ATerm -> Result {cons("pattern")}
    "_" -> ATerm {cons("wildcard")}

    "fails"    -> Result {cons("failure")}
    "succeeds" -> Result {cons("success")}

    "file" PathName -> Input {cons("file")}

  %% allow unquoted upper case AFuns
  lexical syntax
    [A-Z][A-Za-z0-9\-]*[A-Za-z0-9] -> UQLiteral {cons("more-chars")}

  %% allow function applications without arguments
  context-free syntax
    fun:AFun "(" ")" -> ATerm {cons("fun")}

  syntax
    "\""       <InputChars1-LEX> "\""       -> <Input-CF> {cons("string")}
    "\"\""     <InputChars2-LEX> "\"\""     -> <Input-CF> {cons("string")}
    "\"\"\""   <InputChars3-LEX> "\"\"\""   -> <Input-CF> {cons("string")}
    "\"\"\"\"" <InputChars4-LEX> "\"\"\"\"" -> <Input-CF> {cons("string")}

    "["    <InputChars21-LEX> "]"    -> <Input-CF> {cons("string")}
    "[["   <InputChars22-LEX> "]]"   -> <Input-CF> {cons("string")}
    "[[["  <InputChars23-LEX> "]]]"  -> <Input-CF> {cons("string")}
    "[[[[" <InputChars24-LEX> "]]]]" -> <Input-CF> {cons("string")}

  context-free syntax
    EOLString -> Name {cons("name")}
    EOLString -> Description {cons("description")}

  lexical syntax
    [A-Z]                          -> Sort
    [A-Z][A-Za-z0-9\-]*[A-Za-z0-9] -> Sort

    ~[\n]+ -> EOLString

    ~[\"]* -> InputChars1
    (~[\"]  | DQuote1)*                      -> InputChars2
    (~[\"]  | DQuote1 | DQuote2)*            -> InputChars3
    (~[\"]  | DQuote1 | DQuote2 | DQuote3 )* -> InputChars4

    "\""     -> DQuote1
    "\"\""   -> DQuote2
    "\"\"\"" -> DQuote3

    ~[\[]* -> InputChars21
    (~[\[]  | Bracket1)*                        -> InputChars22
    (~[\[]  | Bracket1 | Bracket2)*             -> InputChars23
    (~[\[]  | Bracket1 | Bracket2 | Bracket3 )* -> InputChars24

    "["   -> Bracket1
    "[["  -> Bracket2
    "[[[" -> Barcket3

    [A-Za-z0-9\-\_\.\\\/]+ -> PathName

  lexical restrictions
    Sort      -/- [A-Za-z0-9\-]
    EOLString -/- ~[\n]
    DQuote1   -/- [\"]
    DQuote2   -/- [\"]
    DQuote3   -/- [\"]

    "\""      -/- [\"]
    "\"\""    -/- [\"]
    "\"\"\""  -/- [\"]

    Bracket1   -/- [\[]
    Bracket2   -/- [\[]
    Bracket3   -/- [\[]

    "["    -/- [\[]
    "[["   -/- [\[]
    "[[["  -/- [\[]