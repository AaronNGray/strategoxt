%%%
 %% Syntax definition of parse-unit testsuites
 %%
 %% @author Martin Bravenboer <martin@cs.uu.nl>
 %%%
module parse-testsuite
imports languages/aterm/syntax/ATerms
hiddens
  context-free start-symbols TestSuite

exports
  sorts TestSuite TopSort Test Input Result 
  context-free syntax
    "testsuite" Name TopSort Test+ -> TestSuite {cons("parse-testsuite")}
    "topsort" Sort -> TopSort {cons("topsort")}

  %% The description syntax is very ambiguous if comments are allowed around it. So, we forbid comments.
  syntax
    "test" [\ ]+ <Description-CF> <LAYOUT?-CF> <Input-CF> <LAYOUT?-CF> <Result-CF> -> <Test-CF> {cons("parse-test")}
    "test" [\ \t\n\r]+ <Input-CF> <LAYOUT?-CF> <Result-CF> -> <Test-CF>  {cons("parse-test")}

  context-free syntax
    "->" "file" PathName -> Result {cons("file")}
    "->" ATerm           -> Result {cons("pattern")}
    "_"                  -> ATerm  {cons("wildcard")}

    "fails"    -> Result {cons("failure")}
    "succeeds" -> Result {cons("success")}

    "file" PathName -> Input {cons("file")}

  %% allow unquoted upper case AFuns
  lexical syntax
    ""                             -> UQLiteral {cons("no-chars")}
    [A-Z][A-Za-z0-9\-]*[A-Za-z0-9] -> UQLiteral {cons("more-chars")}

  %% empty is ok, but cannot be a complete ATerm.
  context-free syntax  
    "" -> ATerm {reject}

  %% allow function applications without arguments
  context-free syntax
    fun:AFun "(" ")" -> ATerm {cons("fun")}

  sorts 
  syntax
    "\""       <InputChars1-LEX> "\""       -> <Input-CF> {cons("string")}
    "\"\""     <InputChars2-LEX> "\"\""     -> <Input-CF> {cons("string")}
    "\"\"\""   <InputChars3-LEX> "\"\"\""   -> <Input-CF> {cons("string")}
    "\"\"\"\"" <InputChars4-LEX> "\"\"\"\"" -> <Input-CF> {cons("string")}

    "["    <InputChars21-LEX> "]"    -> <Input-CF> {cons("string")}
    "[["   <InputChars22-LEX> "]]"   -> <Input-CF> {cons("string")}
    "[[["  <InputChars23-LEX> "]]]"  -> <Input-CF> {cons("string")}
    "[[[[" <InputChars24-LEX> "]]]]" -> <Input-CF> {cons("string")}

  sorts Name Description
  context-free syntax
    EOLString -> Name {cons("name")}
    EOLString -> Description {cons("description")}

  sorts Sort EOLString
  lexical syntax
    [A-Z]                          -> Sort
    [A-Z][A-Za-z0-9\-]*[A-Za-z0-9] -> Sort

    ~[\n]+ -> EOLString

  sorts
    InputChars1
    InputChars2
    InputChars3
    InputChars4

    DQuote1
    DQuote2
    DQuote3

    InputChars21
    InputChars22
    InputChars23
    InputChars24

    Bracket1
    Bracket2
    Bracket3

  lexical syntax
    ~[\"]* -> InputChars1
    (~[\"]  | DQuote1)*                      -> InputChars2
    (~[\"]  | DQuote1 | DQuote2)*            -> InputChars3
    (~[\"]  | DQuote1 | DQuote2 | DQuote3 )* -> InputChars4

    "\""     -> DQuote1
    "\"\""   -> DQuote2
    "\"\"\"" -> DQuote3

    ~[\[]* -> InputChars21
    (~[\[]  | Bracket1)*                        -> InputChars22
    (~[\[]  | Bracket1 | Bracket2)*             -> InputChars23
    (~[\[]  | Bracket1 | Bracket2 | Bracket3 )* -> InputChars24

    "["   -> Bracket1
    "[["  -> Bracket2
    "[[[" -> Bracket3

  sorts PathName
  lexical syntax
    [A-Za-z0-9\-\_\.\\\/]+ -> PathName

  lexical restrictions
    Sort      -/- [A-Za-z0-9\-]
    EOLString -/- ~[\n]
    DQuote1   -/- [\"]
    DQuote2   -/- [\"]
    DQuote3   -/- [\"]

    "\""      -/- [\"]
    "\"\""    -/- [\"]
    "\"\"\""  -/- [\"]

    Bracket1   -/- [\[]
    Bracket2   -/- [\[]
    Bracket3   -/- [\[]

    "["    -/- [\[]
    "[["   -/- [\[]
    "[[["  -/- [\[]

  sorts ShortCom LongCom CommChar Asterisk Eof
  lexical syntax
    "//" ~[\n]* ([\n] | Eof) -> ShortCom
    "/*" CommChar* "*/"      -> LongCom

    ~[\*]      -> CommChar

    "*"        -> Asterisk
    Asterisk   -> CommChar

  lexical restrictions
    Asterisk -/- [\/]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
