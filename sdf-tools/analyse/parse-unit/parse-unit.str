module parse-unit
imports
  liblib
  strategoxt-xtc-tools
  parse-testsuite
  parse-unit-test-results
  parse-unit-options
  parse-unit-present
  explode-aterm

strategies

  main-parse-unit =
    init-parse-unit-options
    ; xtc-io-wrap(
        parse-unit-options
      , parse-unit-usage
      , parse-unit-about
      , ![]
      , parse-unit
    )

strategies

  parse-unit = 
    read-parse-testsuite
    ; if get-single-test then
        do-single-test(|<get-single-test> ())
      else
        do-full-testsuite
      end
    ; <xtc-exit> 0
    <+ <xtc-exit> 1

  do-full-testsuite =
    echo-start
    ; ?parse-testsuite(name(name), topsort(sort), <id>)
    ; map-with-index(execute-test(|sort, <try-get-parse-table> ()))
    ; !TestResults(<id>)
    ; where(<echo-results> (name, <id>))
    ; parse-unit-exit-on-failure
    ; write-to

  /**
   * Run a single test
   */
  do-single-test(|i) =
    ?parse-testsuite(name(name), topsort(sort), <id>)
    ; ( <index> (i, <id>)
      ; ?parse-test(description(s), file(f), output)
        <+ say(!"error: parse-unit: no such test."); fail)
    ; where(<debug(!"test : ")> s)

    ; !FILE(f)
    ; sglr-asfix2(|sort, <try-get-parse-table> ())
    ; if not(is-single-test-output-asfix2) then
        xtc-implode-asfix
      end

  try-get-parse-table =
    get-sglr-parse-table <+ fatal-err(|"No parse table specified")

  read-parse-testsuite =
    xtc-sglri(|"parse-testsuite.tbl", "TestSuite")
    ; read-from
    ; parse-testsuite(id, id, map(drop-whitespace))
    ; parse-testsuite(id, id, map(try(add-description)))
    ; parse-testsuite(id, id, map(ensure-test-input-in-file))
    ; parse-testsuite(id, id, map(ensure-test-output-not-in-file))

signature
  constructors
    parse-test : Description * Input * Result -> ParseTest
    parse-test : Input * Result -> ParseTest

rules

  drop-whitespace :
    parse-test(_, descr, input, result) -> parse-test(descr, input, result)

  drop-whitespace :
    parse-test(_, input, result) -> parse-test(input, result)

  add-description :
    parse-test(string(s), output) -> parse-test(description(s), string(s), output)

  add-description :
    parse-test(file(f), output) -> parse-test(description(f), file(f), output)

/**
 * Ensures that the test input is in a file and makes it a complete path.
 */
rules

  ensure-test-input-in-file :
    parse-test(d, string(s), o) -> parse-test(d, file(f), o)
    where
      <print-to> [s] => FILE(f)

  ensure-test-input-in-file  =
    parse-test(id, file(abs-test-file), id)


  /**
   * Ensures that the test output is not in a file.
   */
  ensure-test-output-not-in-file =
    if ?parse-test(_, _, file(_)) then
      read-test-output-to-pattern
    end

  read-test-output-to-pattern :
    parse-test(desc, input, file(f)) -> parse-test(desc, input, pattern(p)) 
      where <read-from;explode-aterm> FILE(f) => p
            <+ if-verbose7(!f ; debug(!"Reading aterm result failed: "))
    
rules

  parse-unit-exit-on-failure =
    ?TestResults(<id>)
    ; map(?Success())
    <+ <exit> 1

  execute-test(|sort, table) = 
      ?(i, <id>); ?t
    ; ?parse-test(description(n), file(f), expected)
    ; <sglri(|sort, table)> FILE(f)
    ; ?result
    ; <create-test-result> (<id>, expected)
    ; where(<echo-report> (i, t, result, <id>))

strategies

  /**
   * @type FILE -> FILE
   */
  sglr-asfix2(|sort, table) =
    core-sglr(|<conc> (<pass-custom-sglr-options> (), ["-2", "-p", table, "-s", sort]))

  /**
   * @type FILE -> ParseResult
   */
  sglri(|sort, table) = 
    core-sglri(|<conc> (<pass-custom-sglr-options> (), ["-2A", "-p", table, "-s", sort]))

  /**
   * @type FILE -> FILE
   */
  core-sglr(|options) =
    ?FILE(pathname)
    ; xtc-transform(!"sglr", !options)

  /**
   * @type FILE -> ParseResult
   */
  core-sglri(|options) =
    ?input@FILE(_);


    let /**
         * @type FILE ->parseResult
         */
        success =
          xtc-transform(!"implode-asfix", !["-b"])
          < !ParseResult(input, Success(<id>))
          + !ParseResult(input, Failure(Implode(<id>)))

        failure =
          !ParseResult(input, Failure(Parse(<read-from>)))

     in xtc-sglr-always(success, failure | options)
      ; if-verbose7(debug(!"ParseResult: "))
    end

strategies

  xtc-sglr-always(success, failure | options) =
    xtc-transform-always(success, failure | "sglr", options)

  /**
   * Do not fail if the tool invocation fails (non-zero exit
   * code). Instead, invoke <function>success</function> if the tool
   * succeeds, and <function>failure</function> if the tool fails.
   */
  xtc-transform-always(success, failure | tool, args) =
    ?FILE(f)
    ; where(<xtc-new-file> f => g)
    ; <conc> (args, ["-i", f, "-o", g])
    ; if xtc-command-silent(|tool) then
        <success> FILE(g)
      else
        <failure> FILE(g)
      end

  xtc-command-silent(|tool) =
    where(<xtc-find-warning> tool => loc)
    ; log(|Debug(),<concat-strings>["Invoking tool ", tool," at location ",loc," with arguments: "],<id>)
    ; where(<call(|None(), None(), Some(<open> "/dev/null"))> (loc, <id>))
