module parse-unit
imports
  liblib
  strategoxt-xtc-tools
  aterm-eq
  oldskool-parse-testsuite
  parse-testsuite
  test-results
  testsuite-upgrade

strategies

  main-parse-unit =
    xtc-io-wrap(parse-unit-options, parse-unit)

strategies

  parse-unit-options =
       parse-table-option
    <+ abstract-input-option
    <+ sglr-filter-options

  parse-table-option =
    ArgOption("-p"
    , where(<set-config> ("--parse-table", <id>))
    , !"-p <file>         Use parse table <file> (required)"
    )

  sglr-filter-options =
    Option("--no-heuristic-filters"
    , where(<extend-config> ("--sglr-options", ["-fi", "-fe"]))
    , !"--no-heuristic-filters  Don't use hearistic disambiguation filters (encouraged)"
    )

  abstract-input-option =
    Option("--abstract-input"
    , where(<set-config> ("--abstract-input", ()))
    , !"--abstract-input  Testsuite is in abstract syntax."
    )

  is-abstract-input =
    <get-config> "--abstract-input"

  get-extra-sglr-options =
    <get-config> "--sglr-options" <+ ![]

  get-parse-table =
    <get-config> "--parse-table" <+ <fatal-error> ["** ERROR: no parse table specified"]

  abs-test-file =
    <conc-strings> (<get-relative-prefix> "-i", <id>)

  get-relative-prefix =
       get-config; get-path
    <+ <conc-strings> (<getcwd>, "/")

strategies

  parse-unit = 
    if not(is-abstract-input) then
      xtc-sglr(!"parse-testsuite.tbl", !"TestSuite")
      ; xtc-implode-asfix
      <+ debug(!"warning: could not parse the testsuite. I'm assuming that it is in abstract syntax, but it there might actually be a syntactical error in your testsuite. Use the --abstract-input option for declare that you are providing an abstract syntax testsuite.")
    else id end
    ; read-from
    ; try(upgrade-oldskool-testsuite)
    ; parse-testsuite(id, id, map(try(add-description)))
    ; echo-start
    ; ?parse-testsuite(name(name), topsort(sort), <id>)
    ; map-with-index(execute-test(!sort, get-parse-table))
    ; !TestResults(<id>)
    ; where(<echo-results> (name, <id>))
    ; parse-unit-exit-on-failure
    ; write-to

  add-description :
    parse-test(string(s), output) -> parse-test(description(s), string(s), output)

  add-description :
    parse-test(file(f), output) -> parse-test(description(f), file(f), output)

  parse-unit-exit-on-failure =
    ?TestResults(<id>)
    ; map(?Success())
    <+ <exit> 1

  execute-test(sort, table) = 
      ?(i, <id>); ?t
    ; ?parse-test(description(n), input, expected)
    ; <parse> (<sort>, <table>, input)
    ; ?result
    ; <create-test-result> (<id>, expected)
    ; where(<echo-report> (i, t, result, <id>))

strategies

  echo-start =
    if-verbose1(
      where(
        ?parse-testsuite(name(name), _, tests)
      ; <echo> "-----------------------------------------------------------------------"
      ; <concat-strings; echo> ["executing testsuite ", name, " with ", <length; int-to-string> tests, " tests"]
      ; <echo> "-----------------------------------------------------------------------"
      )
    )

  echo-results =
    if-verbose1(
      where(	
        ?(name, TestResults(results))
      ; <echo> "-----------------------------------------------------------------------"
      ; <conc-strings; echo> ("results testsuite ", name)
      ; <conc-strings; echo> ("successes : ", <count-in-string(?Success())> results)
      ; <conc-strings; echo> ("failures  : ", <count-in-string(?Failure())> results)
      ; <echo> "-----------------------------------------------------------------------"
      )
    )

  echo-report =
    if-verbose1(
      ?(i, parse-test(description(n), _, expected), result, <id>)
    ; where(
        try(
          ?Success()
        ; <concat-strings; echo> ["* OK   : test ", <int-to-string> i, " (", n, ")"]
        )
      )
    ; where(
        try(
          ?Failure()
        ; <concat-strings; echo> ["* ERROR: test ", <int-to-string> i, " (", n, ")"]
        ; <echo-parse-result> result
        ; <echo-expected> expected
        )
      )
    )

  echo-parse-result :
    ParseResult(Failure(), _) -> <say(!"  - parsing failed")> ()

  echo-parse-result :
    ParseResult(Success(), file) -> <debug(!"  - succeeded: ")> t
      where <read-from> file => t

  echo-expected :
    pattern(p) -> <implode-aterm; debug(!"  - expected:  ")> p

  implode-appl :
    wildcard() -> "_"

  echo-expected :
    success() ->  <say(!"  - should succeed")> ()

  echo-expected :
    failure() ->  <say(!"  - should fail")> ()

strategies

  create-test-result =
       create-test-result-simple
    <+ create-test-compare
    <+ !Failure()

  /**
   * failure & success -> failure
   */
  create-test-result-simple:
    (ParseResult(Failure(), _), success()) -> Failure()

  /**
   * failure & pattern -> failure
   */
  create-test-result-simple:
    (ParseResult(Failure(), _), pattern(_)) -> Failure()

  /**
   * success & success -> success
   */
  create-test-result-simple:
    (ParseResult(Success(), _), success()) -> Success()

  /**
   * failure & failure -> success
   */
  create-test-result-simple:
    (ParseResult(Failure(), _), failure()) -> Success()

  /**
   * success & pattern -> compare
   */
  create-test-compare:
    (ParseResult(Success(), f@FILE(_)), pattern(p)) -> Success()
      where <aterm-eq> (<read-from; explode-aterm> f, p)

strategies

  count-in-string(s) = 
    filter(s); length; int-to-string

  parse = 
      ?(sort, table, input)
    ; <parse-helper> (<conc> (<get-extra-sglr-options> (), ["-2A", "-p", table, "-s", sort]), input)

  parse-helper = 
      ?(options, string(s))
    ; <print-to-tmp-file> s
    ; ?file
    ; finally(
        <parse-sglr> (options, file(<id>))
      , <rm-files> [file]
      )

  parse-helper :
    (opts, file(s)) -> <parse-sglr> (opts, file(<abs-test-file> s))
    
  parse-sglr =
      ?(options, file(pathname))
    ; !FILE(pathname)
    ; xtc-transform(!"sglr", !options)
    ; (   xtc-transform(!"implode-asfix", !["-b"])
        ; !ParseResult(Success(), <id>)
      <+  !ParseResult(Failure(), <id>)
      )
    <+ !ParseResult(Failure(), None())
  
  print-to-tmp-file =
      where(
        new-file => result-file
      ; <open-file> (result-file, "w") => stream
      )
    ; <print> (stream, [<id>])
    ; <close-file> result-file
    ; !result-file

