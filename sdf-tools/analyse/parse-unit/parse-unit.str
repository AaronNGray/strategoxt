module parse-unit
imports
  liblib
  strategoxt-xtc-tools
  aterm-eq
  oldskool-parse-testsuite
  parse-testsuite
  test-results
  testsuite-upgrade

strategies

  main-parse-unit =
    init-parse-unit-options
    ; xtc-io-wrap(parse-unit-options, parse-unit)

  init-parse-unit-options =
    where(<set-verbosity> 1)

strategies

  parse-unit = 
    read-parse-testsuite
    ; if get-single-test then
        do-single-test(|<get-single-test> ())
      else
        do-full-testsuite
      end
    ; <xtc-exit> 0

  do-full-testsuite =
    echo-start
    ; ?parse-testsuite(name(name), topsort(sort), <id>)
    ; map-with-index(execute-test(|sort, <get-parse-table> ()))
    ; !TestResults(<id>)
    ; where(<echo-results> (name, <id>))
    ; parse-unit-exit-on-failure
    ; write-to

  /**
   * Run a single test
   */
  do-single-test(|i) =
    ?parse-testsuite(name(name), topsort(sort), <id>)
    ; ( <index> (i, <id>)
      ; ?parse-test(description(s), file(f), output)
        <+ say(!"error: parse-unit: no such test."); fail)
    ; where(<debug(!"test : ")> s)

    ; !FILE(f)
    ; sglr-asfix2(|sort, <get-parse-table> ())
    ; if not(is-single-test-output-asfix2) then
        xtc-implode-asfix
      end

  read-parse-testsuite =
    if not(is-abstract-input) then
      xtc-sglr(!"parse-testsuite.tbl", !"TestSuite")
      ; xtc-implode-asfix
      <+ trying-abstract-syntax-warning
    end
    ; read-from
    ; try(upgrade-oldskool-testsuite)
    ; parse-testsuite(id, id, map(try(add-description)))
    ; parse-testsuite(id, id, map(ensure-test-input-in-file))

  trying-abstract-syntax-warning =
    debug(<concat-strings>
      [ "warning: could not parse the testsuite. I'm assuming that it "
      , "is in abstract syntax, but it there might actually be a syntactical "
      , "error in your testsuite. Use the --abstract-input option for declare "
      , "that you are providing an abstract syntax testsuite."
      ])

rules

  add-description :
    parse-test(string(s), output) -> parse-test(description(s), string(s), output)

  add-description :
    parse-test(file(f), output) -> parse-test(description(f), file(f), output)

/**
 * Ensures that the test input is in a file and makes it a complete path.
 */
rules

  ensure-test-input-in-file :
    parse-test(d, string(s), o) -> parse-test(d, file(f), o)
    where
      <print-to> [s] => FILE(f)

  ensure-test-input-in-file  =
    parse-test(id, file(abs-test-file), id)

rules

  parse-unit-exit-on-failure =
    ?TestResults(<id>)
    ; map(?Success())
    <+ <exit> 1

  execute-test(|sort, table) = 
      ?(i, <id>); ?t
    ; ?parse-test(description(n), file(f), expected)
    ; <sglri(|sort, table)> FILE(f)
    ; ?result
    ; <create-test-result> (<id>, expected)
    ; where(<echo-report> (i, t, result, <id>))

strategies

  /**
   * @type FILE -> FILE
   */
  sglr-asfix2(|sort, table) =
    core-sglr(|<conc> (<get-extra-sglr-options> (), ["-2", "-p", table, "-s", sort]))

  /**
   * @type FILE -> ParseResult
   */
  sglri(|sort, table) = 
    core-sglri(|<conc> (<get-extra-sglr-options> (), ["-2A", "-p", table, "-s", sort]))

  /**
   * @type FILE -> FILE
   */
  core-sglr(|options) =
    ?FILE(pathname)
    ; xtc-transform(!"sglr", !options)

  /**
   * @type FILE -> ParseResult
   */
  core-sglri(|options) =
    ?FILE(pathname)
    ; xtc-transform(!"sglr", !options)
    ; (   xtc-transform(!"implode-asfix", !["-b"])
        ; !ParseResult(Success(), <id>)
      <+  !ParseResult(Failure(), <id>)
      )
    <+ !ParseResult(Failure(), None())

strategies

/**
 * Determining the result.
 */
strategies

  create-test-result =
       create-test-result-simple
    <+ create-test-compare
    <+ !Failure()

  /**
   * failure & success -> failure
   */
  create-test-result-simple:
    (ParseResult(Failure(), _), success()) -> Failure()

  /**
   * failure & pattern -> failure
   */
  create-test-result-simple:
    (ParseResult(Failure(), _), pattern(_)) -> Failure()

  /**
   * success & success -> success
   */
  create-test-result-simple:
    (ParseResult(Success(), _), success()) -> Success()

  /**
   * failure & failure -> success
   */
  create-test-result-simple:
    (ParseResult(Failure(), _), failure()) -> Success()

  /**
   * success & pattern -> compare
   */
  create-test-compare:
    (ParseResult(Success(), f@FILE(_)), pattern(p)) -> Success()
      where <aterm-eq> (<read-from; explode-aterm> f, p)


/**
 * Presentation
 */
strategies

  echo-start =
    if-verbose1(
      where(
        ?parse-testsuite(name(name), _, tests)
      ; <echo> "-----------------------------------------------------------------------"
      ; <concat-strings; echo> ["executing testsuite ", name, " with ", <length; int-to-string> tests, " tests"]
      ; <echo> "-----------------------------------------------------------------------"
      )
    )

  echo-results =
    if-verbose1(
      where(	
        ?(name, TestResults(results))
      ; <echo> "-----------------------------------------------------------------------"
      ; <conc-strings; echo> ("results testsuite ", name)
      ; <conc-strings; echo> ("successes : ", <count-in-string(?Success())> results)
      ; <conc-strings; echo> ("failures  : ", <count-in-string(?Failure())> results)
      ; <echo> "-----------------------------------------------------------------------"
      )
    )

  count-in-string(s) = 
    filter(s); length; int-to-string

  echo-report =
    if-verbose1(
      ?(i, parse-test(description(n), _, expected), result, <id>)
    ; where(
        try(
          ?Success()
        ; <concat-strings; echo> ["* OK   : test ", <int-to-string> i, " (", n, ")"]
        )
      )
    ; where(
        try(
          ?Failure()
        ; <concat-strings; echo> ["* ERROR: test ", <int-to-string> i, " (", n, ")"]
        ; <echo-parse-result> result
        ; <echo-expected> expected
        )
      )
    )

  echo-parse-result :
    ParseResult(Failure(), _) -> <say(!"  - parsing failed")> ()

  echo-parse-result :
    ParseResult(Success(), file) -> <debug(!"  - succeeded: ")> t
      where <read-from> file => t

  echo-expected :
    pattern(p) -> <implode-aterm; debug(!"  - expected:  ")> p

  implode-appl :
    wildcard() -> "_"

  echo-expected :
    success() ->  <say(!"  - should succeed")> ()

  echo-expected :
    failure() ->  <say(!"  - should fail")> ()

/**
 * Options
 */
strategies

  parse-unit-options =
       parse-table-option
    <+ abstract-input-option
    <+ sglr-filter-options
    <+ single-option
    <+ single-asfix2-option
    <+ single-ast-option

  parse-table-option =
    ArgOption("-p"
    , where(<set-config> ("--parse-table", <id>))
    , !"-p <file>         Use parse table <file> (required)"
    )

  single-option =
    ArgOption("--single"
    , where(<set-config> ("--single", <string-to-int>))
    , !"--single <nr>     Parse test <nr> and output the result to the output"
    )

  get-single-test =
    <get-config> "--single"

  get-single-test-output =
    <get-config> "--single-output"

  is-single-test-output-asfix2 =
    get-single-test-output => "asfix2"

  single-asfix2-option =
    Option("--asfix2"
    , where(<set-config> ("--single-output", "asfix2"))
    , !"--asfix2          Parse to AsFix2 (only applicable when --single is used)"
    )

  single-ast-option =
    Option("--ast"
    , where(<set-config> ("--single-output", "ast"))
    , !"--ast             Parse to AST (only applicable when --single is used)"
    )

  sglr-filter-options =
    Option("--no-heuristic-filters"
    , where(<extend-config> ("--sglr-options", ["-fi", "-fe"]))
    , !"--no-heuristic-filters  Don't use hearistic disambiguation filters (encouraged)"
    )

  abstract-input-option =
    Option("--abstract-input"
    , where(<set-config> ("--abstract-input", ()))
    , !"--abstract-input  Testsuite is in abstract syntax."
    )

  is-abstract-input =
    <get-config> "--abstract-input"

  get-extra-sglr-options =
    <get-config> "--sglr-options" <+ ![]

  get-parse-table =
    <get-config> "--parse-table" <+ <fatal-error> ["** ERROR: no parse table specified"]

  abs-test-file =
    <conc-strings> (<get-relative-prefix> "-i", <id>)

  get-relative-prefix =
       get-config; get-path
    <+ <conc-strings> (<getcwd>, "/")
