/***************************************************************************
 *
 *  SDF Tools
 * 
 *  Pack-sdf creates an SDF definition file containing all modules
 *  imported from the given top module.
 *
 *  Copyright (C) 2001-2003 Merijn de Jonge <mdejonge@cwi.nl>
 *                          Eelco Visser <visser@acm.org>
 *                          Joost Visser <jvisser@cwi.nl>
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 ****************************************************************************/

module pack-sdf
imports lib Sdf-ParseTree-Syntax Kernel-Sdf-Syntax
	asfix-abstractions pack-graph stratego-xt-xtc-tools

strategies

  pack-sdf = 
    xtc-iowrap(pack-sdf-options,
      pack-sdf-modules => (files, spec)
      ; (<get-config> "--imports"
        ; <map(get-filename; basename); write-to-text> files
       <+ <create-dep-file> files
        ; <write-to> spec
        )
    )

  pack-sdf-options =
      ArgOption("-I" + "--Include",        
	where(<extend-config>("-I", ["-I", <id>])); !(),
	!"-I d | --Include d   Include modules from directory d")

    + Option("--nodep" + "-nodep", 
	where(<set-config> ("--nodep", "")); !(),
	!"--nodep              Don't create dependency file")

    + ArgOption("--dep" + "-d" + "-dep",
	where(<set-config> ("--dep", <id>)); !(),
	!"--dep f | -d f       Write dependency to file f")

    + Option("--imports",
	where(<set-config> ("--imports", ())); !(),
	!"--imports            Produce a list of imported modules only")

  create-dep-file :
    files -> FILE(depfile)
    where <get-config> "-o" => outfile
        ; (<get-config> "--dep" <+ not(<get-config> "--nodep")) => dep-base
        ; <add-extension> (<id>, "dep") => depfile
        ; <open-file> (depfile, "w") => dep
        ; <printnl> (dep, [dep-base | <separate-by>(" \\\n\t", [" :" | files])])
        ; <close-file> dep

  pack-sdf-modules =
    ?FILE(infile)
    ; where((<get-config; filter(not("-I"))> "-I" <+ ![]) => path)
    ; !([infile], (), [])
    ; graph-nodes-roots(Fst; get-sdf-module(!["." | path])
		       , get-sdf-imports
		       , \ (n,x,xs) -> [x|xs] \ )
    ; unzip
    ; (id, flatten-sdf)

  get-sdf-module(mkpath) :
    mod -> (name, tree)
    where <find-sdf-module(mkpath)> (<basename> mod, ["sdf"])
		=> (ext, FILE(name))
        ; if-verbose3(where(<debug(!" reading ")> name))
	; parse-sdf-module => tree

  find-sdf-module(mkpath) =
    ?(mod, exts)
    ; mkpath
    ; (fetch-elem(\ dir
	 -> <fetch-elem(!(<id>, FILE(<concat-strings; file-exists> [dir, "/", mod, ".", <id>])))> exts 
       \ )
     <+ <fatal-error> ["*** Module ", mod, " not found"])

  parse-sdf-module =
    ?("sdf", name); Snd
    ; (xtc-parse-sdf; read-from
       <+ <fatal-error> ["parse error in ", name])


  get-sdf-imports =
    collect(?appl(prod(_,cf(sort("Import")),_),_); get-module-name, 
            skip-non-imports)


  skip-non-imports(search, ignore) =  
    parsetree(search,id)
    //<+ appl(prod(id, cf(sort("Module")),id),[id,id,id,search,id,search])
    <+ appl(prod(id, cf(opt(layout) <+ 
                        sort("Productions" <+ "Symbols" <+ 
                             "Priorities" <+ "Restrictions" <+
                             "Aliases")), id); ignore, ignore)
    <+ appl(ignore,search)


// Obtain module name from Import construct by removing optional parameters

  get-module-name =
    oncetd(?appl(prod(_,cf(sort("ModuleId")),_),_);yield=>y);
    !y

// Composing AsFix; The parser produces an AsFix term for each module. These
// have to be merged into a list of modules. This entails merging the layout
// at the end and start of subsequent trees. Note that the prefer longets
// match of laout is not considered here. This means that the layout nodes may not be
// equivalent to the layout nodes when parsing the resulting definition file:
// 
//   parse( unparse(pack(m))) != pack(m) 
//



flatten-sdf = 
  foldr(!(NoCfLayout, EmptyModuleIterStar, NoCfLayout)
       , concat-modules
       , \ [Module_START(w1, m, w2)] -> (NoCfLayout, M-iter(m), NoCfLayout) \ 
       )
  ; \ (w1, modules, w2) ->
      parsetree(SDF_START(NoCfLayout, 
        Definition-overlay(
           <concat-layout>[OptNewLine, w1], 
           Module-s-overlay(NonEmptyModuleIterStar(modules))),w2), 0) \

concat-modules =
   ?( (w1, m1, w2), (w3, m2, w4) );
   !(w1, MM-iter( 
            m1, 
            <concat-layout>[w2, OptNewLine, OptNewLine, w3], 
            m2), w4)

signature
constructors
'id: Arg -> ID
overlays 

// Module -> <START>
Module_START(w1, t, w2) =
   appl(prod([sort("<START>")],sort("SURROGATE-START"),attrs([term(cons("\"sdf-2.1\""))])),[
   appl(prod([cf(opt(layout)),cf(sort("Module")),cf(opt(layout))],sort("<START>"),no-attrs)
   ,[w1,t,w2])])

// SDF -> <START>
SDF_START(w1, t, w2) =
   appl(prod([sort("<START>")],sort("SURROGATE-START"),attrs([term(cons("\"sdf-2.1\""))])),[
   appl(prod([cf(opt(layout)),cf(sort("SDF")),cf(opt(layout))],sort("<START>"),no-attrs)
   ,[w1,t,w2])])

//   -> M*
EmptyModuleIterStar =
   appl(
   prod([],cf(iter-star(sort("Module"))),no-attrs),[])

// M+ -> M*
NonEmptyModuleIterStar(m) = 
   appl(
prod([cf(iter(sort("Module")))],cf(iter-star(sort("Module"))),no-attrs),[m])

// M+ M+ -> M+ {left}
MM-iter(m1, w, m2) =
appl(prod([cf(iter(sort("Module"))),cf(opt(layout)),cf(iter(sort("Module")))],cf(iter(sort("Module"))),attrs([atr("left")])),[
m1, w, m2])

// M -> M+
M-iter( m ) = 
appl(prod([cf(sort("Module"))],cf(iter(sort("Module"))),no-attrs),[m])

//  Module* -> Definition
Module-s-overlay ( g_6 ) = appl ( prod ( [ cf ( iter-star ( sort ( "Module" ) ) ) ] , cf ( sort ( "Definition" ) ) , no-attrs  ) , [ g_6 ] )

// definition Definition -> SDF
Definition-overlay(b_1,c_1) = 
appl(prod([lit("definition"),cf(opt(layout())),cf(sort("Definition"))],cf(sort("SDF")),attrs([term(cons("Definition")),'id("Sdf2-Syntax")])),[appl(prod([

char-class([100]),
char-class([101]),
char-class([102]),
char-class([105]),
char-class([110]),
char-class([105]),
char-class([116]),
char-class([105]),
char-class([111]),
char-class([110])],lit("definition"),no-attrs()),[100,101,102,105,110,105,116,105,111,110]),b_1,c_1])

