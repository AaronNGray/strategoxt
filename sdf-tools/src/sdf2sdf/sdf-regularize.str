/**
 * Recognize groups of productions that can be expressed by means of
 * a regular expression. Assumptions: (1) all productions for a sort are
 * in one context-free syntax section (2) all productions are available.
 * Sorts representing regular expressions are replaced by these expressions
 * to improve the abstract syntax of the language (no superfluous injections).
 *
 * Author: Eelco Visser
 */
module sdf-regularize
imports lib Sdf2 dynamic-rules

strategies

  sdf-regularize =
    io-wrap(regularize)

  regularize = 
      alltd(
        context-free-syntax(
          order-productions
        ; (RegularizeList <+ RegularizeOptional)
        )
      )
    ; inline-lists-and-optionals

strategies

  order-productions = 
    qsort(not(ProdGT))

  ProdGT =
    ?(prod(as, a, _), prod(as', a, _))
    ; where(<gt>(<length> as, <length>as'))

  ProdGT =
    ?(prod(as, a, _), prod(bs, b, _))
    ; where(<not(eq); string-gt> (a, b))

/**
 * Lists
 */
rules

  RegularizeList : // a* -> b
     [prod([],   b, attrs([])),
      prod([b,a],b, attrs([]))]
  -> [prod([iter-star(a)],b,attrs([]))]

  RegularizeList : // a* -> b
    [prod([],   b, attrs([])),
     prod([a,b],b,attrs([]))]
  ->
    [prod([iter-star(a)],b,attrs([]))]

  RegularizeList : // a* -> b
    [prod([],   b,attrs([])),
     prod([a],  b,attrs([])),
     prod([b,a],b,attrs([]))]
  ->
    [prod([iter-star(a)],b,attrs([]))]

  RegularizeList : // a+ -> b
    [prod([a],  b,attrs([])),
     prod([b,a],b,attrs([]))]
  ->
    [prod([iter(a)],b,attrs([]))]

  RegularizeList : // (a|c)* -> b
    [prod([],   b,attrs([])),
     prod([b,a],b,attrs([])),
     prod([b,c],b,attrs([]))]
  ->
    [prod([iter-star(alt(a,c))],b,attrs([]))]

/**
 * Lists of seqences
 */
rules

  RegularizeList : // (a as)* -> b
    [prod([],          b,attrs([])),
     prod([b, a | as], b,attrs([]))]
  -> 
    [prod([iter-star(seq(a, as))],b,attrs([]))]
    where <not([])> as

/**
 * Lists with separators
 */
rules

  RegularizeList : // {A B}+
    [prod([],       b,attrs([])),
     prod([a],      b,attrs([])),
     prod([a,sep,b],b,attrs([]))]
  ->
    [prod([iter-star-sep(a, sep)],b,attrs([]))]

  RegularizeList : // {A B}*
    [prod([a],      b,attrs([])),
     prod([a,sep,b],b,attrs([]))]
  ->
    [prod([iter-sep(a, sep)],b,attrs([]))]

  RegularizeList : // {A B}*
    [prod([a],      b,attrs([])),
     prod([b,sep,a],b,attrs([]))]
  ->
    [prod([iter-sep(a, sep)],b,attrs([]))]

/**
 * Optionals
 */
rules

  RegularizeOptional : // a?
    [prod([], b,attrs([])),
     prod([a],b,attrs([]))]
  -> 
    [prod([opt(a)],b,attrs([]))]

  RegularizeOptional : // (a1 a2 ..)?
    [prod([],           b,attrs([])),
     prod([a1, a2 | as],b,attrs([]))]
  -> 
    [prod([opt(seq(a1, [a2 | as]))],b,attrs([]))]

strategies

  inline-lists-and-optionals =
    alltd(find-inlineables);
    alltd(prod(alltd(ReplaceSymbol),id,id))

  find-inlineables : 
    context-free-syntax([prod([a],b,attrs([]))]) -> context-free-syntax([])
    where <inlineable> a
        ; rules(ReplaceSymbol : b -> a)

  find-inlineables : 
    context-free-syntax([prod([opt(seq(a,as))],b,attrs([]))]) -> 
    context-free-syntax([prod([a | as],b,attrs([]))])
    where rules(ReplaceSymbol : b -> opt(b))

  inlineable = 
    opt(not(seq(id,id))) + iter(id) + iter-star(id) + iter-sep(id,id) + iter-star-sep(id,id)
