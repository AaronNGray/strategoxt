module sdf2sg
imports lib sdf-analysis GraphXML Literal-lib
strategies

  main =
    io-wrap(sort-graph; !"\"graphxml_1_1-0\""#([<id>]))

  sort-graph
    = where(collect-edges => es)
    ; where(collect-nodes => ns)
    ; !(es,ns);conc
    //; !(es,[]);conc
    //; !es
    ; graph-from-edges

  collect-edges
    = collect( \prod    (  ss,s,_) -> <build-edges>(ss ,<get-sortname>s)\
            <+ \prod-fun(_,ss,s,_) -> <build-edges>(ss ,<get-sortname>s)\
            <+ \alias   (   a,s)   -> <build-edges>([a],<get-sortname>s)\
             , skip-appl // skip the production child of non-imploded application node
             )
    ; concat
    ; uniq

  get-sortname
    = \sort(s) -> s\
   <+ \layout() -> "LAYOUT"\

(*
  collect-nodes
    = where( declared-sorts        => alldecs )
    ; where( <uniq>alldecs         => decs )	// Declared sorts
    ; where( defined-sorts         => defs ) 	// Defined sorts
    ; where( used-sorts            => uses )	// Used sorts
    ; where( !(defs,uses);diff     => tops )	// Top sorts
    //; where( !alldecs; doubles             )    // Multiply declared sorts
    ; where( !(defs,uses);union    => srts )
    ; where( !(srts,decs);diff     )		// Non-declared sorts
    ; where( !(uses,defs);diff     => bs   )	// Bottom sorts
    ; where( !(tops,decs);diff     => ndts )	// Non-declared top sorts
    ; where( !(decs,srts);diff     )		// Unknown declared sorts
    ; !bs ; map( \s -> node1([name(<quote>s),class(<quote>"bottom")])\ )
*)

  collect-nodes
    = \grammar -> nodes
       where <declared-sorts>grammar => alldecs
           ; <uniq>alldecs           => decs	// Declared sorts
           ; <defined-sorts>grammar  => defs	// Defined sorts
           ; <used-sorts>grammar     => uses	// Used sorts
           ; <diff>(defs,uses)    => tops	// Top sorts
           ; <union>(defs,uses)   => srts 
           ; <diff>(srts,decs)			// Non-declared sorts
           ; <diff>(uses,defs)    => bs		// Bottom sorts
           ; <diff>(tops,decs)    => ndts	// Non-declared top sorts
           ; <diff>(decs,srts)			// Unknown declared sorts
           ; <isect>(tops,decs)   =>  dts	// Declared top sorts
           ; <concat>[<map(mk-bottom-node)>bs,
                      <map(mk-nondeclared-top-node)>ndts,
                      <map(mk-declared-top-node)>dts,
                      <map(mk-declared-node)>decs
                     ]              => nodes
       \

  mk-bottom-node
    = \n -> node1([name(<quote>n),class(<quote>"bottom")])\
  mk-nondeclared-top-node
    = \n -> node1([name(<quote>n),class(<quote>"nondeclared-top")])\
  mk-declared-top-node
    = \n -> node1([name(<quote>n),class(<quote>"declared-top")])\
  mk-declared-node
    = \n -> node1([name(<quote>n),class(<quote>"declared")])\

  graph-from-edges
    = ?es;
      !GraphXML([],[graph([],es)])

  build-edges
    = \(ss,s) -> <filter(collect(\x -> <mk-edge>(<get-sortname>x,s)\));concat>ss\

  mk-edge
    = \(x,y) -> edge1([source(<quote>x),target(<quote>y)])\

  skip-appl(x,t)
    = \appl(_,ts) -> <x>ts\

signature
  constructors
    appl : Production * List(AsFixTerm) -> AsFixTerm
