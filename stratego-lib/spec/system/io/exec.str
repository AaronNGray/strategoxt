/**
 * Transformation systems often consist of multiple components, e.g.,
 * parsers, pretty-printers and several actual transformation
 * components.
 * 
 * To glue these components together this module defines the
 * process control primitive \verb|call|.
 */
module system/io/exec
imports 
  system/io/process 
  system/io/file 
  util/config/verbose

// TODO: restructure and check what strategies should be deprecated
// because of alternatives in the SSL or XTC.

strategies

  pipe-term-to-child(prog, args) = 
    ?t; where(prog => prog-trm; args => args-trm)
    ; prim("SSL_pipe_term_to_child", t, prog-trm, args-trm)

strategies // non-primitives

  redirect-stdout-to-file =
    ?file
    ; where(STDOUT_FILENO
            ; close
            ; <creat> file)

  redirect-stdin-from-file =
    ?file
    ; where(STDIN_FILENO
            ; close
            ; <open> file)

/**
 * (Very) old stuff
 */
strategies

  // rm-files :: List(String) -> List(String)
  // remove files

  rm-files = 
    ?files; where(<call> ("rm", ["-f" | files]))

  pipe(c, suf2) = 
    pipe(c, suf2, ![])

  pipe(c, suf2, args) = 
    where(conc-strings => 'in);
    (id, suf2);
    where(conc-strings => out);
    //where(<debug(!"calling : ")> [<c>, 'in, out | <args>]);
    where(<call> (<c>, ["-i", 'in, "-o", out | <args>]))

  pipe'(c, suf2, args) = 
    obsolete(!"pipe'/3; use pipe/3");
    pipe(c, suf2, args)

 /**
  * Apply command <comm> to input file (current term) and write the result to a temporary file
  * which is then passed on to the continuation command cont. The temporary file is created
  * and removed afterwards by temp-file.
  *
  * @type (a -> String) * (b -> List(String)) * (String -> String) -> (String -> String)
  */
  call-tmp(comm, args, cont) = 
    ?filein
    ; temp-file(\ (fileout, _) -> <
        <if-verbose5(debug); call>(<comm>, ["-i", filein, "-o", fileout | <args> ])
        ; !fileout
        ; cont
      >\ )

 /**
  * Apply command <comm> to the current file (current term) and write the result to 
  * file <out>. <args> are additional arguments for the command. cont is the continuation
  * which applies to the filename of the result.
  *
  * @type (a -> String) * (b -> List(String)) * (c -> String) * (String -> d) -> (String -> d)
  */
  call-out(comm, args, out, cont) = 
    ? filein
    ; <call>(<comm>, ["-i", filein, "-o", <out> | <args> ])
    ; out
    ; cont

 /**
  * The strategy <transform-file(s, suf)> (base, ext) reads in the
  * term from file "base.ext", applies strategy s to
  * it and write the result to the concatenation of the
  * strings (base, <suf>()).
  */
  transform-file(s, suf) =
    where(conc-strings => 'in);
    (id, suf);
    where(conc-strings => out);
    where(<apply-to-file(s)> ('in, out))

  apply-to-file(s) =
    ?('in, out);
    where(<ReadFromFile; s> 'in => trm);
    where(<WriteToBinaryFile> (out, trm))

  copy-file(s, new-base, new-suf) =
    ?(base, suf);
    (new-base, new-suf); 
    ?(nbase, nsuf);
    where(<apply-to-file(s)> 
	    (<conc-strings> (base, suf),
	     <conc-strings> (nbase, nsuf)))

  apply-program(name) = 
    apply-program(name, ![])
  
  apply-program(name, args) = 
    temp-file(
      ?(infile,_)
    ; WriteToBinaryFile
    ; temp-file(
        ?(outfile,_)
      ; <call> (<name>(), ["-i", infile, "-o", outfile | <args>()])
      ; <ReadFromFile> outfile
      )
    )

