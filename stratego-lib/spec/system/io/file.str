/**
 * The file module provides abstractions over the basic file system
 * operations in the module posix-file.
 */
module system/io/file
imports 
  system/posix/file 
  system/io/-
  collection/list/-
  term/string

/**
 * Abstractions for streams
 */
strategies

  /**
   * Opens a Stream associated to a FileLoc
   *
   * @type (FileLoc, String) -> Stream
   */
  open-stream = ?(_, _);
    (  Fst; stdio-stream
    <+ (?Path(<id>), id); fopen
    <+ (is-string,   id); fopen
    )

  /**
   * @type FileLoc -> Stream
   */
  stdio-stream = ?stdin() ; stdin-stream
  stdio-stream = ?stdout(); stdout-stream
  stdio-stream = ?stderr(); stderr-stream

strategies

  /**
   * @type  String -> String
   */
  file-exists =
    <access> (<id>, [F_OK()])

  /**
   * @type  String -> String
   */
  can-read-file =
    <access> (<id>, [R_OK()])

  is-readable = can-read-file

  /**
   * @type  String -> String
   */
  can-write-file =
    <access> (<id>, [W_OK()])

  is-writable = can-write-file

  /**
   * @type  String -> String
   */
  can-execute-file =
    <access> (<id>, [X_OK()])

  is-executable = can-execute-file

  /**
   * @type String -> String
   * @inc  create?
   */
  can-create-file =
    where(dirname; can-write-file)

/**
 * Components of a pathname
 */
strategies

  /**
   * Returns directory portion of pathname in a POSIX compatible way.
   *
   * @inc   dirname
   * @type  String -> String
   */
  dirname =
    string-as-chars(
      /* (1) Strip trailing slashes */
      try(split-init-last; ?(<id>, '/'))
    ; /* (2) If string consists entirely of slash characters, string shall be
             set to a single slash character.  In this case, skip steps (3)
             through (8). */
    ( ?[]
      < !['/']
      + ( /* (3) If there are any trailing slash characters in string, they
                 shall be removed. */
          init
          /* (4) If there are no slash characters remaining in string, string
                 shall be set to a single period character.  In this case, skip
                 steps (5) through (8).

             (5) If there are any trailing nonslash characters in string,
                 they shall be removed. */

        ; repeat(split-init-last; (id, not(?'/')); Fst)
        ; (?[]
          < !['.']
          + ( /* (7) If there are any trailing slash characters in string, they
                   shall be removed. */
              repeat(split-init-last; ?(<id>, '/'))
            ; (?[] < !['/'] + id))))))

  /**
   * Return the absolute path of a pathname.
   *
   * @type  String -> String
   * @since 0.9.4
   */
  abspath =
      is-abspath
    < id
    + <concat-strings> [<getcwd> (), "/", <id>]

  /**
   * Succeeds if the input pathname is an absolute path.
   *
   * A pathname is absolute if it starts with a /.
   *
   * @type  String -> String
   * @since 0.9.4
   * @inc   is-abs-path
   */
  is-abspath =
    where(explode-string; ?['/' | _])

  /**
   * Succeeds if the input pathname is a relative path.
   *
   * A pathname is relative if it does not start with a /.
   *
   * @type  String -> String
   * @since 0.9.4
   */
  is-relpath =
    not(is-abspath)

  /**
   * Strips the directory from a pathname.
   *
   * @type  String -> String
   * @inc   base-filename-test
   */
  base-filename =
      <string-tokenize> (['/'], <id>)
    ; last
  
/**
 * Strategies for file extensions
 */
strategies

  /**
   * Drops the current extension and replaces it with the specified extension.
   *
   * @type   String -> String
   * @since  0.15
   * @inc    guarantee-extension
   */    
  guarantee-extension(|ext) =
    remove-extension
    ; <add-extension> (<id>, ext)

  /**
   * Checks if the file extension is ext.
   *
   * @param  The required extension (without . )
   * @type   String -> String
   * @since  0.15
   * @inc    has-extension
   */
  has-extension(|ext) =
    test-extension(?ext)
    
  /**
   * Tests if the file extension (everything after the . satisfies ext.
   *
   * @param  Test for the file extension. Is applied to the plain file extension (without the .)
   * @since  0.15
   * @inc    test-extension
   */
  test-extension(ext) =
    where(
      get-extension
      ; ext
    )

  /**
   * Adds an extension (second argument) to a path (first argument).
   *
   * @type (String, String) -> String
   */
  add-extension : 
    (name, ext) -> <concat-strings> [name, ".", ext]

  /**
   * Remove an extension from a file name.
   * Returns the input if the file does not have an extension.
   *
   * @inc  remove-extension
   * @type String -> String
   */
  remove-extension =
    if get-extension; explode-string; !['.' | <id>] => ext then
      explode-string
      ; at-suffix(?ext; ![])
      ; implode-string
    end

  /**
   * Get extension from filename
   *
   * @type   String -> String
   */
  get-extension =
    explode-string
    ; list-tokenize(|['.'])
    
    /**
     * There should be at least two elements in the result, otherwise 
     * there is not extension.
     */
    ; ?[_, _ | _]
    
    /**
     * The match of ?[base, ext] cannot be placed in at-suffix due to
     * the lack of unbinding of variables on backtracking.
     */
    ; at-suffix(?[_, _]; ?lastwo)
    ; !lastwo => [base, ext]
    ; where(
        /**
         * The n-th . part should not contain / \ :
         * in that case it is not a real extension
         */
        <not(fetch(?'/' + ?'\'))> ext
        
        /**
         * The (n-1)th part should not end with a / or \
         * in that case, part n is not a real extension.
         */
      ; <last; not(?'/' + '\')> base
      )
    ; <implode-string> ext
    
/**
 * Generate a new, not existing file name.
 */
strategies

  /**
   * Safe, mkstemp based, creation of temporary file
   * 
   * @type _ -> (String, FileDescr)
   */
  new-temp-file =
      <conc-strings> (<temp-dir>, "/StrategoXT")
    ; mkstemp

  /**
   * Safe, mkdtemp based, creation of temporary directory
   * 
   * @type  _ -> String
   */
  new-temp-dir =
      <conc-strings> (<temp-dir>, "/StrategoXT")
    ; mkdtemp

/**
 * find files in paths
 */
strategies

  /**
   * Finds a file in a list of directories (a path).
   *
   * <find-path(strict|path)> f looks for a file with name f in the list of
   * directories path. If the file is not found the behaviour depends on the
   * strategy strict, if it succeeds a fatal-error is flagged, otherwise the
   * strategy just fails.
   *
   * Example (when run in strategoxt root):
   *   <find-in-path(id|["ssl/spec","ssl/tests"])> "file.str" => "ssl/spec/file.str"
   */

  find-in-path(strict|path) = 
    ?file
    ; ( file-exists
      <+ <fetch-elem(<concat-strings; file-exists> [<id>,"/",file])> path
      <+ if strict then <fatal-error> ["no such file: ", file] else fail end
      )

  /**
   * Finds a file in a list of directories (a path).
   *
   * Differs from find-in-path/(0,0) in that it exits with fatal-error if file is
   * not found.
   *
   * @param should build a list of paths in which the search is performed.
   */

  find-in-path(|path) =
    find-in-path(id|path)

  /**
   * Finds a file in a list of directories (a path)
   *
   * @obsolete.
   *
   * This strategy operates on a tuple (f, [d*]) where f is the name of the file
   * to be found, and d* are the directories to search in. The full path of the
   * first match is the output term.
   *
   * Example (when run in strategoxt root):
   *   <find-in-path> ("file.str", ["ssl/spec", "ssl/tests"]) => "ssl/spec/file.str"
   */

  find-in-path =
    ?(file, path); <find-in-path(fail|path)> file

  /** 
   * @obsolete
   */

  find-in-path(mkpath) =
    find-in-path(|<mkpath>)

  /**
   * Finds one file with a specific file extension in a list of directories.
   *
   * This strategy operates on a tuple (f, [d*]). The one file that will be
   * searched for is determined by the basename of f and the requested file
   * extension.
   * Example:
   *   <find-file(!"rtree")> ("file.str", ["."])
   * searches for file.rtree in the current dir.
   *
   * @param should build the file extension as a string.
   */

  find-file(|ext, path) =
    guarantee-extension(|ext)
    ; find-in-path(fail|path)

  find-file(|ext) =
    ?(file, path)
    ; <find-file(|ext, path)> file

  /**
   * @obsolete
   */

  find-file(ext) =
    find-file(|<ext>)

  /**
   * Finds one file with a specific file extension in a list of directories.
   *
   * Differs from find-file/(1,0) in that it exits with fatal error if file is
   * not found.
   *
   * @param should build a list of paths in which the search is performed.
   * @param should build the file extension as a string.
   */
  find-file(mkpath, ext) =
    guarantee-extension(|<ext>)
    ; find-in-path(|<mkpath>)

/**
 * Obsolete strategies
 */    
strategies

  /**
   * Strip extension from a pathname.
   *
   * @obsolete use remove-extension
   *
   * @warning  basename is not comparable to the basename of sh. 
   *           sh's basename strips the direcrory an optionally the suffix.
   *
   * @type     String -> String
   * @inc      basename-test
   */
  basename =
    obsolete(!"basename; use remove-extension")
    ; basename(id)

  /**
   * Strip extension from a pathname.
   *
   * @obsolete use test-extension(s); remove-extension   
   *
   * @warning basename is not comparable to the basename of sh. 
   *          sh's basename strips the direcrory an optionally the suffix.
   *
   * @param    checks the extension
   * @type     String -> String
   */
  basename(ext) =
    obsolete(!"basename(ext); use test-extension(s); remove-extension")
    ; explode-string
    ; try(rec x([id|x] <+ ['/' | id] <+ ['.' | ext]; ![]))
    ; implode-string
    
  /**
   * Drops the current extension and replaces it with the specified extension.
   *
   * @obsolete  use guarantee-extension(|t)
   * @type      String -> String
   */
  guarantee-extension(ext) =
    obsolete(!"guarantee-extension(s); use guarantee-extension(|t)")
    ; basename
    ; <add-extension> (<id>, <ext> ())
    
  /**
   * Checks whether the argument is a string that ends in ext.
   *
   * @obsolete  use has-extension(|t)
   * @param     Strategy that produces a string for the extension.
   * @type      String -> String
   */
  has-extension(ext) =
    obsolete(!"has-extension(s); use has-extension(|t), without a dot in the extension argument.")
    ; where(
        ext
        ; explode-string
        ; try(?['.' | <id>])
        ; implode-string
        ; ?ext-term
      )
    ; has-extension(|ext-term)

  /**
   * Creates a fresh file in the current directory.
   *
   * @obsolete  use new-temp-file or XTC temporary files
   */
  new-file =
    obsolete(!"new-file; use new-temp-file or XTC temporary files")
    ; rec x(<conc-strings> (<new>(), ".tmp"); try(file-exists; x))

  /**
   * @obsolete use XTC scoped temporary files
   * @param    (String, a) -> b
   * @type     a -> b
   */
  temp-file(s) =
      obsolete(!"new-file; use XTC scoped temporary files")
    ; where(new-file => f)
    ; <finally(s, try(<remove-file> f))> (f, <id>)
  
  /**
   * Path from program name "/usr/local/bin/prog" -> "/usr/local/bin/"
   *
   * @obsolete  use dir-name
   * @inc       get-path-test
   */
  get-path = 
    obsolete(!"get-path; use dirname")
    ; explode-string
    ; (rec x([id|x] <+ [47|![]]) <+ ![])
    ; implode-string

  /**
   * File name from path "/usr/local/bin/prog" -> "prog"
   *
   * @obsolete  use base-filename
   * @inc       get-filename-test
   */
  get-filename = 
    obsolete(!"get-filename; use base-filename")
    ; explode-string
    ; try(at-suffix-rev(?['/' | name]); !name)
    ; implode-string

/**
 * Old file administration
 */
strategies

  /**
   * @obsolete use streams and fclose
   */
  close-file = 
    ?name
    ; obsolete(!"close-file; use streams and fclose")
    ; prim("SSL_close_file", name)

  /**
   * @obsolete use fopen and streams
   */
  open-file =
    ?(name, mode)
    ; obsolete(!"open-file; use fopen and streams")
    ; prim("SSL_open_file", name, mode)

  /**
   * @obsolete use <open-file> (file, mode)
   */
  open-file =
    ?name; not(?(_, _))
    ; obsolete(!"<open-file> file; use <open-file> (file, mode)")
    ; <open-file> (name, "w")

  /**
   * @obsolote use fopen in append mode and streams
   */
  append-file =
    obsolete(!"append-file; use fopen in append mode and streams")
    ; <open-file> (<id>, "a")    
