/**
 * Term input and output.
 */
module system/io/term
imports 
  system/io/*
  term/string 
  term/integer
  collection/list/*
  strategy/conditional
  util/config/options
  
/**
 * Term input and output
 */
strategies

  /**
   * <ReadFromFile> file reads the term in file. 
   * The file needs to be in textual or binary ATerm format.
   * 
   * @type File -> a
   */
  ReadFromFile =
      ( <open-stream> (<id>, "r")
      <+ <conc-strings; perror; fail> ("SSL/ReadFromFile ", <id>))
    ; where(read-from-stream => trm)
    ; fclose
    ; !trm

  /**
   * <WriteToBinaryFile> (file, term) writes term to file in BAF format.i
   *
   * @type File * a -> a
   */
  WriteToBinaryFile = 
    WriteToFile(write-in-baf-to-stream)

  /**
   * <WriteToTextFile> (file, term) writes term to file in textual ATerm format.
   *
   * @type File * a -> a
   */
  WriteToTextFile = 
    WriteToFile(write-in-text-to-stream; <fputc> ('\n', <id>))

  /**
   * <WriteToFile(s)> (file, term) writes term to file with the writer s.
   *
   * @type (Stream * a -> Stream) * File * a -> a
   */
  WriteToFile(writer) =
      ?(<id>, trm)
    ; <open-stream> (<id>, "w")
    ; <writer> (<id>, trm)
    ; fclose
    ; !trm

  open(file) = 
    file; ReadFromFile

  save(file) = 
    <WriteToTextFile> (<file>, <id>)

/**
 * ATerm input and output with streams
 *
 * @TODO move to io module.
 */
strategies

  /**
   * Writes an ATerm to a Stream.
   *
   * @type Stream * _ -> Stream
   */
  write-to-stream =
    write-in-baf-to-stream

  write-in-baf-to-stream =
    ?(Stream(stream), term); prim("SSL_write_term_to_stream_baf", stream, term); !Stream(<id>)

  write-in-taf-to-stream =
    ?(Stream(stream), term); prim("SSL_write_term_to_stream_taf", stream, term); !Stream(<id>)

  write-in-text-to-stream =
    ?(Stream(stream), term); prim("SSL_write_term_to_stream_text", stream, term); !Stream(<id>)

  /**
   * Reads an ATerm from a Stream
   *
   * @type Stream -> _
   */
  read-from-stream =
    ?Stream(stream); prim("SSL_read_term_from_stream", stream)

  /**
   * Reads an ATerm from a String
   *
   * @type String -> _
   */
  read-from-string =
    ?s; prim("SSL_read_term_from_string", s)

  /**
   * Writes an ATerm to a String
   *
   * @type a -> String
   */
  write-to-string =
    ?t; prim("SSL_write_term_to_string", t)

strategies

  /**
   * Prints the terms to a stream. If a term is a string it is printed 
   * without quotes, otherwise it is printed as a term.
   *
   * @type Stream * [a] -> Stream
   */
  fprint =
      ?(stream, <id>)
    ; map(
        where(
          is-string
        < <fputs> (<id>, stream)
        + <write-in-text-to-stream> (stream, <id>)
        )
      )
    ; !stream

  /**
   * fprint, followed by a newline.
   *
   * @type Stream * [a] -> Stream
   */
  fprintnl =
    fprint; <fputc> ('\n', <id>)

 /**
  * Prints terms to a file. If \verb|ti| is a string it is printed without 
  * quotes, otherwise it is printed as a term. \verb|printnl| has the same
  * behaviour, but also prints a newline after \verb|tn|.
  *
  * Before printing to a file the file should be opened using
  * <open-file>filename , which truncates the file, or creates
  * it if it doesn't exist.  To append to a file, open the file
  * with <append-file>filename .  The file is created if it
  * doesn't exist.
  * 
  * E.g. <print> (file, [t1,...,tn]) prints terms ti to file. Terms ti 
  * that are strings are printed without quotes  
  */
  print = 
    ?(name, strs); where(prim("SSL_print", name, strs))

 /**
  * Same as print, but prints a newline at the end. 
  *
  * E.g. <printnl> (file, [t1,...,tn])
  */
  printnl = 
    ?(name, strs); where(prim("SSL_printnl", name, strs))

strategies

  print-strings-nl(out) =
    where(<printnl> (<out>, <id>))

strategies

  /**
   * Prints the current term to stderr without changing it.
   * This is a useful strategy for debugging specifications (hence its name).
   *
   * @type  a -> a
   */
  debug = 
    where(<printnl> (stderr, [<id>]))

  /**
   * Prints the term produced by applying msg followed by the current term to stderr.
   *
   * @type  a -> a
   */
  debug(msg) = 
    where(<printnl> (stderr, [<msg>,<id>]))

strategies
    
  debug-depth = 
    debug-depth(!4, !"")

  debug-depth(depth) = 
    debug-depth(depth, !"")
    
  debug-depth(depth, s) = 
    where(  
      at-depth(depth, !"...")
    ; debug(s)
    )
    
strategies

  /**
   * Prints the term produced by applying msg to stderr.
   *
   * @param  term to print to stderr
   * @type   a -> a
   */
  say(msg) = 
    where(msg; debug)

  trace(msg,s) =
    debug(msg); (s; debug(!"succeeded: ") <+ debug(!"failed: "))

  /**
   * Prints a list of terms to stderr using printnl.
   *
   * @type List(a) -> List(a)
   */
  error = 
    where(<printnl> (stderr, <id>))

  /**
   * Prints a list of terms to stderr using printnl and exits with code 1.
   *
   * @type List(a) -> List(a)
   */
  fatal-error = 
    where(error; <exit> 1)

  /**
   * Prints giving-up to stderr and exits with code 1.
   *
   * @type _ -> _
   */
  giving-up = 
    <fatal-error>["giving-up"]

  obsolete(msg) = 
    log(|Warning(), <conc-strings> ("program uses obsolete strategy ", <msg> ()))

  dissuader(msg) = 
    where(if-verbose2(msg; debug(!"dissuasive library strategy: ")))

  Assert(s, msg) = 
    test(s) <+ debug(msg)

  risky(msg, s) = 
    restore(s, debug(msg))

/**
 * Print to the stdout. You usually don't want this.
 */
strategies

  echo = 
    where(<printnl> (stdout, <is-list <+ ![<id>]>))

  echo(msg) = 
    where(<printnl> (stdout, [<msg>,<id>]))

  printchar = 
    where(<printascii> (stdout, [<id>]))

  printstring = 
    where(<print> (stdout, [<id>]))

  /**
   * @obsolete use echo
   */
  debug-stdout(msg) = 
    obsolete(!"debug-stdout; use echo");
    echo(msg)

strategies

 /**
  * The operator stdio implements a simple user-interface
  * for transformers. A term is read from standard input,
  * transformed with parameter strategy s and then written
  * to standard output. If the transformation failed the text
  * 'rewriting failed' is written to standard error.
  * 
  * Prefer io-wrap in the module options.
  */ 
  stdio(s) =
      <ReadFromFile> stdin()
    ; s
    ; <WriteToTextFile> (stdout(), <id>)
    <+ <fatal-error> ["** rewriting failed"]

strategies

 /** 
  * This variant of the strategy stdio(s) provides a pair of the command-line
  * options and the input file to the strategy.
  */
  stdioO(s) =
    <s> (<id>, <ReadFromFile> stdin())
    ; <WriteToTextFile> (stdout(), <id>)
    <+ <fatal-error> ["** rewriting failed"]
