/**
 * Handling command line options.
 */
module util/config/options
imports 
  // system.io.*
  system/io/file 
  system/io/dir 
  system/io/pipe 
  system/io/char 
  system/io/term 
  system/io/exec

  util/config/parse-options 
  util/config/common 
  util/config/verbose 
  util/config/keep
  util/time 

strategies

  /**
   * Wraps a strategy into a strategy handling options and io of terms.
   *
   * @param  strategy to apply on the input term
   */
  io-wrap(s) = 
    io-wrap(fail, s)

  /**
   * Wraps a strategy into a strategy handling options and io of terms.
   *
   * @param   extra options besides the default io-options
   *          use fail if you have no additional options.
   * @param   strategy to apply on the input term
   */
  io-wrap(extra-opts, s) =
    io-wrap(extra-opts, system-usage, system-about, s)

  /**
   *
   * @param   extra options besides the default io-options.
   *          use fail if you have no additional options.
   *
   * @param   strategy to apply on the input term
   */
  io-wrap(extra-opts, usage, about, s) =
    option-wrap(extra-opts <+ io-options,  usage, about, id, io(s))

  output-wrap(s) =
    output-wrap(fail, s)

  output-wrap(extra-opts, s) =
    option-wrap(extra-opts <+ output-options,  output(s))

  input-wrap(s) =
    input-wrap(fail, s)

  input-wrap(extra-opts, s) =
    option-wrap(extra-opts <+ input-options,  input(s))

strategies

  /**
   * Wraps a strategy into a strategy that handles io options.
   *
   * Reads a term from the file specified by the -i option (or stdin).
   * Writes to a file specified by the -o option (or stdout).
   *
   * @param   strategy to apply on the input term
   */
  io(s) =
    input(output(s))

 /**
  * Wraps a strategy into a strategy that handles output options.
  *
  * Writes to a file specified by the -o option (or stdout).
  */ 
  output(s) =
      s
    ; !(<<get-config> "-o" <+ !stdout()>, <id>)
    ; ( where(<get-config> "-b") < WriteToBinaryFile + WriteToTextFile )

 /**
  * Wraps a strategy into a strategy that handles input options.
  *
  * Reads a term from the file specified by the -i option (or stdin).
  */ 
  input(s) =
      ( <get-config> "-i" <+ !stdin() )
    ; ReadFromFile
    ; s

strategies

  option-wrap(opts, s) =
    option-wrap(opts, system-usage, id, s)

  option-wrap(opts, usage, announce, s) =
    option-wrap(opts, usage, system-about, announce, s)

  /**
   * Read options, display help, report success or failure, call strategy
   */
  option-wrap(opts, usage, about, announce, s) =
    parse-options(opts, usage, about)
    ; store-options
    ; announce
    ; (s; report-success <+ report-failure)

strategies

  /**
   * Handles all common options for a transformation tool.
   */
  io-options =
      input-option
    + aterm-output-option
    + general-options

  input-options =
      input-option
    + general-options

  output-options =
      aterm-output-option
    + general-options

  general-options =
      verbose-option
    + keep-option

  /**
   * Option specifcation for level of keeping intermediate results.
   */
  keep-option =
    ArgOption("-k" + "--keep"
    , where(<set-config> ("--keep", <string-to-int>))
    , !"--keep i | -k i  Keep intermediates (default 0)"
    )

  /**
   * @obsolete --version is a standard option
   */
  version-option =
      obsolete(!"version-option/0: is a standard option")
    ; fail

  /**
   * Option specifications for reading input.
   *
   * Defines -i.
   */
  input-option =
    ArgOption("-i" + "--input"
    , where(<set-config> ("-i",<id>)); !Input(<id>)
    , !"-i f|--input f   Read input from f"
    )

  /**
   * Option specifications for writing output.
   *
   * Defines -o.
   */
  output-option =
    ArgOption("-o" + "--output"
    , where(<set-config> ("-o",<id>)); !Output(<id>)
    , !"-o f|--output f  Write output to f" 
    )

  /**
   * Option specifications for ATerm output.
   *
   * Defines -b option for binary output.
   */
  aterm-output-option =
      output-option
    + Option("-b"
      , where(<set-config> ("-b",())); !Binary()
      , !"-b               Write binary output"
      )

  /**
   * Option specifications for verbosity.
   *
   * Defines -S, --silent, --verbose and -s.
   */
  verbose-option =
      Option("-S"+"--silent"
      , where(<set-config> ("--verbose",0)); !Verbose(0)
      , !"-S|--silent      Silent execution (same as --verbose 0)"
      )
    + ArgOption("--verbose"
      , where(<set-config> ("--verbose",<string-to-int>)); !Verbose(<id>)
      , !"--verbose i      Verbosity level i (default 1)"
      )

strategies

  need-help(u) =
    (  <get-config> "--help"
      <+ option-defined(
           Help()
         + Undefined(id)
         + Version()
         )
    ); u

  need-help =
    need-help(default-usage)

  if-not-silent(s) =
    test(verbosity => 0) <+ s

  report-success =
      report-run-time
    ; <exit> 0

  report-failure =
      report-run-time
    ; <printnl> (stderr, [<whoami> (), ": rewriting failed"])
    ; <exit> 1

  /**
   * Outputs the name of the program and the run time in seconds to
   * stderr.
   */
  report-run-time = 
    if-verbose1(
      <printnl> (stderr,
        [<whoami> (), " (", <run-time>, " secs)"]
      )
    )

  whoami =
    <get-config> "program"

/**
* @obsolete new option handling uses config table.
*/ 
signature

  constructors
    Silent      : Option
    Verbose     : Int -> Option
    Version     : Option
    Input       : String -> Option
    Output      : String -> Option
    Binary      : Option
    Help        : Option
    Runtime     : Real   -> Option
    DeclVersion : String -> Option

strategies

  /**
   * Handles options, reads term from input file, transform, write result 
   * to output file
   *
   * @obsolete use io-wrap.
   */
  iowrap(strat) = 
    obsolete(!"iowrap/1: use io-wrap/1")
  ; iowrap((id, strat), fail)

  /**
   * @obsolete use io-wrap.
   */
  iowrapO(strat, extra-options) =
    obsolete(!"iowrapO/2: use io-wrap/2")
  ; iowrap(strat, extra-options)

  /**
   * @obsolete use io-wrap.
   */
  iowrap(strat, extra-options) = 
    obsolete(!"iowrapO/2: use io-wrap/2")
  ; iowrap(strat, extra-options, system-usage)

  /**
   * @obsolete use io-wrap.
   */
  iowrap(strat, extra-options, usage) =
    obsolete(!"iowrap/4: use io-wrap/4")
  ; iowrap(strat, extra-options, usage, 
	   if-verbose2(where(<printnl>(stderr, [<get-config> "program"]))))

  /**
   * @obsolete use io-wrap.
   */
  iowrapO(strat, extra-options, usage) =
    obsolete(!"iowrap/3: use io-wrap/4")
  ; iowrap(strat, extra-options, usage)

  /**
   * @obsolete use io-wrap.
   */
  iowrap(strat, extra-options, usage, announce) =
    obsolete(!"iowrap: use io-wrap")
  ; option-wrap(extra-options <+ io-options, usage, announce, 
      input-file;
      apply-strategy(strat);
      output-file
    )

  /**
   * @obsolete use input-wrap.
   */
  iowrapNoOutput(strat, extra-options) = 
    obsolete(!"iowrapNoOutput/2: use input-wrap")
  ; iowrapNoOutput(strat, extra-options, default-usage)

  /**
   * @obsolete use input-wrap.
   */
  iowrapNoOutput(strat, extra-options, usage) =
    obsolete(!"iowrapNoOutput/3: use input-wrap")
  ; option-wrap(extra-options <+ io-options, usage, id, 
        input-file
      ; apply-strategy(strat)
      )

  /**
   * @obsolete  use io-wrap
   */
  default-usage =
    obsolete(!"options:default-usage/(0,0): use io-wrap.")
    ; where(
      <printnl> (stderr, 
        ["usage : ", <whoami> (), " [-S] [-i file] [-o file] [-b] [-s] [--help|-h|-?]" ]
      )
    ; <exit> 1
    )

strategies

  /**
   * @obsolete use config for this purpose.
   */
  store-options = ?options;
    where( 
      <table-create>"option-table";
      <table-put>("option-table", "options", options)
    )

  /**
   * @obsolete use config for this purpose.
   */
  get-options =
    <table-get>("option-table", "options")

  /**
   * @obsolete use config for this purpose.
   */
  has-option(s) =
    test(<s; check-option>())

  /**
   * @obsolete use config for this purpose.
   */
  option-value(s,default) =
    get-options; fetch-elem(s) <+ default

  /**
   * @obsolete use config for this purpose.
   */
  check-option: option -> ()
    where get-options => ops
        ; <is-subterm>(option,ops)

  /**
   * @obsolete use default-usage.
   */
  usage' = 
    obsolete(!"usage': use default-usage")

strategies

  /**
   * @obsolete use input(s).
   */
  input-file' =
    obsolete(!"input-file'; use input-file");
    input-file

  /**
   * @obsolete use input(s).
   */
  input-file =
    obsolete(!"input-file; use input(s)");
    where((option-defined(?Input(infile)) <+ !stdin => infile));
    split(id, <ReadFromFile> infile)

  /**
   * @obsolete use profile(s).
   */
  apply-strategy(strat) =
    obsolete(!"input-file'; use input-file");
    where(dtime);
    strat;
    where(dtime => runtime);
    \(options, trm) -> ([Runtime(runtime) | options], trm)\

  /**
   * @obsolete use output(s).
   */
  output-file' =
    obsolete(!"output-file'; use output-file");
    output-file

  /**
   * @obsolete use output(s).
   */
  output-file =
    obsolete(!"output-file; use output(s)");
    where((option-defined(?Output(outfile)) <+ !stdout => outfile, id)); 
    (id, split(!outfile, id));
    ((option-defined(?Binary()), WriteToBinaryFile)
    <+ (id, WriteToTextFile))
