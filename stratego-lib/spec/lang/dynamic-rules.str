/**
 * A revised version of the pre-0.9.5 dynamic-rules-tools
 * Now using the new hash-tables, and implementing scoping
 * as a 'stack' of hashtables.
 *
 * @todo reuse ChangeSets when applying the fix point operator
 * @todo provide constructs to handle do-while-like structures
 *       issues: - a break inside the do-while
 *               - propagation in the first run could be wrong
 */
module lang/dynamic-rules

imports
  collection/hash-table/common
  strategy/traversal/simple
  collection/set/indexed
  system/posix/file
signature
  constructors
    RuleScope : IndexedSet * Hashtable -> RuleScope
    ChangeSet : IndexedSet * IndexedSet * Hashtable * String -> RuleScope
    Fix       : String * String -> Fix
    BreakCS   : String * String -> BreakCS
    Label     : Label

/**
 * Currently active rule set
 */
strategies

  /**
   * @type  _ -> List(RuleScope)
   */
  dr-get-rule-set(|name) =
    <table-get> ("_rules", name)
    <+ dr-new-rule-set
       ; dr-set-rule-set(|name)

  dr-set-rule-set(|name) =
    where(<table-put> ("_rules", name, <id>))

  dr-switch-rule-set(|name) =
    where(dr-get-rule-set(|name) => rs)
    ; dr-set-rule-set(|name)
    ; !rs

  // Note: the storing the currently active rule set should
  // be done in a global variable at the C level (probably).
  // We should abstract from that as much as possible and
  // just consider the rule-set as a value that can be
  // changed. Manipulating the content should be the same
  // for any storage solution we use.

  // a question to consider: should operations be relative
  // to the current rule-set or should we make a set of
  // operations that work on a named rule-set and deal
  // with the pointer change at a higer-level?

  // Well, we can actually have two APIs, one working on
  // the implicit global rule-set, and the other working
  // on the explicit representation.

  // whose responsibility is it to initialize the outer scope?
  // In the definition above an initial hashtable is created
  // when no rule-set was available yet.

strategies // high-level API with implicit rule set

  // Note that the compiler can generate a specifically named
  // rule for each of the strategies in this API, e.g,
  // add-rule-name, lookup-rule-name, etc. Then the compiler
  // can specialize the applications.

  dr-scope(s | name) =
    dr-begin-scope(|name)
    ; (s < dr-end-scope(|name)
         + dr-end-scope(|name); fail)

  /**
   * @type  t -> t
   */
  dr-begin-scope(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-add-scope
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-end-scope(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-leave-scope
      ; dr-set-rule-set(|name)
    )

  dr-scopes(s | names) =
    dr-begin-scopes(|names)
    ; (s < dr-end-scopes(|names)
         + dr-end-scopes(|names); fail)

  /**
   * @type  t -> t
   */
  dr-begin-scopes(|names) =
    where(
      !names
      ; map({?name
             ; dr-get-rule-set(|name)
             ; dr-add-scope
             ; dr-set-rule-set(|name)})
    )

  /**
   * @type  t -> t
   */
  dr-end-scopes(|names) =
    where(
      !names
      ; map({?name
             ; dr-get-rule-set(|name)
             ; dr-leave-scope
             ; dr-set-rule-set(|name)})
    )

  /**
   * @type  t -> t
   */
  dr-start-change-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-start-change-set
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-commit-change-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-commit-change-set
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-discard-change-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-discard-change-set
      ; dr-set-rule-set(|name)
    )

  /**
   * @type  t -> t
   */
  dr-label-scope(|name, label) =
    where(
      dr-get-rule-set(|name)
      ; dr-label-scope(|label)
      ; dr-set-rule-set(|name)
    )

   /**
    * Get all scope labels ordered from inner, most recent, to outer, oldest.
    */

  dr-get-scope-labels(|name) =
    dr-get-rule-set(|name)
    ; dr-get-scope-labels

   /**
    * Get the first scope label for which s succeeds starting with the
    * inner, most recent, scope.
    */

  dr-get-first-scope-label(s|name) =
    dr-get-rule-set(|name)
    ; dr-get-first-scope-label(s)

strategies

  /**
   * Apply s in a state where the current dynamic rules for name are ignored.
   *
   * @param strategy to apply (a -> b)
   * @param name of the dynamic rules (String)
   * @type a -> b
   */
  dr-ignore-state(s|name) =
    where(
      dr-new-rule-set
      ; dr-switch-rule-set(|name) => rs
    )
  ; s
  ; where(<dr-set-rule-set(|name)> rs)

  /**
   * Apply s in a state where the current dynamic rules for names are ignored.
   *
   * @param strategy to apply (a -> b)
   * @param names of the dynamic rules (List(String))
   * @type a -> b
   */
  dr-ignore-states(s|names) =
    where(
       <map(dr-new-rule-set)> names
       ; zip(dr-switch-rule-set | names) => rss
    )
    ; s
    ; where(<zip(dr-set-rule-set | names)> rss)

strategies

  dr-lookup-rule(|name, key) =
    dr-get-rule-set(|name)
    ; dr-lookup-rule(|key)

  dr-lookup-all-rules(|name, key) =
    dr-get-rule-set(|name)
    ; dr-lookup-all-rules(|key)

  dr-lookup-rule-pointer(|name, key) =
    dr-get-rule-set(|name)
    ; dr-lookup-rule-pointer(|key)

  dr-set-rule(|name, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|key, [value])
      ; dr-set-rule-set(|name)
    )

  dr-set-rule(|name, label, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|label, key, [value])
      ; dr-set-rule-set(|name)
    )

  dr-set-rule-vis(|name, label, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set-vis(|label, key, [value])
      ; dr-set-rule-set(|name)
    )

  dr-set-rules-vis(|name, label, key, values) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set-vis(|label, key, values)
      ; dr-set-rule-set(|name)
    )

  dr-undefine-rule(|name, key) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|key, [])
      ; dr-set-rule-set(|name)
    )

  dr-undefine-rule(|name, label, key) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set(|label, key, [])
      ; dr-set-rule-set(|name)
    )

  dr-undefine-rule-vis(|name, label, key) =
    where(
      dr-get-rule-set(|name)
      ; dr-set-in-rule-set-vis(|label, key, [])
      ; dr-set-rule-set(|name)
    )

  dr-add-rule(|name, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-add-to-rule-set(|key, value)
      ; dr-set-rule-set(|name)
    )

  dr-add-rule(|name, label, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-add-to-rule-set(|label, key, value)
      ; dr-set-rule-set(|name)
    )

  dr-add-rule-vis(|name, label, key, value) =
    where(
      dr-get-rule-set(|name)
      ; dr-add-to-rule-set-vis(|label, key, value)
      ; dr-set-rule-set(|name)
    )

  /**
   * Intersect live rule-set with given rule set changing the live rule set.
   */

  dr-intersect-with(|name) =
    <dr-intersect-rule-sets>(<dr-get-rule-set(|name)>, <id>)
    ; dr-set-rule-set(|name)

  /**
   * Intersect live rule-set with given rule set changing both.
   */

  dr-intersect-symm(|name) =
    <dr-intersect-rule-sets-symm>(<dr-get-rule-set(|name)>, <id>)
    ; dr-set-rule-set(|name)

  /**
   * Merge live rule-set with given rule set using union changing the live rule set.
   */

  dr-union-with(|name) =
    <dr-union-rule-sets>(<dr-get-rule-set(|name)>, <id>)
    ; dr-set-rule-set(|name)

  /**
   * Merge live rule-set with give rule set using union changing both.
   */

  dr-union-symm(|name) =
    <dr-union-rule-sets-symm>(<id>, <dr-get-rule-set(|name)>)
    ; dr-set-rule-set(|name)


  /**
   * Left choice with dynamic rule roll-back in case s1 fails.
   */

  dr-left-choice(s1,s2|rulenames) =
    where(<map(dr-start-change-set(|<id>))> rulenames)
    ; s1
    < where(<map(dr-commit-change-set(|<id>))> rulenames)
    + where(<map(dr-discard-change-set(|<id>))> rulenames)
      ; s2

/**
 * Low-level API working directly on rule-set.
 */

strategies // debugging

  dr-save-rule-set =
    alltd(hashtable-getlist)

strategies // scope

  // a rule-set is represented by a list of (label list, hash-table) pairs

  dr-new-scope =
    !RuleScope(<new-iset; iset-add(|())>, <new-hashtable>)

  dr-new-rule-set =
    ![<dr-new-scope>]

  dr-add-scope =
    ![<dr-new-scope> | <id>]

  dr-destroy-scope =
    RuleScope(iset-destroy, hashtable-destroy)

  dr-leave-scope :
    [scope | scopes] -> scopes
    where <dr-destroy-scope> scope

  dr-get-inner-scope :
    [scope | scopes] -> scope

  dr-label-scope(|label) =
    [ RuleScope(iset-add(|label), id)
      + ChangeSet(iset-add(|label), id, id, id)
    | id]
    // todo: distinction between rulescope and changeset necessary here or not??
//    [RuleScope(labels, tbl) | scopes] -> [RuleScope([label | labels], tbl) | scopes]

   dr-get-scope-labels =
     mapconcat(?RuleScope(<iset-elements>,_) + ?ChangeSet(<iset-elements>,_,_,_))

   /**
    * Get the first scope label for which s succeeds.
    */

   dr-get-first-scope-label(s) =
     fetch-elem(?RuleScope(<iset-elements; fetch-elem(s)>,_)
                + ?ChangeSet(<iset-elements; fetch-elem(s)>,_,_,_))

strategies // change sets

  dr-new-change-set =
    !ChangeSet(<new-iset>, <new-iset>, <new-hashtable>, "")

  dr-start-change-set =
    ![<dr-new-change-set> | <id>]

  dr-destroy-change-set =
    ChangeSet(iset-destroy, iset-destroy, hashtable-destroy, id)

  dr-commit-change-set =
    dr-commit-change-set(id)

  /**
   * The strategy destroy indicates whether the change
   * set should also be destroyed after the commmit.
   */
  dr-commit-change-set(destroy) :
    [cs@ChangeSet(labelset, rmset, tbl, slabel) | rs] -> rs'''
    where <hashtable-keys> tbl
        ; foldr(<dr-commit-labels(|labelset)> rs
               , dr-apply-change(|tbl)) => rs'
        ; <iset-elements> rmset
        ; foldr(!rs', dr-apply-removal)
        ; where(try(destroy; <dr-destroy-change-set> cs))
        ; if <eq>(slabel, "ignore")
          then (fetch(ChangeSet(id, id, id, !"ignore"))
                <+ fatal-err(|"dr-break was called outside of a fix and merge operator or a dr-label call"))
          else id
          end => rs'''

  dr-discard-change-set :
    [cs@ChangeSet(_,_,_,_) | rs] -> rs
    where <dr-destroy-change-set> cs

  dr-commit-labels(|labelset) =
    [ ChangeSet(iset-union(|labelset), id, id, id)
      + RuleScope(iset-union(|labelset), id)
    | id]

  /**
   * commit to ruleset is finding the first ChangeSet (any) *or* the first
   * RuleScope that has the appropriate scopeid (i.e. hashtable pointer)
   * and setting the key-value into it
   */

  dr-apply-change(|tbl) :
    (key1@(scpid, key), rs) -> <dr-commit-to-rule-set(|scpid, key, <hashtable-get(|key1)> tbl)> rs


  dr-commit-to-rule-set(|scpid, key, value) =
    dr-commit-to-change-set(|scpid, key, value)
    <+ dr-commit-to-rule-scope(|scpid, key, value)

  dr-commit-to-change-set(|scpid, key, value) =
    ?[ChangeSet(_, rmset, tbl, _) | rs]
    ; where(
        (<dr-lookup-rule-in-scope(|key, scpid)>rs => value
         < <hashtable-remove(|(scpid, key))>tbl
         + <hashtable-put(|(scpid, key), value)>tbl)
        ; <iset-remove(|(scpid, key))>rmset
      )

  dr-commit-to-rule-scope(|scpid, key, value) =
    ?[RuleScope(_, tbl@Hashtable(scpid)) | rs]
    ; where(<hashtable-put(|key, value)>tbl)
    <+ [RuleScope(id, id) | dr-commit-to-rule-set(|scpid, key, value) ]

/*
 * the old implementation (for reference)
 *

  dr-commit-to-rule-set(|scpid, key, value) =
    fetch(
      dr-commit-to-change-set(|scpid, key, value)
    + dr-commit-to-rule-scope(|scpid, key, value))

  dr-commit-to-change-set(|scpid, key, value) =
    ?ChangeSet(_, _, tbl, _)
    ; where(<hashtable-put(|(scpid, key), value)> tbl)

  dr-commit-to-rule-scope(|scpid, key, value) =
    ?RuleScope(_,tbl@Hashtable(scpid))
    ; where(<hashtable-put(|key, value)> tbl)
*/

  dr-apply-removal :
    (key1@(scpid, key), rs) -> <dr-remove-from-rule-set(|scpid, key)> rs

  dr-remove-from-rule-set(|scpid, key) =
    fetch(
      dr-remove-from-change-set(|scpid, key)
    + dr-remove-from-rule-scope(|scpid, key))

  dr-remove-from-change-set(|scpid, key) =
    ChangeSet(id, iset-add(|(scpid, key)), ?tbl, id)
  ; where(<hashtable-remove(|(scpid, key))> tbl)

  dr-remove-from-rule-scope(|scpid, key) =
    ?RuleScope(_,tbl@Hashtable(scpid))
  ; where(<hashtable-remove(|key)> tbl)

strategies // looking up

  /**
   * Fetch the most recent definition for key.
   */

  // The "removed" parameter is now a list, which allows duplicates
  // to be added. This is not wrong, but it is marginally inefficient.
  // We actually need set-like behavior. Indexed sets, however, are
  // not an option because of the check of whether or not "removed"
  // contains key' in function look2. Since look2 is called later on,
  // when a RuleScope is reached, "removed" will potentially contain
  // some extra elements which should not be considered. This is the
  // case because of the in-place update of indexed sets.

  dr-lookup-rule(|key) =
    dr-lookup-rule(fail | key, [])

  dr-lookup-rule(look | key, removed) =
    ?[RuleScope(_, tbl@Hashtable(hptr)) | rs]
    ; (<look>(hptr, key)
       <+ <not(fetch(?(hptr, key)))> removed
          ; <hashtable-get(|key)> tbl
       <+ <dr-lookup-rule(look | key, removed)> rs)

  dr-lookup-rule(look1 | key, removed) =
    ?[ChangeSet(_, rmset, tbl, _) | rs]
    ; let look2 = look1
                  <+ {key':
                      ?key'
                      ; <not(fetch(?key'))> removed
                      ; <hashtable-get(|key')> tbl
                     }
       in
         <iset-elements> rmset
         ; filter(?(_, key)) => keys
         ; <dr-lookup-rule(look2 | key, <conc>(keys, removed))> rs
      end

  /**
   * Version of dr-lookup-rule that looks for definition of a key
   * in a particular scope. The expected scope id (scpid) is the
   * pointer to the hashtable of a rule scope and is usually
   * identified by means of a label, i.e., a label indicates the
   * rule scope and the rule scope has a unique scope id.
   */

  dr-lookup-rule-in-scope(|key, scpid) =
    dr-lookup-rule-in-scope-rs(|key, scpid)
    <+ dr-lookup-rule-in-scope-cs(|key, scpid)

  dr-lookup-rule-in-scope-rs(|key, scpid) =
    ?[RuleScope(_, tbl@Hashtable(scpid)) | rs]      // if this is the right scope,
    < <hashtable-get(|key)>tbl                      // then check for key
    + (?[RuleScope(_, _) | rs]                      // else recurse
       ; <dr-lookup-rule-in-scope(|key, scpid)>rs)

  dr-lookup-rule-in-scope-cs(|key, scpid) =
    ?[ChangeSet(_, rmset, tbl, _) | rs]
    ; (<iset-contains(|(scpid, key))>rmset
       < fail                                // key is marked for removal, so
                                             // in effect it is not defined
       + (<hashtable-get(|(scpid, key))>tbl
          <+ <dr-lookup-rule-in-scope(|key, scpid)>rs))

  /**
   * Fetch the most recent definition for key and return a pointer
   * to the table that defines it.
   */

  dr-lookup-rule-pointer(|key) =
    dr-lookup-rule-pointer(fail | key, [])

  dr-lookup-rule-pointer(look | key, removed) =
    ?[RuleScope(_, tbl@Hashtable(hptr)) | rs]
    ; (<look>(hptr, key)
       <+ <not(fetch(?(hptr, key)))> removed
          ; <hashtable-get(|key)> tbl
          ; !(<id>, key, tbl)
       <+ <dr-lookup-rule-pointer(look | key, removed)> rs)

  dr-lookup-rule-pointer(look1 | key, removed) =
    ?[ChangeSet(_, rmset, tbl, _) | rs]
    ; let look2 = look1
                  <+ {key':
                      ?key'
                      ; <not(fetch(?key'))> removed
                      ; <hashtable-get(|key'); !(<id>, key', tbl)> tbl
                     }
       in
         <iset-elements> rmset
         ; filter(?(_, key)) => keys
         ; <dr-lookup-rule-pointer(look2 | key, <conc>(keys, removed))> rs
      end

  /**
   * Fetch all definitions for key.
   */

  dr-lookup-all-rules(|key) =
    dr-lookup-all-rules(fail | key, [])

  dr-lookup-all-rules(look | key, removed) =
    ?[RuleScope(_, tbl@Hashtable(hptr)) | rs]
    ; <conc>(<<look>(hptr, key)
              <+ <not(fetch(?(hptr, key)))> removed
                 ; <hashtable-get(|key)> tbl
              <+ ![]>
            ,<dr-lookup-all-rules(look | key, removed) <+ ![]> rs)

  dr-lookup-all-rules(look1 | key, removed) =
    ?[ChangeSet(_, rmset, tbl, _) | rs]
    ; let look2 = look1
                  <+ {key':
                      ?key'
                      ; <not(fetch(?key'))> removed
                      ; <hashtable-get(|key')> tbl
                     }
       in
         <iset-elements> rmset
         ; filter(?(_, key)) => keys
         ; <dr-lookup-all-rules(look2 | key, <conc>(keys, removed))> rs
      end

strategies // setting a rule

  // A rule is always stored as a mapping from key to a list of values.
  // Setting a rule entails removing previous rules.

  /**
   * set a rule in the inner scope
   *
   * The inner scope has label () since all scopes are labeled
   * this way.
   */

  dr-set-in-rule-set(|key, value) =
    dr-set-in-rule-set(|(), key, value)

  /**
   * set a rule in the scope with specified label
   */

  dr-set-in-rule-set(|label, key, value) =
    dr-set-in-rule-set(dr-set-fail | label, key, value)

  dr-set-fail(|scpid, tbl, key, value) =
    fail

  dr-set-in-rule-set(set : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm
           | label, key, value) =
    ?[RuleScope(labelset, tbl@Hashtable(hptr)) | rs]
    ; where(
        <iset-contains(|label)> labelset
        < (set(|hptr, tbl, key, value)
           <+ where(<hashtable-put(|key, value)> tbl))
        + <dr-set-in-rule-set(set | label, key, value)> rs
      )

  dr-set-in-rule-set(set1 : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm
           | label, key, value) =
    ?[ChangeSet(labelset, rmset, tbl1, _) | rs]
    ; where(
        let set2(|scpid, tbl2, key, value) =
              set1(|scpid, tbl2, key, value)
              <+ <dr-lookup-rule-in-scope(|key, scpid)> rs => value
                 ; <hashtable-remove(|(scpid, key))> tbl1
                 ; <iset-remove(|(scpid, key))> rmset
              <+ <hashtable-put(|(scpid, key), value)> tbl1
                 ; <iset-remove(|(scpid, key))> rmset
         in if <iset-contains(|label)> labelset
            then <fetch-elem(?RuleScope(_,tbl@Hashtable(hptr)))> rs
                 ; set2(|hptr, tbl, key, value)
            else <dr-set-in-rule-set(set2 | label, key, value)> rs
            end
        end
      )


    // what to do if no scope with the label is defined?
    // currently this fails. This might default to adding to
    // the inner scope and labeling that inner scope as
    // well. However, that is quite expensive since
    // it would entail first going through all scopes to
    // establish non-existence of a label.


  /**
   * Add a rule to the rule-set with the specified label and make sure
   * it is visible by deleting any rules with the same key in scopes
   * upto the specified scope. Deleting by removing from the table, not
   * undefining.
   */

  dr-set-in-rule-set-vis(|key, value) =
    dr-set-in-rule-set(|key, value)

  dr-set-in-rule-set-vis(|label, key, value) =
    dr-set-in-rule-set-vis(dr-set-fail, dr-rm-fail | label, key, value)

  dr-rm-fail(|scpid, tbl, key) =
    fail

  dr-set-in-rule-set-vis(
      set : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm,
      rm  : ATerm * Hashtable * ATerm * ATerm         -> ATerm
      | label, key, value)
  = ?[RuleScope(labelset, tbl@Hashtable(hptr)) | rs]
    ; where(
        if <iset-contains(|label)> labelset then
          set(|hptr, tbl, key, value)
          <+ <hashtable-put(|key, value)> tbl
        else
          (rm(|hptr, tbl, key) <+ <hashtable-remove(|key)> tbl)
          ; <dr-set-in-rule-set-vis(set, rm | label, key, value)> rs
        end
      )

  dr-set-in-rule-set-vis(
      set1 : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm,
      rm1  : ATerm * Hashtable * ATerm * ATerm         -> ATerm
      | label, key, value)
  = ?[ChangeSet(labelset, rmset, tbl1, _) | rs]
    ; where(
        let set2(|scpid, tbl2, key, value) =
              set1(|scpid, tbl2, key, value)
              <+ <dr-lookup-rule-in-scope(|key, scpid)> rs => value
                 ; <hashtable-remove(|(scpid, key))> tbl1
                 ; <iset-remove(|(scpid, key))> rmset
              <+ <hashtable-put(|(scpid, key), value)> tbl1
                 ; <iset-remove(|(scpid, key))> rmset

            rm2(|scpid, tbl2, key) =
              rm1(|scpid, tbl2, key)
              <+ if <dr-lookup-rule-in-scope(|key, scpid)> rs then
                   <hashtable-remove(|(scpid, key))> tbl1
                   ; <iset-add(|(scpid, key))> rmset
                 end

         in if <iset-contains(|label)> labelset then
              <fetch-elem(?RuleScope(_,tbl@Hashtable(hptr)))> rs
              ; set2(|hptr, tbl, key, value)
            else
              <dr-set-in-rule-set-vis(set2, rm2 | label, key, value)> rs
            end
        end
      )

strategies // extending a rule

  // Extending a rule entails adding a value to the list of values
  // corresponding to the key. The intended semantics is that all
  // these values are

  dr-add-to-rule-set(|key, value) =
    dr-add-to-rule-set(|(), key, value)

  /**
   * add a rule to the scope for label
   *
   * @assert: dr-add-to-rule-set(|l, k, v)
   *               = set-rule(|l, k, [v | <lookup-rule(|l, k, v) <+ ![]>])
   */
  dr-add-to-rule-set(|label, key, value) =
    dr-add-to-rule-set(dr-add-fail | label, key, value)

  dr-add-fail(|scpid, tbl, key, value) =
    fail

  dr-rm-fail(|scpid, tbl, key) =
    fail

  dr-add-to-rule-set(add : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm
             | label, key, value) =
    ?[RuleScope(labelset, tbl@Hashtable(hptr)) | rs]
    ; where(
        <iset-contains(|label)> labelset
        < (add(|hptr, tbl, key, value)
           <+ where(<hashtable-push(|key, value)> tbl))
        + <dr-add-to-rule-set(add | label, key, value)> rs
      )

  dr-add-to-rule-set(add1 : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm
             | label, key, value) =
    ?[ChangeSet(labelset, rmset, tbl1, _) | rs]
    ; where(
        let add2(|scpid, tbl2, key, value) =
              add1(|scpid, tbl2, key, value)
              <+ {values:  // this is when the hash table of the change
                           // set already contains a binding for the key
                  ![value | <hashtable-get(|(scpid, key))> tbl1] => values
                  ; if <dr-lookup-rule-in-scope(|key, scpid)> rs => values then
                      <hashtable-remove(|(scpid, key))> tbl1
                      ; <iset-remove(|(scpid, key))> rmset
                    else
                      <hashtable-put(|(scpid, key), values)> tbl1
                      ; <iset-remove(|(scpid, key))> rmset
                    end
                 }
                           // this is when the hash table of the change set
                           // already does not already contain a binding for the key
              <+ (<dr-lookup-rule-in-scope(|key, scpid)> rs <+ ![])
                 ; \ values -> <hashtable-put(|(scpid, key), [value | values])> tbl1 \

         in if <iset-contains(|label)> labelset then
               <fetch-elem(?RuleScope(_, tbl@Hashtable(hptr)))> rs
               ; add2(|hptr, tbl, key, value)
            else
               <dr-add-to-rule-set(add2 | label, key, value)> rs
            end
        end
      )

  /**
   * add a rule to the scope for label such that it is visible afterwards
   *
   * @assert: dr-add-to-rule-set(|l, k, v)
   *               = set-rule(|l, k, [v | <lookup-rule(|l, k, v) <+ ![]>])
   */
  dr-add-to-rule-set-vis(|label, key, value) =
    dr-add-to-rule-set-vis(dr-add-fail, dr-rm-fail | label, key, value)

  dr-add-to-rule-set-vis(
      add : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm,
      rm  : ATerm * Hashtable * ATerm * ATerm         -> ATerm
      | label, key, value)
  = ?[RuleScope(labelset, tbl@Hashtable(hptr)) | rs]
    ; where(
        if <iset-contains(|label)> labelset then
           add(|hptr, tbl, key, value)
           <+ <hashtable-push(|key, value)> tbl
        else
          (rm(|hptr, tbl, key) <+ <hashtable-remove(|key)> tbl)
          ; <dr-add-to-rule-set-vis(add, rm| label, key, value)> rs
        end
      )

  dr-add-to-rule-set-vis(
      add1 : ATerm * Hashtable * ATerm * ATerm * ATerm -> ATerm,
      rm1  : ATerm * Hashtable * ATerm * ATerm         -> ATerm
      | label, key, value)
  = ?[ChangeSet(labelset, rmset, tbl1, _) | rs]
    ; where(
        let add2(|scpid, tbl2, key, value) =
              add1(|scpid, tbl2, key, value)
              <+ {values:  // this is when the hash table of the change
                           // set already contains a binding for the key
                  ![value | <hashtable-get(|(scpid, key))> tbl1] => values
                  ; if <dr-lookup-rule-in-scope(|key, scpid)> rs => values then
                      <hashtable-remove(|(scpid, key))> tbl1
                      ; <iset-remove(|(scpid, key))> rmset
                    else
                      <hashtable-put(|(scpid, key), values)> tbl1
                      ; <iset-remove(|(scpid, key))> rmset
                    end
                 }
                           // this is when the hash table of the change set
                           // already does not already contain a binding for the key
              <+ (<dr-lookup-rule-in-scope(|key, scpid)> rs <+ ![])
                 ; \ values -> <hashtable-put(|(scpid, key), [value | values])> tbl1 \

            rm2(|scpid, tbl2, key) =
              rm1(|scpid, tbl2, key)
              <+ if <dr-lookup-rule-in-scope(|key, scpid)> rs then
                   <hashtable-remove(|(scpid, key))> tbl1
                   ; <iset-add(|(scpid, key))> rmset
                 end

         in if <iset-contains(|label)> labelset then
              <fetch-elem(?RuleScope(_, tbl@Hashtable(hptr)))> rs
              ; add2(|hptr, tbl, key, value)
            else
              <dr-add-to-rule-set-vis(add2, rm2 | label, key, value)> rs
            end
        end
      )

strategies // intersection and union of rule-sets

  /**
   * Merge two rule sets scope by scope.
   *
   * @merge-rs : operation to merge RuleScopes
   * @merge-cs : operation to merge ChangeSets
   */

  dr-merge-rule-sets(merge-rs, merge-cs) =
    rec x(
      eq < fail
      + (dr-merge-rule-sets1(merge-rs, x)
         <+ dr-merge-rule-sets2(merge-cs, x))
    )

  dr-merge-rule-sets1(merge-rs, merge-rec) :
    (rs1@[RuleScope(labels1, tbl1) | rs1a],
     rs2@[RuleScope(labels2, tbl2) | rs2a]) -> rs1
    where
      ior(<merge-rs> (rs1, tbl1, rs2, tbl2), <merge-rec> (rs1a, rs2a))

  dr-merge-rule-sets2(merge-cs, merge-rec) :
    (rs1@[cs1@ChangeSet(labels1, rmset1, tbl1, slabel1) | rs1a],
     rs2@[cs2@ChangeSet(labels2, rmset2, tbl2, slabel2) | rs2a]) -> [cs | rs1a]
    where
      // "ignore" & "ignore" have to be merged, with the "ignore" system label kept
      // "" & "" is the normal merge
//      debug(!"dr-merge-rule-sets2-1>")
//      ; <dr-print-rule-set-msg(|"merge cs 1")>[cs1]
//      ; <dr-print-rule-set-msg(|"merge cs 2")>[cs2]
      <eq>(slabel1, slabel2)
//      ; debug(!"dr-merge-rule-sets2-2>")
      ; ior(<merge-cs> (rs1, rmset1, tbl1, rs2, rmset2, tbl2), <merge-rec> (rs1a, rs2a))
//      ; debug(!"dr-merge-rule-sets2-3>")
      ; !cs1 => cs
//      ; debug(!"dr-merge-rule-sets2-4>")
      <+ // slabel1 = "ignore" & slabel2 != "ignore", so we ignore cs1
         <eq>(slabel1, "ignore")
//         ; debug(!"dr-merge-rule-sets2-5>")
         ; (<eq>(rs1a, rs2a)
            < // debug(!"dr-merge-rule-sets2-6>");
              !cs2 => cs
            + fatal-err(|"Merging of rulesets cannot continue because the non-ingnored change set is based on a different ruleset than the ignored change set."))
      <+ // slabel1 != "ignore" & slabel2 = "ignore", so we ignore cs2
         <eq>(slabel2, "ignore")
//         ; debug(!"dr-merge-rule-sets2-7>")
         ; !cs1 => cs
//         ; debug(!"dr-merge-rule-sets2-8>")

  /**
   * Intersection of two rule-sets
   *
   * assumption: the scope structure is the same
   * intersection works scope by scope
   * note that labels are ignored
   *
   * @todo: intersect labelsets as well!!??
   */

  dr-intersect-rule-sets =
    dr-merge-rule-sets(
        {?(rs1, tbl1, rs2, tbl2)
         ; <hashtable-intersect-wempty(|tbl2, [])> tbl1}
      , {?(rs1, rmset1, tbl1, rs2, rmset2, tbl2)
         ; <apply-rm-set(|rmset2)> tbl1
         ; <iset-union(|rmset2)> rmset1
         ; <hashtable-intersect-wempty(|tbl2, [])> tbl1}
    )

  apply-rm-set(|rmset) = ?tbl
    ; where(
        <iset-elements> rmset
        ; map({x: ?x; <hashtable-remove(|x)> tbl})
      )

  /**
   * Symmetric intersection of two rule-sets
   *
   * assumption: the scope structure is the same
   * intersection works scope by scope
   * note that labels are ignored
   *
   * @todo: intersect labelsets as well!!
   */

  dr-intersect-rule-sets-symm =
    dr-merge-rule-sets(
        {?(rs1, tbl1, rs2, tbl2)
         ; <hashtable-intersect-symm-wempty(|[])> (tbl1, tbl2)}
      , {?(rs1, rmset1, tbl1, rs2, rmset2, tbl2)
         ; <apply-rm-set(|rmset2)> tbl1
         ; <apply-rm-set(|rmset1)> tbl2
         ; <iset-union(|rmset2)> rmset1
         ; <iset-union(|rmset1)> rmset2
         ; <hashtable-intersect-symm-wempty-ignore-left(|[])> (tbl1, tbl2)}
    )

  /**
   * Union of two rule-sets
   *
   * assumption: the scope structure of the two rule-sets is the same
   * and union works scope by scope
   *
   */

  dr-union-rule-sets =
    dr-merge-rule-sets(
        {?(rs1, tbl1, rs2, tbl2)
         ; <hashtable-union(|tbl2)> tbl1}

      , {?(rs1, rmset1, tbl1, rs2, rmset2, tbl2)
         ; <apply-rm-set(|rmset2)> tbl1
         ; <iset-union(|rmset2)> rmset1
         ; <hashtable-merge(
               symmetric-no,
             iterate1-yes,
             iterate2-yes,
             remove-no,
             union,
             ![],
             \ (_,key) -> <dr-lookup-rule(|key)> rs1\,
             \ (_,key) -> <dr-lookup-rule(|key)> rs2\
           )> (tbl1, tbl2)}
    )

  dr-union-rule-sets-symm =
    dr-merge-rule-sets(
        {?(rs1, tbl1, rs2, tbl2)
         ; <hashtable-union-symm-wempty(|[])> (tbl1, tbl2)}

      , {?(rs1, rmset1, tbl1, rs2, rmset2, tbl2)
         ; <apply-rm-set(|rmset2)> tbl1
         ; <apply-rm-set(|rmset1)> tbl2
         ; <iset-union(|rmset2)> rmset1
         ; <iset-union(|rmset1)> rmset2
         ; <hashtable-union-symm-wempty(|[])> (tbl1, tbl2)}
    )

strategies // generic fork-and-merge strategies

  fork-rule-sets :
    rulename -> (rulename, rs)
    where dr-get-rule-set(|rulename)
        ; dr-start-change-set => rs
        ; dr-start-change-set(|rulename)

  merge-rule-sets(merge) =
    ?(rulename, <id>)
    ; try(<merge>(rulename, <id>))
    ; dr-commit-change-set(|rulename)

  /**
   * Fork and merge two rule-sets.
   *
   * @param merge :
   */

  dr-fork-and-merge(merge, s1, s2 | rulenames) =
    where(<map(fork-rule-sets)> rulenames => rs1)
    ; restore(s1, where(<map(dr-discard-change-set(|<id>))> rulenames))
    ; where(<map({(?rulename,dr-switch-rule-set(|rulename))})> rs1 => rs2)
    ; restore(s2, where(<map(dr-discard-change-set(|<id>))> rulenames))
    ; where(<map(merge-rule-sets(merge))> rs2)

  dr-fork-and-merge(merge1, merge2, s1, s2 | rulenames1, rulenames2) =
    where(
      <map(fork-rule-sets)> rulenames1 => rs1a;
      <map(fork-rule-sets)> rulenames2 => rs1b
    )
    ; restore(
        s1,
        where(
          <map(dr-discard-change-set(|<id>))> rulenames1;
          <map(dr-discard-change-set(|<id>))> rulenames2
        )
      )
    ; where(
        <map({(?rulename,dr-switch-rule-set(|rulename))})> rs1a => rs2a;
        <map({(?rulename,dr-switch-rule-set(|rulename))})> rs1b => rs2b
      )
    ; restore(
        s2,
        where(
          <map(dr-discard-change-set(|<id>))> rulenames1;
          <map(dr-discard-change-set(|<id>))> rulenames2
        )
      )
    ; where(
        <map(merge-rule-sets(merge1))> rs2a;
        <map(merge-rule-sets(merge2))> rs2b
      )

strategies // generic fix-point strategies

  /**
   * Iterate and merge two rule-sets.
   *
   * @param merge :
   */

  dr-fix-and-merge-no-break(merge, s | rulenames) =
    where(<map(fork-rule-sets)> rulenames => rs)
    ; repeat(
        where(
          restore(s, where(<map(dr-discard-change-set(|<id>))> rulenames))
          ; if <filter({?(rulename,<id>); <merge>(rulename, <id>)})> rs; []
            then
              ?e; fail // no changes in any of the rules
            else
              id       // some rule changed; continue
            end
        )
      )
    ; !e
    ; where(<map(dr-commit-change-set(|<id>))> rulenames)

  dr-fix-and-merge(merge, s | rulenames) =
//    dr-fix-and-merge-no-break(merge, s | rulenames)
    dr-fix-and-merge(merge, s | rulenames, "")

  dr-fix-and-merge(merge, s | rulenames, label) =
    {| DR_BREAK :

      // register <label> as the active label
      rules(DR_BREAK+label : Label -> label)

      // for each rule r in <rulenames> do
      //     define a dynamic rule based on r and <label> which marks
      //     the position of the change set for the fixed point
      //     operator labeled with <label> in the ruleset of r
      //     (these rules are used in dr-break)
      ; where(
          <map({rulename, pos :
                ?rulename
                ; dr-get-rule-set(|rulename)
                ; length => pos
                ; rules(DR_BREAK : Fix(rulename, label) -> pos)
              })>rulenames
        )

//      ; dr-print-rule-set(|"DR_BREAK")

      ; where(<map(fork-rule-sets)> rulenames => rs)
      ; repeat(
          where(
            restore(s, where(<map(dr-discard-change-set(|<id>))> rulenames))
            ; if <filter({?(rulename, ruleset)
//                          ; debug(!"dr-fix-and-merge-5>")
//                          ; dr-print-rule-set(|rulename)
                          // getting a change sets marked with "ignore" here means
                          // that the loop _always_ ends with a break, so we might
                          // as well not have had a loop at all, since it will only
                          // be executed once
                          ; (dr-get-rule-set(|rulename) => [ChangeSet(labels, rmset, tbl, "ignore") | _]
                             < <iset-clear>labels
                               ; <iset-clear>rmset
                               ; <hashtable-clear>tbl
//                               ; debug(!"dr-fix-and-merge-6>")
                               ; fail
                             + //debug(!"dr-fix-and-merge-7>");
                               <merge>(rulename, ruleset))
                        })> rs; []
              then
//                debug(!"dr-fix-and-merge-8>");
                ?e; fail // no changes in any of the rule sets
              else
                // when <bagof-DR_BREAK>BreakCS(rulename, label) is called further
                // below in this strategy, we need to be able to extract the
                // elements in the list returned by bagof which were defined during
                // the first run (from above) of the strategy s and the ones in the
                // last run. For this, we need to make sure there will be some
                // separators in that list which we can use to get what we need.
                // The separator will be (), and here is the point where we add it
                where(<map(rules(DR_BREAK :+ BreakCS(<id>, label) -> ()))>rulenames)
//                ; debug(!"dr-fix-and-merge-9>")
                ; id       // some rule changed; continue
              end
          )
        )

//      ; dr-print-rule-set(|"DR_BREAK")

      // for each rule r in <rulenames> do
      //     we want to intersect the current ruleset for rule r with some of the rulesets
      //     returned by bagof-DR_BREAK for r and the current <label>. We only want to use those
      //     elements from bagof-DR_BREAK that are from the first and the last run of strategy s
      //     in the repeat from above. For that, we used () as a separator (see comment above).
      //     We also have to check that the first change set from the current ruleset for r
      //     is not marked as "ignore". If it is, then we replace the current ruleset with the
      //     first one from the (already filtered) list returned by bagof-DR_BREAK (it could have
      //     been any other element of that list just as well) and then intersect that with
      //     the rest of the list.
      ; <map({rulename, rs, slabel:
          ?rulename
//          ; debug(!"dr-fix-and-merge-10>")
          ; dr-get-rule-set(|rulename) => [ChangeSet(_, _, _, slabel) | rs]
//          ; debug(!"dr-fix-and-merge-11>")
          ; <bagof-DR_BREAK>BreakCS(rulename, label)
//          ; debug(!"dr-fix-and-merge-12>")
          ; list-tokenize(|[()])
//          ; debug(!"dr-fix-and-merge-13>")
          ; first-last
//          ; debug(!"dr-fix-and-merge-14>")
          ; concat
//          ; debug(!"dr-fix-and-merge-15>")
          ; if <eq>(slabel, "ignore")
            then [<MkCons>(<id>, rs); dr-set-rule-set(|rulename) | id]; Tl
            else id
            end
//          ; debug(!"dr-fix-and-merge-16>")
          ; map(<MkCons>(<id>, rs); try(<merge>(rulename, <id>)))
//          ; debug(!"dr-fix-and-merge-17>")

//        @TODO destroy the break change sets

        })>rulenames

      ; !e
      ; where(<map(dr-commit-change-set(|<id>))> rulenames)
    |}

  dr-break(|rulename) =
    dr-break(|rulename, <DR_BREAK>Label)

  dr-break(|rulename, label) =
    where(
//      debug(!"dr-break-1>");
      dr-get-rule-set(|rulename) => rs
//      ; dr-print-rule-set(|rulename)
//      ; debug(!"dr-break-2>")

      // get the ruleset up to the fix point operator identified by <label> and the one from
      // within the structure over which the fix point operator was applied
      ; back-split-at(|<DR_BREAK>Fix(rulename, label))
//      ; dr-print-rule-set(|rulename)
//      ; debug(!"dr-break-3>")

      // build the change set with a snapshot of the current ruleset within the fix point
      // operator
      ; dr-build-break-change-set => bcs
//      ; debug(!"dr-break-4>")
//      ; where(<dr-print-rule-set>[bcs])
//      ; dr-print-rule-set(|rulename)

      // add to the rule which will be used back at the application of the fix point operator
      // to retrieve all the change sets pertaining to paths leading to a break
      ; rules(DR_BREAK.label :+ BreakCS(rulename, label) -> bcs)
//      ; debug(!"dr-break-5>")
//      ; dr-print-rule-set(|rulename)

      // go back to the active ruleset and mark the innermost change set with "ignore"
      ; !rs
//      ; debug(!"dr-break-6>")
//      ; dr-print-rule-set(|rulename)
      ; fetch(ChangeSet(id, id, id, !"ignore"))
//      ; debug(!"dr-break-7>")
//      ; dr-print-rule-set(|rulename)
      ; dr-set-rule-set(|rulename)
//      ; debug(!"dr-break-8>")
//      ; dr-print-rule-set(|"DR_BREAK")
//      ; dr-print-rule-set(|rulename)
    )

  /**
   * This strategy takes a pair of lists of change sets and rule scopes
   * and returns a change set which contains all the changes from the
   * change sets in the left member of the input pair which refer to
   * rule scopes in the right member of the input pair.
   */
  dr-build-break-change-set =

    // create the extra change set
    (?inFixRs, dr-start-change-set => rs@[bcs@ChangeSet(_, rmset, tbl, _) | _])

    // commit all change sets in inFixRs to the extra change set
    ; <reverse-map(
        ![<id> | rs]
        ; try(dr-commit-change-set(fail))
      )>inFixRs

    // collect all the scope ids of the rule scopes in inFixRs
    ; <filter(?RuleScope(_, Hashtable(<id>)))>inFixRs => scpids

    // remove all the elements from rmset that refer to rule scopes
    // whose scope id is part of scpids
    ; <iset-elements>rmset
    ; map({k, scpid :
        ?k@(scpid, _)
        ; try(<fetch-elem(?scpid)>scpids; <iset-remove(|k)>rmset)
      })

    // remove all the elements from tbl that refer to rule scopes
    // whose scope id is part of scpids
    ; <hashtable-keys>tbl
    ; map({k, scpid :
        ?k@(scpid, _)
        ; try(<fetch-elem(?scpid)>scpids; <hashtable-remove(|k)>tbl)
      })

    // return the built change set
    ; !bcs

  dr-fix-and-merge(merge1, merge2, s | rulenames1, rulenames2) =
    where(<map(fork-rule-sets)> rulenames1 => rs1;
          <map(fork-rule-sets)> rulenames2 => rs2)
    ; repeat(
        where(
          restore(
            s,
            where(
              <map(dr-discard-change-set(|<id>))> rulenames1;
              <map(dr-discard-change-set(|<id>))> rulenames2
            )
          )
          ; if and(<filter({?(rulename,<id>); <merge1>(rulename, <id>)})> rs1; []
                  ,<filter({?(rulename,<id>); <merge2>(rulename, <id>)})> rs2; [])
            then
              ?e; fail // no changes in any of the rules
            end
        )
      )
    ; !e
    ; where(<map(dr-commit-change-set(|<id>))> rulenames1
           ;<map(dr-commit-change-set(|<id>))> rulenames2)

strategies // fork with intersection and union

  /**
   * two-way split in data-flow (if-then-else) for list of rules
   */

  dr-fork-and-intersect(s1, s2 | rulenames) =
    dr-fork-and-merge(\ (rulename, rs) -> <dr-intersect-with(|rulename)> rs \
                     , s1, s2 | rulenames)

  /**
   * Fork and union of two rule-sets
   */

  dr-fork-and-union(s1, s2 | rulenames) =
    dr-fork-and-merge(\ (rulename, rs) -> <dr-union-with(|rulename)> rs \
                     , s1, s2 | rulenames)

  /**
   * Fork and combined union and intersection of two rule-sets
   */

  dr-fork-and-intersect-union(s1, s2 | rulenames1, rulenames2) =
    dr-fork-and-merge(\ (rulename, rs) -> <dr-intersect-with(|rulename)> rs \
                     ,\ (rulename, rs) -> <dr-union-with(|rulename)> rs \
                     , s1, s2 | rulenames1, rulenames2)

strategies // fix-point with intersection and union

  /**
   * loop in data-flow (while)
   */

  dr-fix-and-intersect(s | rulenames) =
    dr-fix-and-merge(\ (rulename, rs) -> <dr-intersect-symm(|rulename)> rs \
                    , s | rulenames)

  dr-fix-and-intersect(s | rulenames, label) =
    dr-fix-and-merge(\ (rulename, rs) -> <dr-intersect-symm(|rulename)> rs \
		    , s | rulenames, label)

  /**
   * Iterate union of two rule-sets
   */

  dr-fix-and-union(s | rulenames) =
    dr-fix-and-merge(\ (rulename, rs) -> <dr-union-symm(|rulename)> rs \
                    , s | rulenames)

  dr-fix-and-intersect-union(s | rulenames1, rulenames2) =
    dr-fix-and-merge( \ (rulename, rs) -> <dr-intersect-symm(|rulename)> rs \
                    , \ (rulename, rs) -> <dr-union-symm(|rulename)> rs \
                    , s | rulenames1, rulenames2)

strategies // n-way split

  /**
   * n-way split in data-flow (case)
   *
   * @todo : generalize to factor out table merge operation
   */

  dr-fold-and-intersect(empty, hd, tl : (a -> a) * a -> a | rulenames) =
    if empty then id
    else
      where(<map(!(<id>, <dr-get-rule-set(|<id>)>))> rulenames => rs0)
      ; dr-fold-and-intersect(empty, hd, tl | rulenames, rs0)
      ; where(<map(dr-commit-change-set(|<id>))> rulenames)
    end

  dr-fold-and-intersect(empty, hd, tl : (a -> a) * a -> a | rulenames, rs0) =
    if empty then id
    else
      where(
        <map({?(rulename,<id>)
              ; dr-start-change-set
              ; dr-set-rule-set(|rulename)})> rs0
      )
      ; hd
      ; where(
          <map(!(<id>, <dr-get-rule-set(|<id>)>))> rulenames => rs1
        )
      ; tl(dr-fold-and-intersect(empty, hd, tl | rulenames, rs0))
      ; where(
          <map({?(rulename, <id>); dr-intersect-with(|rulename)})> rs1
        )
    end

  /**
   * fork and intersect over a list
   *
   * @todo : generalize to factor out table merge operation
   */

  dr-map-and-intersect(s | rulenames) =
    let tl(s') = [id | s']
     in dr-fold-and-intersect([], [s|id], tl | rulenames)
    end

strategies // rule-set equality

  dr-eq-rule-sets =
  let rseq =
        ?(RuleScope(lbl1, tbl1), RuleScope(lbl2, tbl2))
      ; <iset-eq(|lbl2)> lbl1
      ; <hashtable-eq> (tbl1, tbl2)
    +   ?(ChangeSet(lbl1, rmset1, tbl1, _), ChangeSet(lbl2, rmset1, tbl2, _))
      ; <iset-eq(|lbl2)> lbl1
      ; <iset-eq(|rmset2)> rmset1
      ; <hashtable-eq> (tbl1, tbl2)
   in where(zip(rseq))
  end

strategies // debugging

  dr-debug-rule-set(|name) = dr-debug-rule-set(|name, "")

  dr-debug-rule-set(|name, msg) =
    where(
        (!msg => "" <+ say(!msg))
      ; <debug(!"Ruleset for: ")> name
      ; dr-print-rule-set(|name)
    )

  dr-print-rule-set(|name) =
    where(
      dr-get-rule-set(|name)
      ; dr-print-rule-set
    )

  dr-print-rule-sets(|names) =
    where(
      <map(debug; dr-print-rule-set(|<id>))> names
    )

  dr-print-rule-set =
    where(map(dr-print-scope))

  dr-print-rule-set-msg(|msg) =
    where(!msg => "" <+ say(<concat-strings>["\n--- BEGIN(", msg,  ") ---"]))
    ;  dr-print-rule-set
    ; where(!msg => "" <+ say(<concat-strings>["--- END  (", msg,  ") ---\n"]))

  dr-print-scope =
    ?RuleScope(labelset, tbl)
  ; where(
      debug
    ; <iset-elements; debug(!"labels: ")> labelset
    ; <hashtable-keys> tbl
          ; map(where(<fprintnl>(stderr, ["  ", <id>, " -> " ]))
          ; where(\ key -> <hashtable-get(|key)> tbl \
                  ; map(<fprintnl>(stderr, ["    ", <id>]))
                 )
         )
    )

  dr-print-scope =
    ?ChangeSet(labelset, rmset, tbl, slabel)
  ; where(
      debug
    ; <iset-elements; debug(!"labels: ")> labelset
    ; <iset-elements; debug(!"removed: ")> rmset
    ; <hashtable-keys> tbl
    ; map(where(<fprintnl>(stderr, ["  ", <id>, " -> "]))
          ; where(\ key -> <hashtable-get(|key)> tbl \
                  ; map(<fprintnl>(stderr, ["    ", <id>]))
                 )
         )
    ; <debug(!"system label: ")> slabel
    )
