/**
 * Some primitives for the manipulation of terms.
 */
module term
imports simple-traversal list-misc list-set

strategies

 /**
  * Build a term given a constructor name and a list of terms. 
  *
  * Note that this primitive strategy has been turned into a language construct. 
  *
  * The pattern f#(xs) denotes the decomposition of a term into its function symbol 
  * f and its list of arguments xs. This pattern can be used in matching ?f#(xs) 
  * and building !f#(xs) terms (so also in left- and right-hand sides of rules) and 
  * also as a congruence s1#(s2).
  *
  * E.g. <mkterm> (f, [t1,...,tn])  builds the constructor application f(t1,...,tn).
  */ 
  mkterm       = ?(c,ts); prim("SSL_mkterm",c,ts)

 /**
  * Decompose a term into a constructor name and a list of terms. 
  *
  * Note that this primitive strategy has been turned into a language construct. 
  *
  * The pattern f#(xs) denotes the decomposition of a term into its function symbol 
  * f and its list of arguments xs. This pattern can be used in matching ?f#(xs) 
  * and building !f#(xs) terms (so also in left- and right-hand sides of rules) and 
  * also as a congruence s1#(s2).
  *
  * E.g. <explode-term> f(t1,...,tn) is the inverse of mkterm and produces (f, [t1,...,tn]).
  *
  * Note that explode-term is equivalent to !(<get-constructor>, <get-arguments>).
  */ 
  explode-term = ?t; prim("SSL_explode_term",t)

 /**
  * Get the constructor of a term.
  *
  * Note that explode-term is equivalent to !(<get-constructor>, <get-arguments>).
  */

  get-constructor = ?t; prim("SSL_get_constructor", t)

 /**
  * Get the arguments of a term.
  *
  * Note that explode-term is equivalent to !(<get-constructor>, <get-arguments>).
  */

  get-arguments = ?t; prim("SSL_get_arguments", t)

 /**
  * Compare the address of two terms and succeeds if the address of the first is 
  * smaller than the address of the second.
  *
  * This predicate induces a total ordering on terms and can be used to sort terms. 
  * Note that this relation is valid in one session (but what happens after
  * rehashing), but not necessarily between two sessions.
  */
  address-lt   = ?(t1,t2); prim("SSL_address_lt",t1,t2)

 /**
  * Give the address of a term. 
  *
  * <address> t replaces t with its address (an integer).
  * This can be used to obtain a unique symbolic reference to a term.
  */
  address      = ?t; prim("SSL_address",t)
  
strategies 

  crush(nul, sum) : 
    _#(xs) -> <foldr(nul,sum)> xs

  crush(nul, sum, s) : 
    _#(xs) -> <foldr(nul,sum, s)> xs

  foldr-kids(nul,sum) =
    obsolete(!"foldr-kids/2; use crush/2");
    crush(nul, sum)

  foldr-kids(nul,sum,s) =
    obsolete(!"foldr-kids/3; use crush/3");
    crush(nul, sum, s)
    
strategies      

  node-size =
    crush(!0, add, !1)

  term-size =
    crush(!1, add, term-size)
  
strategies

  at-depth(depth, s) =
      !(<depth> (), <id>)
    ; topdown(
        {d :
           ?(0, <s> )
        <+ ?(d, <id>); all(!(<dec> d, <id>))
        }
      )  
  
/**
 * Occurence Counting.
 */
strategies

  nrofoccs(s) = 
    obsolete(!"nrofoccs/1; use occurrences/1");
    occurrences(s)

  om-occurrences(s) = 
    s; !1 <+ crush(!0, add, occurrences(s))

  occurrences(s) = 
    split(s; !1 <+ !0, crush(!0, add, occurrences(s))); add

