/**
 * Operations on integer lists
 */
module collection/list/integer
imports 
  collection/list/-
  term/integer

strategies

  sum = foldr(!0, add)

  average = split(sum, length); div

  list-min = list-accum(min)

  list-max = list-accum(max)

  list-accum(s) = !(<Tl>, <Hd>); foldl(s)

  add-lists = list-accum(zip(add <+ !""))

 /**
  * @inc sort-test
  */
  int-sort = sort-list(SortL(gt))

 /**
  * @inc is-interval-test
  */
  is-interval-from = 
  rec r(
    \ (low,[]) -> low \
    <+ {l: \ (low,[x|xs]) -> <r>(x,xs)
           where <add>(low,1) => l
               ; <eq>(x,l)\ }
  )

/**
 * Generates lists of numbers.
 * 
 * The given end point is never part of the generated list; <range> 10 generates a list of 10 values, 
 * exactly the legal indices for items of a sequence of length 10. It is possible to let the range 
 * start at another number.
 *
 * <range> 10 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 * <range> (5, 10)     => [5, 6, 7, 8, 9]
 *
 * The documentation of the range strategy is partly copied from the Python tutorial.
 *
 * @type  Int       -> [Int]
 * @type  Int * Int -> [Int]
 * @since 0.9.3
 * @inc   range
 */
strategies

  range = is-int; <range> (0, <id>)
  range = (is-int, is-int); range(|1)

/**
 * Generates lists of numbers using a specified step size.
 *
 * These range variants use a specified increment. This step size is allowed
 * to be negative.
 *
 * <range(|3)>   10          => [0, 3, 6, 9]
 * <range(|3)>   (0, 10)     => [0, 3, 6, 9]
 * <range(|-30)> (-10, -100) => [-10, -40, -70]
 *
 * @type step Int
 * @type      Int       -> [Int]
 * @type      Int * Int -> [Int]
 * @since     0.9.3
 * @inc       range
 */
strategies

  range(|step) = is-int; <range(|step)> (0, <id>)
  range(|step) = (is-int, is-int); range(<add> (<id>, step))

/**
 * Generates lists of numbers using a 'next' generator.
 *
 *  <range(<mul> (<id>, 2))> 
 *
 * @type next Int -> Int
 *
 * @type      Int       -> [Int]
 * @type      Int * Int -> [Int]
 * @since 0.9.3
 */
strategies

  range(next) = is-int; <range(next)> (0, <id>)
  range(next) = (is-int, is-int); range-next(next) <+ ![]

  /**
   * @warning private helper strategy, do not use directly
   */
  range-next(inc) :
      (start, end) -> [start | tail]
        where <inc> start => next
            ; ( (<lt-lt>  (start, next, end) + <lt-lt>  (end, next, start))
              ; <range(inc)> (next, end)
             <+ (<lt-leq> (start, end, next) + <leq-lt> (next, end, start))
              ; ![]
              ) => tail

rules

  is-interval:
    [x|xs] -> (x,<is-interval-from>(x,xs))
