module til-propconst
imports til-opt-lib
strategies

  io-til-propconst =
    io-wrap(propconst)

  propconst =
    PropConst
    <+ propconst-declaration
    <+ propconst-assign
    <+ propconst-block
    <+ propconst-if-then
    <+ propconst-if-then-else
    <+ propconst-while
    <+ propconst-for
    <+ all(propconst); try(EvalExp)

  propconst-block =
    Block({| PropConst : map(propconst) |})

  propconst-declaration =
    (?Declaration(x) <+ ?DeclarationTyped(x, t))
    ; rules( PropConst+x :- Var(x) )

  propconst-assign =
    Assign(?x, propconst => e)
    ; if <is-value> e then
        rules( PropConst.x : Var(x) -> e )
      else
        rules( PropConst.x :- Var(x) )
      end

  propconst-if-then =
    IfThen(propconst, id)
    ; (EvalIf; propconst
       <+ IfThen(id, {| PropConst: map(propconst) |}) /PropConst\ id)

  propconst-if-then-else =
    IfElse(propconst, id, id)
    ; (EvalIf; propconst
       <+ IfElse(id, {| PropConst: map(propconst) |}, id) /PropConst\
          IfElse(id, id, {| PropConst: map(propconst) |}))

  propconst-while =
    ?While(_, _)
    ; (/PropConst\* While(propconst, {| PropConst: map(propconst) |}))

  // we assume a semantics for the for loop which evaluates the
  // lower and upper bound only once, at the beginning of the loop
  propconst-for =
    For(?x, propconst, propconst, id)
    ; rules( PropConst.x :- Var(x) )
    ; (/PropConst\* For(id, id, id, {| PropConst: map(propconst) |}))
