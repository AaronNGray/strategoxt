module term-to-adot
imports Dot liblib
signature
  constructors
    Graph : Option
    Tree  : Option

strategies

  term-to-adot = 
    io-wrap(term-to-adot-options, to-adot)

  term-to-adot-options =
    Option("--graph", 
	where(<set-config>("--graph", ())); !Graph(), 
	!"--graph           visualize term keeping graph structure") 

  + Option("--tree",  
	where(<set-config>("--tree", ())); !Tree(), 
	!"--tree            visualize as tree ")

  to-adot =
    (test(<get-config> "--tree"); term-to-tree
     <+ test(<get-config> "--graph"); term-to-graph)
    ; graph-to-adot

strategies

  term-to-graph =
    rec x(
      ![(<address; NodeId>, <map(address; NodeId) <+ all(address; NodeId)>)
       | <foldr(![],union,x) <+ crush(![],union,x)>]
    )

  NodeId = 
    <conc-strings>("node", <int-to-string>)
    
  term-to-tree =
    if-verbose5(debug(!"term-to-tree: ")); 
    !(<new>, <id>);
    rec x(
      (id, map(!(<new>, <id>)) <+ all(!(<new>, <id>)))
      ; ![<(id, map(Fst) <+ all(Fst))>
         |<Snd; (foldr(![],union,x) <+ crush(![],union,x))>]
    )

rules

  graph-to-adot :
    edges -> Graph|[ digraph Term { ~stmt*:stms } ]|
    where <map(TupleEdgeToDot <+ ListEdgeToDot <+ EdgeToDot); concat> edges => stms

  ListEdgeToDot :
    (n0, ns) ->  
    Stmt* |[ ~id:n0 [label = "\"[]\""] ; 
             ~stmt*:<map(\ n1 -> Stmt|[ ~id:n0 -> ~id:n1 ; ]|\ )> ns ]|
    where <is-list> ns

  TupleEdgeToDot :
    (n0, ns) ->  
    Stmt* |[ ~id:n0 [label = "\"( )\""] ; 
             ~stmt*:<map(\ n1 -> Stmt|[ ~id:n0 -> ~id:n1 ; ]|\ )> ns1 ]|
    where <?""#(<id>)>ns => ns1

  EdgeToDot :
    (n0, i) -> 
    Stmt* |[ ~id:n0 [label = ~id:s] ; ]| 
    where <is-int> i
        ; <concat-strings>["\"", <int-to-string; escape> i, "\""] => s

  EdgeToDot :
    (n0, f#(ns)) -> 
    Stmt* |[ ~id:n0 [label = ~id:<escape; double-quote>f] ; 
             ~stmt*:<map( \ n1 -> Stmt|[ ~id:n0 -> ~id:n1 ; ]| \ )> ns ]|
